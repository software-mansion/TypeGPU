import { FuncParameterType } from 'tinyest';
import { getAttributesString } from '../../data/attributes.ts';
import { snip } from '../../data/dataTypes.ts';
import {
  type AnyWgslData,
  type AnyWgslStruct,
  isWgslData,
  isWgslStruct,
  Void,
} from '../../data/wgslTypes.ts';
import { MissingLinksError } from '../../errors.ts';
import { getMetaData, getName, setName } from '../../shared/meta.ts';
import type { ResolutionCtx } from '../../types.ts';
import {
  addArgTypesToExternals,
  addReturnTypeToExternals,
  applyExternals,
  type ExternalMap,
  replaceExternalsInWgsl,
} from '../resolve/externals.ts';
import { extractArgs } from './extractArgs.ts';
import type { Implementation } from './fnTypes.ts';

export interface TgpuFnShellBase<Args extends unknown[], Return> {
  readonly argTypes: Args;
  readonly returnType: Return;
  readonly isEntry: boolean;
}

export interface FnCore {
  applyExternals(newExternals: ExternalMap): void;
  resolve(ctx: ResolutionCtx, fnAttribute?: string): string;
}

export function createFnCore(
  shell: TgpuFnShellBase<unknown[], unknown>,
  implementation: Implementation,
): FnCore {
  /**
   * External application has to be deferred until resolution because
   * some externals can reference the owner function which has not been
   * initialized yet (like when accessing the Output struct of a vertex
   * entry fn).
   */
  const externalsToApply: ExternalMap[] = [];

  if (typeof implementation === 'string') {
    if (!shell.isEntry) {
      addArgTypesToExternals(
        implementation,
        shell.argTypes,
        (externals) => externalsToApply.push(externals),
      );
      addReturnTypeToExternals(
        implementation,
        shell.returnType,
        (externals) => externalsToApply.push(externals),
      );
    } else {
      if (isWgslStruct(shell.argTypes[0])) {
        externalsToApply.push({ In: shell.argTypes[0] });
      }

      if (isWgslStruct(shell.returnType)) {
        externalsToApply.push({ Out: shell.returnType });
      }
    }
  }

  const core = {
    applyExternals(newExternals: ExternalMap): void {
      externalsToApply.push(newExternals);
    },

    resolve(ctx: ResolutionCtx, fnAttribute = ''): string {
      const externalMap: ExternalMap = {};

      for (const externals of externalsToApply) {
        applyExternals(externalMap, externals);
      }

      const id = ctx.names.makeUnique(getName(this));

      if (typeof implementation === 'string') {
        const replacedImpl = replaceExternalsInWgsl(
          ctx,
          externalMap,
          implementation,
        );

        let header = '';
        let body = '';

        if (shell.isEntry) {
          const input = isWgslStruct(shell.argTypes[0])
            ? `(in: ${ctx.resolve(shell.argTypes[0])})`
            : '()';

          const attributes = isWgslData(shell.returnType)
            ? getAttributesString(shell.returnType)
            : '';
          const output = shell.returnType !== Void
            ? isWgslStruct(shell.returnType)
              ? `-> ${ctx.resolve(shell.returnType)}`
              : `-> ${attributes !== '' ? attributes : '@location(0)'} ${
                ctx.resolve(shell.returnType)
              }`
            : '';

          header = `${input} ${output} `;
          body = replacedImpl;
        } else {
          const providedArgs = extractArgs(replacedImpl);

          if (providedArgs.args.length !== shell.argTypes.length) {
            throw new Error(
              `WGSL implementation has ${providedArgs.args.length} arguments, while the shell has ${shell.argTypes.length} arguments.`,
            );
          }

          const input = providedArgs.args.map((argInfo, i) =>
            `${argInfo.identifier}: ${
              checkAndReturnType(
                ctx,
                `parameter ${argInfo.identifier}`,
                argInfo.type,
                shell.argTypes[i],
              )
            }`
          ).join(', ');

          const output = shell.returnType === Void
            ? ''
            : `-> ${
              checkAndReturnType(
                ctx,
                'return type',
                providedArgs.ret?.type,
                shell.returnType,
              )
            }`;

          header = `(${input}) ${output}`;

          body = replacedImpl.slice(providedArgs.range.end);
        }

        ctx.addDeclaration(`${fnAttribute}fn ${id}${header}${body}`);
      } else {
        // get data generated by the plugin
        const pluginData = getMetaData(implementation);

        if (pluginData?.externals) {
          const missing = Object.fromEntries(
            Object.entries(pluginData.externals).filter(
              ([name]) => !(name in externalMap),
            ),
          );

          applyExternals(externalMap, missing);
        }
        const ast = pluginData?.ast ?? ctx.transpileFn(String(implementation));

        // verify all required externals are present
        const missingExternals = ast.externalNames.filter(
          (name) => !(name in externalMap),
        );
        if (missingExternals.length > 0) {
          throw new MissingLinksError(getName(this), missingExternals);
        }

        // generate wgsl string
        const { head, body } = ctx.fnToWgsl({
          args: shell.argTypes.map((arg, i) =>
            snip(
              ast.params[i]?.type === FuncParameterType.identifier
                ? ast.params[i].name
                : `_arg_${i}`,
              arg as AnyWgslData,
            )
          ),
          argAliases: Object.fromEntries(
            ast.params.flatMap((param, i) =>
              param.type === FuncParameterType.destructuredObject
                ? param.props.map(({ name, alias }) => [
                  alias,
                  snip(
                    `_arg_${i}.${name}`,
                    (shell.argTypes[i] as AnyWgslStruct)
                      .propTypes[name] as AnyWgslData,
                  ),
                ])
                : []
            ),
          ),
          returnType: shell.returnType as AnyWgslData,
          body: ast.body,
          externalMap,
        });

        ctx.addDeclaration(
          `${fnAttribute}fn ${id}${ctx.resolve(head)}${ctx.resolve(body)}`,
        );
      }

      return id;
    },
  };

  // The implementation could have been given a name by a bundler plugin,
  // so we try to transfer it to the core.
  const maybeName = getName(implementation);
  if (maybeName !== undefined) {
    setName(core, maybeName);
  }

  return core;
}

function checkAndReturnType(
  ctx: ResolutionCtx,
  name: string,
  wgslType: string | undefined,
  jsType: unknown,
) {
  const resolvedJsType = ctx.resolve(jsType).replace(/\s/g, '');

  if (!wgslType) {
    return resolvedJsType;
  }

  const resolvedWgslType = wgslType.replace(/\s/g, '');

  if (resolvedWgslType !== resolvedJsType) {
    throw new Error(
      `Type mismatch between TGPU shell and WGSL code string: ${name}, JS type "${resolvedJsType}", WGSL type "${resolvedWgslType}".`,
    );
  }

  return wgslType;
}
