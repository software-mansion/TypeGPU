import { MissingLinksError } from '../../errors';
import type { AnyTgpuData, ResolutionCtx, Resource } from '../../types';
import { pluginAstInfo } from './astUtils';
import {
  type ExternalMap,
  applyExternals,
  replaceExternalsInWgsl,
} from './externals';
import type { Implementation } from './fnTypes';

export interface TgpuFnShellBase<Args extends unknown[], Return> {
  readonly argTypes: Args;
  readonly returnType: Return | undefined;
}

interface FnCore {
  label: string | undefined;
  applyExternals(newExternals: ExternalMap): void;
  resolve(ctx: ResolutionCtx, fnAttribute?: string): string;
}

export function createFnCore(
  shell: TgpuFnShellBase<unknown[], unknown>,
  implementation: Implementation<unknown[], unknown>,
): FnCore {
  /**
   * External application has to be deferred until resolution because
   * some externals can reference the owner function which has not been
   * initialized yet (like when accessing the Output struct of a vertex
   * entry fn).
   */
  const externalsToApply: ExternalMap[] = [];

  return {
    label: undefined as string | undefined,

    applyExternals(newExternals: ExternalMap): void {
      externalsToApply.push(newExternals);
    },

    resolve(ctx: ResolutionCtx, fnAttribute = ''): string {
      const externalMap: ExternalMap = {};

      for (const externals of externalsToApply) {
        applyExternals(externalMap, externals);
      }

      const id = ctx.names.makeUnique(this.label);

      if (typeof implementation === 'string') {
        const replacedImpl = replaceExternalsInWgsl(
          ctx,
          externalMap,
          implementation.trim(),
        );

        ctx.addDeclaration(`${fnAttribute}fn ${id}${replacedImpl}`);
      } else {
        // get data generated by the plugin
        const pluginData = pluginAstInfo.get(implementation);

        if (pluginData?.externals) {
          applyExternals(externalMap, pluginData.externals);
        }
        const ast = pluginData?.ast ?? ctx.transpileFn(String(implementation));

        // Verifying all required externals are present.
        const missingExternals = ast.externalNames.filter(
          (name) => !(name in externalMap),
        );

        if (missingExternals.length > 0) {
          throw new MissingLinksError(this.label, missingExternals);
        }

        const args: Resource[] = ast.argNames.map((name, idx) => ({
          value: name,
          dataType: shell.argTypes[idx] as AnyTgpuData,
        }));

        const { head, body } = ctx.fnToWgsl({
          args,
          returnType: shell.returnType as AnyTgpuData,
          body: ast.body,
          externalMap,
        });

        ctx.addDeclaration(
          `${fnAttribute}fn ${id}${ctx.resolve(head)}${ctx.resolve(body)}`,
        );
      }

      return id;
    },
  };
}
