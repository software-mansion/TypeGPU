/**
 * @vitest-environment jsdom
 */

import { beforeEach, describe, expect, vi } from 'vitest';
import { it } from '../utils/extendedIt.ts';

function getExampleURLs(category: string, name: string): {
  html: string;
  ts: string;
} {
  return {
    html:
      `../../../../apps/typegpu-docs/src/content/examples/${category}/${name}/index.html?raw`,
    ts:
      `../../../../apps/typegpu-docs/src/content/examples/${category}/${name}/index.ts`,
  };
}

function createDeepNoopProxy<T extends object>(
  target: T,
  accessedProperties = new Set<PropertyKey>(),
): T {
  return new Proxy(target, {
    get(obj, prop, receiver) {
      accessedProperties.add(prop);

      // biome-ignore lint/suspicious/noExplicitAny: we testing here
      return () => createDeepNoopProxy({} as any, accessedProperties);
    },
    set() {
      return true; // No-op set
    },
    apply() {
      // biome-ignore lint/suspicious/noExplicitAny: we testing here
      return createDeepNoopProxy({} as any, accessedProperties);
    },
  }) as T;
}

async function testExampleShaderGeneration(
  examplePath: string,
  controlTriggers: string[] = [],
) {
  const example = await import(examplePath);

  for (const trigger of controlTriggers) {
    const control = example.controls?.[trigger];
    if (control?.onButtonClick) {
      try {
        control.onButtonClick();
      } catch {}
    }
  }

  return example;
}

describe('exampleConformance', () => {
  beforeEach(() => {
    vi.resetAllMocks();
    vi.spyOn(HTMLCanvasElement.prototype, 'getContext').mockImplementation(
      () => {
        return createDeepNoopProxy(
          {} as unknown as CanvasRenderingContext2D,
          new Set(),
          // biome-ignore lint/suspicious/noExplicitAny: we testing here
        ) as any;
      },
    );

    let callbackInvoked = false;

    Object.defineProperty(
      HTMLVideoElement.prototype,
      'requestVideoFrameCallback',
      {
        value: (callback: VideoFrameRequestCallback) => {
          if (!callbackInvoked) {
            callbackInvoked = true;
            callback(
              0,
              { width: 640, height: 480 } as VideoFrameCallbackMetadata,
            );
          }
          return 0; // Mock ID
        },
        writable: true,
        configurable: true,
      },
    );
    // we also need to mock readyState to 4
    Object.defineProperty(HTMLVideoElement.prototype, 'readyState', {
      get: () => 4, // HAVE_ENOUGH_DATA
      configurable: true,
    });
  });

  it('matrix(next) example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('algorithms', 'matrix-next');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    const example = await testExampleShaderGeneration(urls.ts, ['Compute']);

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('matrix example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('algorithms', 'matrix-multiplication');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    const example = await testExampleShaderGeneration(urls.ts);

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('mnist inference example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('algorithms', 'mnist-inference');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    vi.stubGlobal('fetch', async (url: string) => {
      if (url.startsWith('/TypeGPU/assets/mnist-weights/')) {
        const mockHeader =
          "{'descr': '<f4', 'fortran_order': False, 'shape': (0, 0)}";
        const headerBuffer = new TextEncoder().encode(mockHeader);
        const totalBuffer = new ArrayBuffer(headerBuffer.length + 100);
        const view = new Uint8Array(totalBuffer);
        view.set(headerBuffer, 0);
        return new Response(totalBuffer);
      }
    });

    const example = await testExampleShaderGeneration(urls.ts);

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('ascii filter example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('image-processing', 'ascii-filter');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    const example = await testExampleShaderGeneration(urls.ts);

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('blur example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('image-processing', 'blur');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    vi.stubGlobal('fetch', async (url: string) => {
      if (url.startsWith('/TypeGPU/plums')) {
        const mockImage = new Uint8Array([0, 0, 0, 255, 255, 255, 255, 255]);
        return new Response(mockImage, {
          headers: {
            'Content-Type': 'image/png',
          },
        });
      }
    });
    vi.stubGlobal('createImageBitmap', async () => {
      return {
        width: 2,
        height: 2,
        close: () => {},
        getImageData: () => {
          return {
            data: new Uint8ClampedArray([0, 0, 0, 255, 255, 255, 255, 255]),
            width: 2,
            height: 2,
          };
        },
      } as ImageBitmap;
    });

    const example = await testExampleShaderGeneration(urls.ts);

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('camera thresholding example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('image-processing', 'camera-thresholding');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    const example = await testExampleShaderGeneration(urls.ts);

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('chroma keying example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('image-processing', 'chroma-keying');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    const example = await testExampleShaderGeneration(urls.ts);

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('image tuning example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('image-processing', 'image-tuning');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    vi.stubGlobal('fetch', async (url: string) => {
      if (url.startsWith('/TypeGPU/')) {
        const mockImage = new Uint8Array([0, 0, 0, 255, 255, 255, 255, 255]);
        return new Response(mockImage, {
          headers: {
            'Content-Type': 'image/png',
          },
        });
      }
    });
    vi.stubGlobal('createImageBitmap', async () => {
      return {
        width: 2,
        height: 2,
        close: () => {},
        getImageData: () => {
          return {
            data: new Uint8ClampedArray([0, 0, 0, 255, 255, 255, 255, 255]),
            width: 2,
            height: 2,
          };
        },
      } as ImageBitmap;
    });

    const example = await testExampleShaderGeneration(urls.ts);

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('3d fish example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('rendering', '3d-fish');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    // Mock ResizeObserver
    vi.stubGlobal(
      'ResizeObserver',
      vi.fn(() => ({
        observe: vi.fn(),
        unobserve: vi.fn(),
        disconnect: vi.fn(),
      })),
    );

    // Mock the loaders.gl modules before importing
    vi.doMock('@loaders.gl/core', () => ({
      load: vi.fn(async () => ({
        attributes: {
          POSITION: {
            value: new Float32Array([
              0,
              0,
              0,
              1,
              0,
              0,
              0,
              1,
              0,
              1,
              1,
              0,
              0,
              0,
              1,
              1,
              0,
              1,
            ]),
          },
          NORMAL: {
            value: new Float32Array([
              0,
              0,
              1,
              0,
              0,
              1,
              0,
              0,
              1,
              0,
              0,
              1,
              0,
              0,
              1,
              0,
              0,
              1,
            ]),
          },
          TEXCOORD_0: {
            value: new Float32Array([
              0,
              0,
              1,
              0,
              0,
              1,
              1,
              1,
              0,
              0,
              1,
              0,
            ]),
          },
        },
      })),
    }));

    vi.doMock('@loaders.gl/obj', () => ({
      OBJLoader: {},
    }));

    // Mock fetch for texture and model loading
    vi.stubGlobal('fetch', async (url: string) => {
      if (url.includes('.jpg') || url.includes('.png')) {
        const mockImage = new Uint8Array([
          255,
          0,
          0,
          255,
          0,
          255,
          0,
          255,
          0,
          0,
          255,
          255,
          255,
          255,
          255,
          255,
        ]);
        return new Response(mockImage, {
          headers: {
            'Content-Type': 'image/png',
          },
        });
      }
      if (url.includes('.obj')) {
        const mockObjData = `
v 0.0 0.0 0.0
v 1.0 0.0 0.0
v 0.0 1.0 0.0
vn 0.0 0.0 1.0
vn 0.0 0.0 1.0
vn 0.0 0.0 1.0
vt 0.0 0.0
vt 1.0 0.0
vt 0.0 1.0
f 1/1/1 2/2/2 3/3/3
`;
        return new Response(mockObjData, {
          headers: {
            'Content-Type': 'text/plain',
          },
        });
      }
    });

    vi.stubGlobal('createImageBitmap', async () => {
      return {
        width: 2,
        height: 2,
        close: () => {},
      } as ImageBitmap;
    });

    await testExampleShaderGeneration(urls.ts);

    // this example takes a
    await new Promise((resolve) => setTimeout(resolve, 100));

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('box-raytracing example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('rendering', 'box-raytracing');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    const example = await testExampleShaderGeneration(urls.ts);

    await new Promise((resolve) => setTimeout(resolve, 100));

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('camera thresholding example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('rendering', 'caustics');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    const example = await testExampleShaderGeneration(urls.ts);

    await new Promise((resolve) => setTimeout(resolve, 100));

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });

  it('camera thresholding example should procude valid code', async ({ device }) => {
    const urls = getExampleURLs('rendering', 'cubemap-reflection');
    const html = await import(urls.html);
    document.body.innerHTML = html.default;

    vi.stubGlobal('fetch', async (url: string) => {
      if (url.startsWith('/TypeGPU/')) {
        const mockImage = new Uint8Array([0, 0, 0, 255, 255, 255, 255, 255]);
        return new Response(mockImage, {
          headers: {
            'Content-Type': 'image/png',
          },
        });
      }
    });
    vi.stubGlobal('createImageBitmap', async () => {
      return {
        width: 2,
        height: 2,
        close: () => {},
        getImageData: () => {
          return {
            data: new Uint8ClampedArray([0, 0, 0, 255, 255, 255, 255, 255]),
            width: 2,
            height: 2,
          };
        },
      } as ImageBitmap;
    });
    vi.stubGlobal(
      'ResizeObserver',
      vi.fn(() => ({
        observe: vi.fn(),
        unobserve: vi.fn(),
        disconnect: vi.fn(),
      })),
    );

    const example = await testExampleShaderGeneration(urls.ts);

    await new Promise((resolve) => setTimeout(resolve, 100));

    const calls = device.mock.createShaderModule.mock.calls as unknown as Array<
      [GPUShaderModuleDescriptor, { label?: string }]
    >;
    const shaderCodes = calls.map(([descriptor]) => descriptor.code).join(
      '\n\n',
    );

    expect(shaderCodes).toMatchInlineSnapshot();
  });
});
