---
title: From Triangle to Boids Simulation
description: A tutorial that will guide you through the process of creating a simple triangle rendering program and incrementally adding features to create a boids simulation.
---

import { Icon } from '@astrojs/starlight/components';


<div class="container flex flex-row justify-around content-evenly">
  <img src="/assets/ttbt-triangle.png" alt="Triangle" class="rounded-lg !size-1/3 !aspect-square !m-0 !p-1"/>
  <Icon name="right-arrow" color="white" size="5rem" />
  <img src="/assets/ttbt-boids.png" alt="Triangle" class="rounded-lg !size-1/3 !aspect-square !m-0 !p-1"/>
</div>

In this tutorial, we will explore the capabilities of TypeGPU by transforming a simple program that draws a triangle on the screen into a boids simulation. While creating the boids simulation, we will learn about the following TypeGPU concepts:

- Creating and using a TypeGPU runtime
- Writing shader code in TypeGPU
- Creating vertex and storage buffers and using them in shaders
- Creating render and compute pipelines
- Understanding and using slots

Along the way, there will be places where you might want to follow a different path from the one in the tutorial.
Feel free to do so! There will be checkpoints where you can compare your code with the tutorial code and see if it works as expected.
The checkpoints will also include comparisons with WebGPU code, showing how TypeGPU helps you write less boilerplate code.

Letâ€™s start with a simple program that draws a triangle on the screen.
First, we need to set up the canvas and our runtime.
This setup will mostly look very similar in every project that draws something to the screen.

```ts
// triangle.ts
import { createRuntime } from 'typegpu'
import { addElement } from '@typegpu/example-toolkit';

// create the runtime and get the GPUDevice
const runtime = await createRuntime();
const device = runtime.device;

// add the canvas element and get the context
const canvas = await addElement('canvas', {aspectRatio: 1});
const context = canvas.getContext('webgpu') as GPUCanvasContext;

// configure the canvas context
const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
context.configure({
  device,
  format: presentationFormat,
  alphaMode: 'premultiplied',
});
```

import { Aside } from '@astrojs/starlight/components';
import { LinkCard } from '@astrojs/starlight/components';

<Aside type="tip">

We're creating a canvas by running the `addElement` function from our example toolkit, but that is not the only way! You can use the standard `document.createElement('canvas')` and append it to the document.

</Aside>

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Let's draw a triangle!

Now that we have our canvas setup, we can start drawing on it. We will start by creating a simple shader that will draw a triangle.

```ts
import { wgsl, builtin } from 'typegpu'

const vertexCode = wgsl`
  var verticies = array<vec2f, 3>(
    vec2(0.0, 0.5),
    vec2(-0.5, -0.5),
    vec2(0.5, -0.5)
  );

  // we can use builtin.vertexIndex to let TypeGPU
  // know that we want to access the `vertexIndex` WGSL builtin
  let pos = vec4f(verticies[${builtin.vertexIndex}], 0.0, 1.0);
`;
```

<Aside type="caution">
  Pay attention to how the vertex shader code looks.
  There is no function declaration and no return statement! That is by design - TypeGPU will take care of that.
</Aside>

Since there is no function declaration, there is no place for defining parameters - but don't worry,
every used builtin and vertex shader will be properly added by TypeGPU.

```ts
const fragmentCode = wgsl`
  // let's go with a simple purple for now
  return vec4(0.7686, 0.3922, 1.0, 1.0);
`;
```

### Time to create a render pipeline
import { Card, CardGrid } from '@astrojs/starlight/components';

The API for creating a pipeline in TypeGPU is similar to the WebGPU API but with a few differences.
<CardGrid>
  <Card title="Layouts" icon="seti:bicep">
    There is no need to pass any group layouts. They are all inferred automatically by the library.
  </Card>
  <Card title="Modules" icon="setting">
    The module field in both vertex and fragment objects is replaced with "code" which accepts wgsl code.
  </Card>
  <Card title="Vertex" icon="setting">
    Apart from the code field, the vertex object has an output field, which maps the output of the vertex shader to the next stage.
    It works basically as an "export" from the vertex shader. The variables with matching keys will be packed into a struct and passed to the fragment shader.
  </Card>
  <Card title="Fragment" icon="setting">
    Variables present in the vertex output can be used inside the fragment code with no additional setup. The target field remains unchanged.
  </Card>
</CardGrid>

```ts
const pipeline = runtime.makeRenderPipeline({
  vertex: {
    code: vertexCode,
    output: {
      [builtin.position] : 'pos'
    }
  },
  fragment: {
    code: fragmentCode,
    target: [{
      format: presentationFormat
    }]
  },
  primitive: {
    topology: 'triangle-list'
  }
})
```

Now all we need to do is execute the pipeline. To do so, we need to pass `GPURenderPassDescriptor` along with the `vertexCount`.

```ts
import { onFrame } from '@typegpu/example-toolkit';

onFrame(() => {
  pipeline.execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
  });
});
```
<Aside type="danger" title="The code above draws nothing!">
  The `pipeline.execute()` method encodes all the necessary commands, but they will not be queued until we either read from a buffer or call `runtime.flush()`.
</Aside>

```diff lang=ts
onFrame(() => {
  pipeline.execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
  });
  runtime.flush();
})
```

## Now let's have a look at our program and compare it to WebGPU

<Tabs>
  <TabItem label="TypeGPU">
  <details>
  <summary>Show code</summary>
    ```ts
    import { wgsl, createRuntime, builtin } from 'typegpu'
    import { addElement, onFrame } from '@typegpu/example-toolkit';

    const runtime = await createRuntime();
    const device = runtime.device;

    const canvas = await addElement('canvas', {aspectRatio: 1});
    const context = canvas.getContext('webgpu') as GPUCanvasContext;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'premultiplied',
    });

    const pipeline = runtime.makeRenderPipeline({
      vertex: {
        code: wgsl`
          var verticies = array<vec2f, 3>(
            vec2(0.0, 0.5),
            vec2(-0.5, -0.5),
            vec2(0.5, -0.5)
          );

          let pos = vec4f(verticies[${builtin.vertexIndex}], 0.0, 1.0);
        `,
        output: {
          [builtin.position] : 'pos'
        }
      },
      fragment: {
        code: wgsl`
          return vec4(0.7686, 0.3922, 1., 1.0);
        `,
        target: [{
          format: presentationFormat
        }]
      },
      primitive: {
        topology: 'triangle-list'
      }
    })

    onFrame(() => {
      pipeline.execute({
      colorAttachments: [
          {
            view: context.getCurrentTexture().createView(),
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
        vertexCount: 3,
    })

    runtime.flush();
    })
    ```
    </details>
    <LinkCard
      title="Run this in the playground"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgdwOYGcA2AaOBjKAUwEMZCAlAVwDsZRDcAjS4TO6uAXzgDMoIQcAOQwAnmEKowlIQChQkWIjjEAJqoCimQiEK1cEagDEoxXV179BQgAJiJUygHpCADzNhtAWhgQImAGtgGCEAbllZPEN0eCgaOnMAXhVkYmD8IlIKePoACgBKcKjqGLhVQgA3YDxCOGS42noAOnKqmvDI6Pg8YmoK4nQ6lLT4NU1tXVpcoR6%2BgaFcBAGJPBhyUmAIAC44AEZOQs6S7sMyV3hk2f70JtRCGABhU7cYaeRCRkchfJVBgHEAAoAVQevWuT1oLyKXTgYCI6D0MA2hiM0BApCG1GIVVQpGgt2kt3uAKIPEIUCIqlBc3QqKg6NehyOZxgTWKPGAqEoRFyCFkcDKlWqDH5vDRpB2cMICNoyOM4pg2FFxEwYAAFsQALIQco7IRSkCUNjATzAQiqBayA4dYqlMAmwiYYDUWr1HK6JrogIUPTlKAAh1Ol280UVclnHZ8gUCqK6lAYTAAA1F0bg-SgafD1TNg2SxApxFEAB4w3gAEw8XAAZgAfLkU6nM%2BXcgAGJot3BtgCs%2BSVjejpbLuS83dwI6aPb7-abQ9HcHHPYbAqZ-e08EguabABYeLkw7Bs9KANoAEgQzFY7Ca%2B7OAElqOVXJwALqd9u4Xbtw6pxNTgUQSgYGkGBIyXOAjwvY1qCaDdgk2ahnzgPUNzkVNOFFTgpz4YhUEmEDEAbWNCB2NAsGTfsiBgbkOFLLdWyaAB2AA2AAOJi3yrABOMsyw-Jo%2BJbb9o1-BskSgO58KPKNGx4BVJXhRE5TpBkGxfDCpzhUA4LDUDU18SBMAgVBRD1GAoGAXpUG8J0YlQrgrXyCIUVMXRcgKOoawIgV7QkINCCaNxCDwQDCBDGN-GgABBGAkTwNU8PQHYjzA6T%2ByqQhkB2YoWSJR5uSIWgABUXm5UL8jZTIyAANTNZACj-Rs8G0fMqpVShiPAjs4C6nrXzAgVDLUAB5MA9SakgoEtac4BiaBCBGvVZqIKbG0whs%2BtTG83CeeIdirKcDgiAUGgSfyeEwSh0DVApwgOIA"
      target="_blank"
    />
  </TabItem>
  <TabItem label="WebGPU">
  <details>
  <summary>Show code</summary>
    ```ts
    import { addElement, onFrame } from '@typegpu/example-toolkit';

    const adapter = await navigator.gpu?.requestAdapter();
    const device = await adapter?.requestDevice();

    if (!device) {
      throw new Error('Failed to acquire a device')
    }

    const canvas = await addElement('canvas', {aspectRatio: 1});
    const context = canvas.getContext('webgpu') as GPUCanvasContext;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'premultiplied',
    });

    const pipeline = device.createRenderPipeline({
      layout: 'auto',
      vertex: {
        module: device.createShaderModule({
          code: `
            @vertex
            fn main(
              @builtin(vertex_index) VertexIndex : u32
            ) -> @builtin(position) vec4f {
              var pos = array<vec2f, 3>(
                vec2(0.0, 0.5),
                vec2(-0.5, -0.5),
                vec2(0.5, -0.5)
              );

              return vec4f(pos[VertexIndex], 0.0, 1.0);
            }
          `,
        }),
      },
      fragment: {
        module: device.createShaderModule({
          code: `
            @fragment
            fn main() -> @location(0) vec4f {
              return vec4(0.7686, 0.3922, 1.0, 1.0);
            }
          `,
        }),
        targets: [
          {
            format: presentationFormat,
          },
        ],
      },
      primitive: {
        topology: 'triangle-list',
      },
    });


    onFrame(() => {
      const commandEncoder = device.createCommandEncoder();
      const textureView = context.getCurrentTexture().createView();

      const renderPassDescriptor: GPURenderPassDescriptor = {
        colorAttachments: [
          {
            view: textureView,
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
      };

      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.draw(3);
      passEncoder.end();

      device.queue.submit([commandEncoder.finish()]);
    })

    ```
    </details>
    <LinkCard
      title="Run this in the playground"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoKIBsCmIcB2MANHBAQGJTL5wC%2BcAZlBCHAOQACMAnmDgHMwAVwD0OAB40wuALQwIELAGtgMdgG4AUFoDG5AM7w0yMDBxQ4AXhQB3ZGrgFkAN2ADkCqADohwgPzeUDgAjsI4RgCCqKbmUAAUAJTa%2BgRGcKg4bro41nYOxjFmFoHBYREwACJZwDlJ2lrAjPEAhJnZOImIWnBwMAAWLLZOOMMYUCwJ7BQOuKh9ECi6YcDBKBk1OeyJWnQ6qem6yAQuyAZ5yPaOaJi4%2BETx7EcnZ%2BykCGf8ujAASp7AEAAXHAAIx0ZJ6QzwVLmCTwGzPU4GXw4GAAYXIsJgj1sOAARn5tihzgBxAAKAFU0cckRiiJIYCkoXAwMEDIQYP9yBRoCBPHlnG4PF5fCIUTAycFGBZgqhqS8DDyoHzsRDIfS4d5Uox3MJgvEED0Nh1iEbGLzPMDWREOVzKBaSEbkFgwP1kABZCCZYHsa0gYRYGDAGTAHCoN67NUHeBgYM4LDAAi5GztWo4LXBTw4H6ETJQMlxhNJg1GrDIHgQYQwH3IKsQCO9FwWWHAw29XogL0BnDA1M5DM4LMAZTdec9qG7Jfb7f03rgAAMjdPepwm7BJEvl4wCHA%2BYn4pvl3BOHjhMBA-u17CAPqJzISLoANWbkgAkgR73BgcIAMwAJkPdsulkAA%2BY9T3PIMCHiSADDUAECC6JtdAAFkYboj2nU5LFgi4JnLAAeZC-0YUgfxAg9MOXYj4gABm8WjSHogBWRJTSorCcF0P94lkFjSD47xWPYjjGy4nj%2BLgQTWMA6c1VE4IYD1HdkLQmCIAMABtZ91wkd97wAXSYhjSBBBiISovYj3nETenBES6BE5hkAEe5qww9tOwnXBe02dNdEzcwRzQCxx0nNtl1nHsF1k49nNcjlYu3XcHGg4CwM4LAICOINyDopCuLQjyqMU5S4FUujvAAdgANgADhq4yfwATj-P9TJM0FzO0SzAJszd7M3TkoAEVEDGBTTAIio9zWVS0WTZW1cvtObHSPRzNyMo0Nt6VlQHgptWyGiBICygQeB9GAoGAY4BDkBMjAbehTXBBotG5ah8HiJJrDAiLozgfQQD5D8MAIKLLBTPyByzDFgeOTBwa9Cx6iNAGsT1HBH1DYYEUxBlxTRPVgiIAAVBlMaSGHzGx0ZUbR5kSbzMkzgMaoDAC4MvGBckKRzD8LBZgw2YiTmzGgPJpsBpRoEiGBOV0fo3PGuBJqPKWsJx4EMeCWnbFsyLcGQKBH2dcIJsYuBLetraqKytAAHkwB9XQjagJ6jyMaAcCdn0veCD32x29tbfoBpegBsBWbBiG8iBkHEYh7w8UERN%2BeZ1n4iZwXWfZsWvAsllo6RvNvHZCVC0THAYMrpNC6j4WY%2BRnxUGoWx4h-evi6T3N6d6Pt03KcIy%2BEPEQDUeJNPjhGm9LnUCGAAx%2BiSAyIXBLQgA"
      target="_blank"
    />
  </TabItem>
</Tabs>

<Aside>The advantages of using TypeGPU may not be immediately apparent. While we've reduced some lines of code, is it truly worth it? Let's continue and find out!</Aside>

## Let's add some parametrization

A simple static triangle has its charm, but let's add some excitement by incorporating parameters into our shader.
We'll introduce x and y position buffers, along with a rotation buffer, allowing us to move the triangle around. Isn't that **awesome**?

### But first, let's upgrade our program a little

Currently, the vertices are hardcoded in the shader.

```wgsl
var verticies = array<vec2f, 3>(
  vec2(0.0, 0.5),
  vec2(-0.5, -0.5),
  vec2(0.5, -0.5)
);

let pos = vec4f(verticies[${builtin.vertexIndex}], 0.0, 1.0);
```

That's certainly not the best approach. Instead, let's create a vertex buffer to store the coordinates and use that in the shader.

```ts
import { vec2f, arrayOf } from 'typegpu/data';

const triangleVertex = wgsl
  .buffer(arrayOf(vec2f, 3), [
    [0.0, 0.5],
    [-0.5, -0.5],
    [0.5, -0.5],
  ])
  .$allowVertex('vertex');
```
<Aside type="tip">
You can also pass `'instance'` into the `$allowVertex()` method, which will alter how the values are read.
</Aside>

Now we can use the buffer in the shader.

<Tabs>
  <TabItem label="Before">
    ```ts
    const vertexCode = wgsl`
      var verticies = array<vec2f, 3>(
        vec2(0.0, 0.5),
        vec2(-0.5, -0.5),
        vec2(0.5, -0.5)
      );

      let pos = vec4f(verticies[${builtin.vertexIndex}], 0.0, 1.0);
    `;
    ```
  </TabItem>
  <TabItem label="After">
    ```ts
    const vertexCode = wgsl`
      let pos = vec4f(${triangleVertex.asVertex()}, 0.0, 1.0);
    `;
    ```
    <Aside title="Thats it!">TypeGPU will take care of the rest.</Aside>
  </TabItem>
</Tabs>

Great! Now that we have that sorted, let's add some parameters to our shader. Here's the game plan:

import { Steps } from '@astrojs/starlight/components';

<Steps>

1. Create the parameters:

   ```ts
   import { addSliderParam } from '@typegpu/example-toolkit';

   const params = {
     rotation: addSliderParam('rotation (rad)', 0, {
       min: 0,
       max: 3.14 * 2,
       step: 0.1,
     }),
     x: addSliderParam('x', 0, {
       min: -1,
       max: 1,
       step: 0.1,
     }),
     y: addSliderParam('y', 0, {
       min: -1,
       max: 1,
       step: 0.1,
     }),
   };
   ```

2. Create the buffers:

   ```ts
   import { f32 } from 'typegpu/data';

   const rotationBuffer = wgsl.buffer(f32, params.rotation).$allowUniform();
   const xBuffer = wgsl.buffer(f32, params.x).$allowUniform();
   const yBuffer = wgsl.buffer(f32, params.y).$allowUniform();
   ```

3. Prepare a helper function to rotate the triangle:

   ```ts
   const rotate = wgsl.fn`(v: vec2f, angle: f32) -> vec2f {
     let pos = vec2(
       (v.x * cos(angle)) - (v.y * sin(angle)),
       (v.x * sin(angle)) + (v.y * cos(angle))
     );
     return pos;
   }`;
   ```

4. Use the buffers inside the shader code:

   ```ts
   const vertexCode = wgsl`
    let rotated = ${rotate}(
      ${triangleVertex.asVertex()},
      ${rotationBuffer.asUniform()}
    );

    let offset = vec2f(
      ${xBuffer.asUniform()},
      ${yBuffer.asUniform()}
    );

    let pos = vec4f(rotated + offset, 0.0, 1.0);
   `;
   ```
   <Aside>
    Remember that we don't need to index into `triangleVertex` because we made it a vertex buffer.
    </Aside>

4. VoilÃ ! We now have a movable and rotatable triangle.

</Steps>
<Aside type="tip">
Remember, there are many ways to achieve the same result.
This is just one method. Having three separate buffers for x, y, and rotation might not be the most efficient approach.
Feel free to experiment with different methods to find the one that best suits your needs.
</Aside>

### Let's compare TypeGPU to WebGPU again:

<Tabs>
  <TabItem label="TypeGPU">
  <details>
  <summary>See code</summary>
    ```ts
    import { wgsl, createRuntime, builtin } from 'typegpu';
    import { f32, vec2f, arrayOf } from 'typegpu/data';
    import { addElement, onFrame, addSliderParam } from '@typegpu/example-toolkit';

    const runtime = await createRuntime();
    const device = runtime.device;

    const canvas = await addElement('canvas', { aspectRatio: 1 });
    const context = canvas.getContext('webgpu') as GPUCanvasContext;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'premultiplied',
    });

    const params = {
      rotation: addSliderParam('rotation (rad)', 0, {
        min: 0,
        max: 3.14 * 2,
        step: 0.1,
      }),
      x: addSliderParam('x', 0, {
        min: -1,
        max: 1,
        step: 0.1,
      }),
      y: addSliderParam('y', 0, {
        min: -1,
        max: 1,
        step: 0.1,
      }),
    };

    const rotationBuffer = wgsl.buffer(f32, params.rotation).$allowUniform();
    const xBuffer = wgsl.buffer(f32, params.x).$allowUniform();
    const yBuffer = wgsl.buffer(f32, params.y).$allowUniform();

    const triangleVertex = wgsl
      .buffer(arrayOf(vec2f, 3), [
        [0.0, 0.5],
        [-0.5, -0.5],
        [0.5, -0.5],
      ])
      .$allowVertex('vertex');

    const rotate = wgsl.fn`(v: vec2f, angle: f32) -> vec2f {
      let pos = vec2(
        (v.x * cos(angle)) - (v.y * sin(angle)),
        (v.x * sin(angle)) + (v.y * cos(angle))
      );
      return pos;
    }`;

    const pipeline = runtime.makeRenderPipeline({
      vertex: {
        code: wgsl`
          let rotated = ${rotate}(
            ${triangleVertex.asVertex()},
            ${rotationBuffer.asUniform()}
          );

          let offset = vec2f(
            ${xBuffer.asUniform()},
            ${yBuffer.asUniform()}
          );

          let pos = vec4f(rotated + offset, 0.0, 1.0);
        `,
        output: {
          [builtin.position]: 'pos',
        },
      },
      fragment: {
        code: wgsl`
          return vec4(0.7686, 0.3922, 1., 1.0);
        `,
        target: [
          {
            format: presentationFormat,
          },
        ],
      },
      primitive: {
        topology: 'triangle-list',
      },
    });

    onFrame(() => {
      pipeline.execute({
        colorAttachments: [
          {
            view: context.getCurrentTexture().createView(),
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
        vertexCount: 3,
      });

      runtime.flush();
    });

    ```
    </details>
    <LinkCard
      title="Run it in the playground!"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgdwOYGcA2AaOBjKAUwEMZCAlAVwDsZRDcAjS4TO6uAXzgDMoIQcAOQwAnmEKowlIQG4AUKEixEvAMwAmXADdCeDT1zEoUYqIDyPLr36CR4ydID0AE1LE5i8NHhJiLlwBRTEIQQlpcCGoAMVMwowCAZUxgF0IoAAVjYkFuPgFhAAExCSlKJ0IADxywEIBaGAgITABrYBhPeTwo9HgoGjowuABeOGJkYnb8IlIKAfoACgBKBW7qXrg07WA8QhG4ftp6ADotncIFLp74PGJqbWJ0ffHJ%2BH8gkLDaBaFb%2B8ehLg-OgJHgYORSMAIAAuOAARi4Kyu6xuUTIlXgoz%2BD3Qx1QhBgAGE0VUYD9kIRGGUhEsxk8AOIZACqhLuOOJtFJq2ucDARHQ4RgkKi0WgIFI%2B2oxG2qFI0Dx0jxBIyRB46SILlZ-3Qoqg4rJSOR6JgxzWPGAqEoRAWCHkcE2hG2u2wdt4YtIsL5hAFtGFMXdMBd9uImDAAAtiABZCBpWFCL0gShsYC1YCEFyA%2BScQ1rDZgbIgJ6jW32-hCuhRWHvZKpdJZOI-Mt%2BuALUwuJaAuAABiBrvtIGA1FhPb7cHFlVhamOcIALHAAFRwLSj3qEMDD6dBxFbidjJIpNKZAs-SqdnuIUcDodwOpwrf94i7u8rsjr7ub13ZreiKv72tHhshFEM9e3tftB1hW97zHR9YWfMC4FXN8uw-e0vyzS5cz6CByyhagACFKB4NUoH2NAsGOZhiPSBYeE0XB8ziXEmwraglmOAASENMAgZAmWoYAeDFZZuRROBKkI6jSNGcjMEooiSNo%2BjeQLXFKnYrjMB4viBKEvURORDZREkkiyIwOSqMUuitBUpjjlEDTuN4-jBOEnMeRgKBgDuVAQgANXSdEzKwV15KkhZjFMCweAWXR9EMOA1CWXAAG1RxSlDzxQgBWABdaCUrqHLcCK448oK4qbxy-LXVypZQs07SAtgKofl0FrT3csSWL2GTzOOHhqAAA1i2E4oMIxqF8whYWs2k6gAPjgcarBLOAQngSAi2WvQNAWUdYuOSoF3wCB0AiqaQiWeaW20eyTvQQcLum67oMO47F0e6hnqu2kAGpbvuxdunOnzftdJFSwJK0OC2hROCGzCeTAFNCBSaheoOeYwmOcUWgocJDwyVH0cIG1XXa9FYTW%2B1uljFBzKG0d7Q2g4cNmFx9g4hAes4faEIQ7nPO8y7CGa9FjkecXWqWThoMFnn2dYkz0kl9AXL0kBlk4Zm4ENAX1oJOAIGIgVMR2%2BL%2BYNuBuYkhTVceDW3Ll3X7W54z7agNWnf02Xdf1gXWa2-Y4pnGKes5gGTZ4M3cEy3A4WOLtIbAoboIgSgYGkGBqd1lLmFYdhji29o8NyuMtszBCXbQrc%2BGIVAvhzi8ELpmaGawJmDaIGAYYtmcFhQgB2AA2AAOEe4%2BONQAE4NBsxOE6TlP7TT0chSgfFm7Sg2aYFzWPV5flBT9XV9XlrhoJq2vXT5UBS90XOEMaSAeNQH9hGFsHCDqFJeiry%2BWZDQijiGTZYIwlprRRhIUmxwqh6EzmTPe3QeJQAAIIwCFHgMMTd0Cwh3gLPeCFtiEGQLCNYxolREitEQWgAAVUkVoybsQICQMgfk0zIGWBfWmIRjB%2BRDJQduGU46iO7Nfa2PF-DmDfL8PhUAAEG16NAQgMi4zKKIIosCNcwISPtJTKoxIBiTi3NmS4pZsaEAGpgSg6AwwGTMfIIAA"
      target="_blank"
    />
  </TabItem>
  <TabItem label="WebGPU">
  <details>
  <summary>See code</summary>
    ```ts
    import { addElement, onFrame, addParameter } from '@typegpu/example-toolkit';

    const adapter = await navigator.gpu?.requestAdapter();
    const device = await adapter?.requestDevice();

    if (!device) {
      throw new Error('Failed to acquire a device');
    }

    const canvas = await addElement('canvas', { aspectRatio: 1 });
    const context = canvas.getContext('webgpu') as GPUCanvasContext;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'premultiplied',
    });

    const triangleVertexData = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);

    const triangleVertexBuffer = device.createBuffer({
      size: triangleVertexData.byteLength,
      usage: GPUBufferUsage.VERTEX,
      mappedAtCreation: true,
    });
    new Float32Array(triangleVertexBuffer.getMappedRange()).set(triangleVertexData);
    triangleVertexBuffer.unmap();

    const parametersBuffer = device.createBuffer({
      size: 4 * 3,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    addParameter(
      'rotation',
      {
        initial: 0,
        min: 0,
        max: 3.14 * 2,
        step: 0.1,
      },
      (value) => {
        const data = new Float32Array([value]);
        device.queue.writeBuffer(parametersBuffer, 0, data);
      },
    );

    addParameter(
      'x',
      {
        initial: 0,
        min: -1,
        max: 1,
        step: 0.1,
      },
      (value) => {
        const data = new Float32Array([value]);
        device.queue.writeBuffer(parametersBuffer, 4, data);
      },
    );

    addParameter(
      'y',
      {
        initial: 0,
        min: -1,
        max: 1,
        step: 0.1,
      },
      (value) => {
        const data = new Float32Array([value]);
        device.queue.writeBuffer(parametersBuffer, 8, data);
      },
    );

    const wgslCode = `
      fn rotate(v: vec2f, angle: f32) -> vec2f {
        let pos = vec2(
          (v.x * cos(angle)) - (v.y * sin(angle)),
          (v.x * sin(angle)) + (v.y * cos(angle))
        );
        return pos;
      };

      struct Parameters {
        rotation : f32,
        x : f32,
        y : f32,
      };

      @binding(0) @group(0) var<uniform> params : Parameters;

      struct VertexOutput {
        @builtin(position) position : vec4f
      };

      @vertex
      fn mainVert(@location(0) v: vec2f) -> VertexOutput {
        let rotated = rotate(v, params.rotation);
        let offset = vec2(params.x, params.y);

        return VertexOutput(vec4f(rotated + offset, 0.0, 1.0));
      }

      @fragment
      fn mainFrag() -> @location(0) vec4f {
        return vec4(0.7686, 0.3922, 1.0, 1.0);
      }
    `;

    const module = device.createShaderModule({
      code: wgslCode,
    });

    const pipeline = device.createRenderPipeline({
      layout: 'auto',
      vertex: {
        module: module,
        buffers: [
          {
            arrayStride: 2 * 4,
            attributes: [
              {
                shaderLocation: 0,
                offset: 0,
                format: 'float32x2',
              },
            ],
          },
        ],
      },
      fragment: {
        module: module,
        targets: [
          {
            format: presentationFormat,
          },
        ],
      },
      primitive: {
        topology: 'triangle-list',
      },
    });

    const bindGroup = device.createBindGroup({
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        {
          binding: 0,
          resource: {
            buffer: parametersBuffer,
          },
        },
      ],
    });

    onFrame(() => {
      const commandEncoder = device.createCommandEncoder();
      const textureView = context.getCurrentTexture().createView();

      const renderPassDescriptor: GPURenderPassDescriptor = {
        colorAttachments: [
          {
            view: textureView,
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
      };

      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.setVertexBuffer(0, triangleVertexBuffer);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(3);
      passEncoder.end();

      device.queue.submit([commandEncoder.finish()]);
    });
    ```
    </details>
    <LinkCard
      title="Run it in the playground!"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoKIBsCmIcB2MANCugArJTL4w5SkQEBi1%2BcAvnAGZQQhwA5AAEYATzA4A5mACuAehwAPGmFwBaGBAhYA1sBiCA3ACgTAYyYBneGmRg6UOAF4UAd2QG4BZADdgUshaUAB0MrIA-CFQOACOsjg2AIKo9o4AFACUppYENnCoOP7mOC7unrapDvRRMfGJMAAiRcAlWaYmwNxw6QCEhcU4mYgmcHAwABZ8bt44MxhQfFDpgsyeuKjjECjm8cAxKAUtJYLZJhxmufnmyAS%2ByFZlyB5eaJi4%2BEQrN3cPgqRIB6ScwwABKQWAEAAXHAAIycM5XeC5OhKeCuH73KxhHAwADCTFRMBWbhwACNwqcUI8AOLkACqeNuWIJRGUMBy1ngYBiVkIMAhTGY0BAQTKPn8gWCYTkOJg5Bi3HoMVQTN%2BVmFUFFxLOFkJ7JCuW4AVkMXSCFGR0GxEt3BFQRhPMS-MFLHtJEtyCwYAmyAAshBCjDBE6QLIsDBgGpgDhUP9zrqkeMoMBblJcAA1eioxpBZDiuZwZhYCBBADMACYkotkGJ0gBtAAMIUbpGbAFZSOoO12e3A%2B92Qu2ALqJrnJ1MEdM4LOwZQAIVk3CVTlcA1aOENMSCOEXy-o5stVmAAC8cDCYCm05ns8pcwKQmSxHQADKEKSTG1jWRWZBSc9wHS9J7iu9K-v%2BIQZhgoIACoYAAGl%2BcCimAkioEk%2BLbpGTAXlACQ2hwZwEIWxaljAlbVtQdaXpO06zqiIH0HKfr2Gh4JTjgWSZCEfLEjR14zreSj3sgZz8VON5zkojGhLIBAoe0lzjmAVA0Li9BWDJZTriUW44DuMmHmMx5njCAAscAAFRwGWSE-n%2BAFATJYEOSE9IAHIAJLMAA8qCfpwAAPoBDLOeBm54j55AAJoAPqNAAyjBBG6m8lBsOpyyWoIfACthBDxmMFpjGMwAEAYqZYDCraWmMIBldVSF1cgSgwmWISwhZ1kVk1cA2DgYDVR1SEcEh6T3FgCTDM4AB8IwlXASapAKBYzKR5ZVjWdb1hNCSjqYC06Zu9QJCEbgpnQhkqRljiaUuK5tqQy2iQdnA2qlFCqbQB7ZUohXzSVZUVV6jW1chDVwOosK9aKrVwr1-WDf2w2WqNlrjV6U0uHNxUlUtearUWJYbZRtYNrtOD7WDR0hCdm7nQYu73Qe11qbdMmkGZT15mcYxox9qDpWzP1jIIYj-bjpXlZGIP9jDENQzDLUwtDYOI0Nqt82NFPTTjYP4ytrjEWtxPkZtVHk5jlO8yVNN02dF1M-uyys99UB3c7pAABzcwKNv8x0SZuFIVhYAShRlAABraBBwLlO7jTCvg4OYFbcKQAkwtwlbDOoc3J6n3SS3AuDchAjyuAXFbpGDYzjSEShWYt5fpAJmS5z0vghGITfHgQrcSUMmS9XXXeN9ZfcD9O7dwAA1J33dN5YVhT7g7dgzbYwxDApqx5AVivRwHTGZesggnAQtu48xfx-lcBZ5WvWNw-PVgz3L8jcfcDCGSZWoGVUh0iNmGMIKQfBZBgCAcMe4UAAA8ckugijmq7R4MJL6ZQPmYE%2BeFz70WUD5WQMA5DwGLj-WQwAIxlXSPvCqTBhg0LvknFOZluCoy-sIZOUkY7IU8AQei6RhAlhuPlKBcBfBMMLrnOaeClAEKIYQgGYxS5xwgHlWMZRb6cV8KQFB0RVGuk3iXXEcAIDLl4mUKu1CvrYiUDo6x3ddQLW3rvOAMi5HEPGsw7g6RNGbHnqY7gvE2wtlILCFs7dD5YO-rwP8nwYDcNFGVVgf4siQzmoIiAwjIT92AWIrxii464hcQXMyQCQgAHYABsXtKnBLLAATgrD1OEISWnAMiZHQO44QCBnDKUNcxxNzmCwjgBKvpChQADKgPpRlm5BjgMHUO4ccApS6XkbkUYcBYDKv0q0G49I7lBIQCZ5BNnbOIrMrAtYICEODMgQhEB-qcNRDCYuPTpm4BhO8vpvUyTM3djCestcCkLSoFRBKNF5kViblzYFYwgg0T%2BXQKwgK4UlWLgtBaVhxn0BfJk10oNMVEpMWY3EhLiULTtFqB0QhuCm0rEoCs-0KVowpcOEeb0wbstRkhGJUg4mvLBt8z5yFem4F6gKKA-4YAorgEColGKSpUu1I6XkLp8qam1By1lJVuVa0tDyUAFVk6CoWloSAJYpBiGDOJac6htk2H%2BmjQiaz8i-wIKgGk4CwDaUGQcy6f8vU3MgbjK5YgbkwEdGcnZcp5yBu9S%2Ba5hCoFIX5CmRIqKFqKvdf-Kc5KnGJBuVAEopriV-Odo6L6GCObAp1fqsY3KXVmCFBldIqTZoAyTJYEAooPUYAIJYCZvrBj%2BpwASHttxMADsDAeG2SYiSmhnDGGYGJ9RojlHiU0MQiAwXZIurIo6MzLsUpaJM26TkPCsM0KwwyozBBhEBI5Hr6CUCsFexIt6HDQDKMXSwJYoAYQFOYCYcTZXysxYqsY-g5gXj3TEI9cwOVjHMLgKgGYraAtbHLbDjY9XEuJqgHySNBAof0lAZlmKbDQBwER4MVGYgUfrbqz%2BUSkwqTff2wd9Ayjdt7VOrjoQyTSDKk%2Bi9b6fHHJfZe69n7gg23Y1YTjM7Qi8VOZIc5nEwDRuIvJy9SmJk8VxDIwyWHbWSQYv83THHp0Gd4nGj1QaIFANIDmxzYArOKZs0xVA1A3DpDLB5-TTFjknrGHbBIp0rCyDJPVYk9ZeOTqC6EY05VsVZCpk2oAA"
      target="_blank"
    />
  </TabItem>
</Tabs>

## Let's create some more triangles

Now that we have a single movable triangle, let's create some friends for it.
But first, let's upgrade our program a bit. Currently, the size of our triangle is defined by the values written to the buffer during its creation.
While this is acceptable, let's make it more convenient by extracting the size into a variable.
Additionally, we should make the triangle slightly smaller to fit more on the screen.

<Tabs>
  <TabItem label='Before'>
  ```ts
  const triangleVertex = wgsl
    .buffer(arrayOf(vec2f, 3), [
      [0.0, 0.5],
      [-0.5, -0.5],
      [0.5, -0.5],
    ])
    .$allowVertex('vertex');
  ```
  </TabItem>
  <TabItem label='After'>
  ```ts
  const triangleSize = 0.2;
  const triangleVertex = wgsl
    .buffer(arrayOf(vec2f, 3), [
      [0.0, triangleSize],
      [-triangleSize, -triangleSize],
      [triangleSize, -triangleSize],
    ])
    .$allowVertex('vertex');
  ```
  </TabItem>
</Tabs>

Regarding the triangles, we'll need to create a buffer containing the positions and rotations of each one.
We'll also need to update the vertex shader to utilize these values.
There are two different approaches, each with its own pros and cons.
We can either create another vertex buffer (this time using the 'instance' version) or use a uniform/storage buffer.
Let's explore both options.

<Tabs>
  <TabItem label='Instance vertex buffer'>
  ```ts
  const triangleAmount = 10;
  const trianglePos = wgsl
    .buffer(arrayOf(vec3f, triangleAmount))
    .$allowVertex('instance');
  ```

  One potential downside of this approach is that the data type of the buffer is limited to scalar types.
  This means that our data type can't be a struct, which could potentially make our code less readable.

  ```diff lang=ts
  const vertexCode =  wgsl`
+  let instanceInfo = ${trianglePos.asVertex()};
    let rotated = ${rotate}(
      ${triangleVertex.asVertex()},
-    ${rotationBuffer.asUniform()}
+    instanceInfo[2]
    );
    );

    let offset = vec2f(
-    ${xBuffer.asUniform()},
-    ${yBuffer.asUniform()}
+    instanceInfo[0],
+    instanceInfo[1]
    );

    let pos = vec4f(rotated + offset, 0.0, 1.0);
  `;
  ```
  <Aside type='tip'>
    In the above code, we extracted `trianglePos` to an `instanceInfo` variable. This step is unnecessary because each call to `trianglePos.asVertex()` returns the same value. Therefore, `${trianglePos.asVertex()}[x]` is equivalent to `instanceInfo[x]` in this context.
  </Aside>
  Since we are using a vertex buffer, we don't need to index into the buffer data within the vertex shader.
  One downside of this approach is that we must keep track of which variable is at which index in the vector.
  This can be somewhat confusing and less readable compared to using a struct.
  Additionally, we need to specify the number of instances we want to render to our render pipeline.

  ```diff lang=ts
  onFrame(() => {
    pipeline.execute({
      colorAttachments: [
        {
          view: context.getCurrentTexture().createView(),
          clearValue: [0, 0, 0, 0],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
      vertexCount: 3,
+    instanceCount: triangleAmount,
    });

    runtime.flush();
  });
  ```
  </TabItem>
  <TabItem label='Storage buffer'>
  ```ts
  const triangleAmount = 10;
  const trianglePos = wgsl
    .buffer(
      arrayOf(
        struct({
          x: f32,
          y: f32,
          rotation: f32,
        }),
        triangleAmount,
      ),
    )
    .$allowReadonlyStorage();
  ```
  This time, we are using a buffer of structs, making our code more readable as we can access the data using the struct fields.
  We are using a readonly storage buffer because the current alignment of the data in the buffer is 12 bytes, which is not a multiple of 16 bytes â€” a requirement for a uniform buffer.
  While we could pad the struct to make it 16 bytes, let's stick to using readonly storage for now.
  ```diff lang=ts
  const vertexCode =  wgsl`
+  let instanceInfo = ${trianglePos.asReadOnlyStorage()}[${builtin.instanceIndex}];
    let rotated = ${rotate}(
      ${triangleVertex.asVertex()},
-    ${rotationBuffer.asUniform()}
+    instanceInfo.rotation
    );
    );

    let offset = vec2f(
-    ${xBuffer.asUniform()},
-    ${yBuffer.asUniform()}
+    instanceInfo.x,
+    instanceInfo.y
    );

    let pos = vec4f(rotated + offset, 0.0, 1.0);
  `;
  ```
  In the vertex shader, we need to index into the buffer data using the `builtin.instanceIndex` variable, which contains the index of the current instance being rendered. This step was unnecessary when using a vertex buffer, as the data was already indexed for us. Lastly, we need to specify the number of instances we want to render to our render pipeline, just as we did with the previous approach.
  ```diff lang=ts
  onFrame(() => {
    pipeline.execute({
      colorAttachments: [
        {
          view: context.getCurrentTexture().createView(),
          clearValue: [0, 0, 0, 0],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
      vertexCount: 3,
+    instanceCount: triangleAmount,
    });

    runtime.flush();
  });
  ```

  </TabItem>
</Tabs>

For the remainder of this tutorial, we will assume the use of the storage buffer approach. If you prefer the vertex buffer approach, feel free to adapt the code accordingly.
### Initializing the buffer
Since we don't have initial values for the buffer, we'll create a helper function that populates it with random values.

```ts
function randomizeTriangles() {
  const positions = [];
  for (let i = 0; i < triangleAmount; i++) {
    const x = Math.random() * 2 - 1;
    const y = Math.random() * 2 - 1;
    const rotation = Math.random() * Math.PI * 2;
    positions.push({ x, y, rotation });
  }
  runtime.writeBuffer(trianglePos, positions);
}
```
<Aside type='tip'>
  If you chose the vertex buffer approach, ensure you use the correct data type when writing to the buffer. The `writeBuffer` function will provide hints about the appropriate data type.
</Aside>

We will call this function before the first frame is rendered to ensure that the buffer is initialized with random values. Let's also add a button that will call this function when clicked.

```ts
addButton('Randomize', randomizeTriangles);
```

```diff lang=ts
+randomizeTriangles();
onFrame(() => {
  pipeline.execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
    instanceCount: triangleAmount,
  });

  runtime.flush();
});
```

Since they are no longer used, we can remove the parameters that were used to position the triangle.

```diff lang=ts
-const params = {
-  rotation: addSliderParam('rotation (rad)', 0, {
-    min: 0,
-    max: 3.14 * 2,
-    step: 0.1,
-  }),
-  x: addSliderParam('x', 0, {
-    min: -1,
-    max: 1,
-    step: 0.1,
-  }),
-  y: addSliderParam('y', 0, {
-    min: -1,
-    max: 1,
-    step: 0.1,
-  }),
-};
-
-const rotationBuffer = wgsl.buffer(f32, params.rotation).$allowUniform();
-const xBuffer = wgsl.buffer(f32, params.x).$allowUniform();
-const yBuffer = wgsl.buffer(f32, params.y).$allowUniform();
```

<LinkCard
  title="Run it in the playground!"
  href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoEIFcYwgOwBoV0BRAGwFMRL8ZiCAxKZGuAXzgDMoIQ4A5AAEYATzCUA5mCwB6SgA9WYKgFo8EcgGtgMAQG4AUKEixEcAEZZg5GMCJwAxlErIYlAEpY6oSsQDukgDO5BzcvPwCYhLSWAbG4NDwSMhQLKIA8lzEXADMAEzEQTBQWI70cABulI752VU1uVxhPHyC0VIysqhuyPGGjgTFcKU%2BbAC8KP7Iuk4ubp7edjQAFACURoP4w6iUlcCOlHCTo8uUAHS7%2B4dGA0Pwjsj4lchBx1Mz8GioFNS0MCsBI9nq8BMQUkEJOUPG5gBAAFxwACMHA2d22DwI7gU8EmwJeQXOkkoMAAwljFACBP5KBZYgI1ig3gBxAAKAFVSU8CeS6JTNvc4GAXEF-rCmNAQG53vhkPtJG5oESZESSayXFxKGlKKguSCgoxJW51rcttiYOctlxgJIsC4VghDHA4FcDn4ndwjTBEcLKKK6OL8IaoFL6B7kOQwAALZAAWQgu0RAl9ICwtmAKmAOrBhnYaMM32wuAIgJh%2BFQfGAAC9KGCRk8KyBq5QACpQYBPSRUIL5rbDEod-BdygAZWb7wADOd8gKMXAB52qAA1LXY96BEIe85WLiaqArVLpLIraq1eq5NbEADaHudV6nE%2BIC6HVDHNYAuoRb3Ar%2Bp24vR2bYg-0HYc30oT9vyvZ8wKAuAQIA8DIOdd81i3AASCNyAgfwV1gRRAWqfCFAZU1BRgqgAEEQAgJZ3iRCdZ37f8X0oVkIDeSYN3ILcdz3FZv0PZBMi4ATnXEuBilKcoHW-CSFERPJCjk8TREUgovwkiTeBgQN1OUrTUU0rSKMoajaLoYznUvD00Odc5MPIbD-A8VwK3wchRBHPAWGJE1DEMLhvHKOF8HrctKxrNtQO7dZEA9Pt4EgIJdFCzif3fIxnS4aA4BWKh4GASd9DgIqAB55xY4dzKWErgAAanqxlHQkxK4AUd5YzcKNzhYCKQDigAqOB8ng5EsvEtrRE67reobPghpGsakQm502p0wMZpgHq%2BsbRauu285WQASTgYaZ2-ZLUqGc4ZCCKMHXa4hRGIDa7AIVEJvYD1Tl8c5-HbdxsF3LUVlM9igmIK73u2NFvvRYY3qOLjgnIc4uHwAADE9EVPOpiAA-TGVUAA%2BBoz3i50CqFDj3jxsTxJPc4OuGwYggPVi1mJvLKnOabhpS-AOeHLmrJ55mzsk%2BxhaoLm4Hq8X%2BacDiZcoLnbImlwYDtMLkqMdhMbIucwAzShyHsZGRiWP6pS0TxaF2KBWVN838EoWTnSI7FERayaE0oRFuMxlTqfsYonkOY78By950IQcGOPOV5XLQAhPO86BkD8tZ2CvOOrBsOx8HOMPdPwSPy0UdhMpDkkRggXT3FQWOECR9gGcMuPTLw7Ek6CHuCJzsWJNLiPKCjnLeobwMVPzQzqYgXdRVxcm6g7rTR-L8fo4gZnh-EzeK8n0RZ9uee6%2BSumagAFlEpHm4VxeuGX4gH2IJFzgnNEJMxsXaJgGQ3pKZaSvAXdMxdoahXfEmZKOYJLsGMggj0PAs40DoD7b8gxExwCDipLWOtybXxWFOAA7AANgABxkNfucXIABOfIhRkTnHfp-b%2B4lf7fl0lAYkQCbyGV9oZHKIY3A%2BhFGKGGwZQz7yQRJZCHBjLClAKlaoGCJJ4EgNhSQal2hVTUObYocCFG5nzLtSKrY9F%2Bn8kwFgqw4rjDJr7E2EhXYXEUDUHA7tBHK2wlASiuBkCOCjGgmAQRET8K0t4iS%2BxKD%2BERGaSkqoyR2hcHQFslI7TuzWJaeY7glxZn8Osfea0qCpCXBGLAAcfyPjgDUup8j54QDQBkMASZHClKgEYwyxRoCUBaUmHpLguniVkeJBpDRiLkiWIiXIYtD6UCmegyqMUzI0SWIgueVsxgXC4OQLA91-J5iMEAA"
  target="_blank"
/>

Great! But now we have a little problem. When we had just one triangle, we could easily see it.
But now, with multiple triangles, it's hard to distinguish the individual shapes.
Let's add a gradient color to each triangle to make them more distinguishable.

<Steps>

1. Add additional output to the vertex shader that will represent the UV coordinates inside the triangle:

   ```diff lang=ts
   output: {
     [builtin.position]: 'pos',
   +  fragUV: vec2f,
    },
   ```

2. Create the UV coordinates inside the vertex shader:

   ```diff lang=ts
   const vertexCode = wgsl`
     let instanceInfo = ${trianglePos.asReadonlyStorage()}[${builtin.instanceIndex}];
     let rotated = ${rotate}(
       ${triangleVertex.asVertex()},
       instanceInfo.rotation
     );

     let offset = vec2f(
       instanceInfo.x,
       instanceInfo.y
     );

     let pos = vec4f(rotated + offset, 0.0, 1.0);
   +  let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
   `;
   ```
   To calculate the UV coordinates, first add a vector of the triangle size to the rotated position to eliminate negative values.
   Then, divide the result by twice the triangle size to obtain the UV coordinates.

3. Update the fragment shader:

   ```ts
   const fragCode = wgsl`
     let color1 = vec3(196.0 / 255.0, 100.0 / 255.0, 255.0 / 255.0);
     let color2 = vec3(29.0 / 255.0, 114.0 / 255.0, 240.0 / 255.0);

     let dist = length(fragUV - vec2(0.5, 0.5));

     let color = mix(color1, color2, dist);

     return vec4(color, 1.0);
   `;
   ```
   <Aside>
    Note that we can use fragUV directly in the fragment shader. This is because the `fragUV` value was present in the vertex shader output. TypeGPU will automatically pass this value to the fragment shader.
   </Aside>
   First, we define two colors. Then, we calculate the distance from the center of the triangle to the current fragment.
   We use this distance to blend the two colors. The closer the fragment is to the center, the closer the color will be to color1.
   The further the fragment is from the center, the closer the color will be to color2. This way, we achieve a nice radial gradient.
</Steps>

<Aside type="tip">
  The proposed solution is completely arbitrary. Feel free to experiment with different ways to color your triangles!
</Aside>

<Tabs>
  <TabItem label="TypeGPU">
  <details>
  <summary>See code</summary>
  ```ts
  import { addButton, addElement, onFrame } from '@typegpu/example-toolkit';
  import { builtin, createRuntime, wgsl } from 'typegpu';
  import { arrayOf, f32, struct, vec2f } from 'typegpu/data';

  const runtime = await createRuntime();
  const device = runtime.device;

  const canvas = await addElement('canvas', { aspectRatio: 1 });
  const context = canvas.getContext('webgpu') as GPUCanvasContext;
  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

  context.configure({
    device,
    format: presentationFormat,
    alphaMode: 'premultiplied',
  });

  addButton('Randomize', randomizeTriangles);

  const triangleSize = 0.2;
  const triangleVertex = wgsl
    .buffer(arrayOf(vec2f, 3), [
      [0.0, triangleSize],
      [-triangleSize, -triangleSize],
      [triangleSize, -triangleSize],
    ])
    .$allowVertex('vertex');

  const triangleAmount = 10;
  const trianglePos = wgsl
    .buffer(
      arrayOf(
        struct({
          x: f32,
          y: f32,
          rotation: f32,
        }),
        triangleAmount,
      ),
    )
    .$allowReadonlyStorage();

  function randomizeTriangles() {
    const positions = [];
    for (let i = 0; i < triangleAmount; i++) {
      const x = Math.random() * 2 - 1;
      const y = Math.random() * 2 - 1;
      const rotation = Math.random() * Math.PI * 2;
      positions.push({ x, y, rotation });
    }
    runtime.writeBuffer(trianglePos, positions);
  }

  const rotate = wgsl.fn`(v: vec2f, angle: f32) -> vec2f {
    let pos = vec2(
      (v.x * cos(angle)) - (v.y * sin(angle)),
      (v.x * sin(angle)) + (v.y * cos(angle))
    );
    return pos;
  }`;

  const pipeline = runtime.makeRenderPipeline({
    vertex: {
      code: wgsl`
        let instanceInfo = ${trianglePos.asReadonlyStorage()}[${builtin.instanceIndex}];
        let rotated = ${rotate}(
          ${triangleVertex.asVertex()},
          instanceInfo.rotation
        );

        let offset = vec2f(
          instanceInfo.x,
          instanceInfo.y
        );

        let pos = vec4f(rotated + offset, 0.0, 1.0);
        let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
      `,
      output: {
        [builtin.position]: 'pos',
        fragUV: vec2f,
      },
    },
    fragment: {
      code: wgsl`
        let color1 = vec3(196.0 / 255.0, 100.0 / 255.0, 255.0 / 255.0);
        let color2 = vec3(29.0 / 255.0, 114.0 / 255.0, 240.0 / 255.0);

        let dist = length(fragUV - vec2(0.5, 0.5));

        let color = mix(color1, color2, dist);

        return vec4(color, 1.0);
      `,
      target: [
        {
          format: presentationFormat,
        },
      ],
    },
    primitive: {
      topology: 'triangle-list',
    },
  });

  randomizeTriangles();
  onFrame(() => {
    pipeline.execute({
      colorAttachments: [
        {
          view: context.getCurrentTexture().createView(),
          clearValue: [0, 0, 0, 0],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
      vertexCount: 3,
      instanceCount: triangleAmount,
    });

    runtime.flush();
  });
  ```
  </details>
  <LinkCard
    title="Run it in the playground!"
    href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoEIFcYwgOwBoV0BRAGwFMRL8ZiCAxKZGuAXzgDMoIQ4A5AAEYATzCUA5mCwB6SgA9WYKgFo8EcgGtgMAQG4AUKEixEcAEZZg5GMCJwAxlErIYlAEpY6oSsQDukgDO5BzcvPwCYhLSWAbG4NDwSMhQLKIA8lzEXADMAEzEQTBQWI70cABulI752VU1uVxhPHyC0VIysqhuyPGGjgTFcKU%2BbAC8KP7Iuk4ubp7edjQAFACURoP4w6iUlcCOlHCTo8uUAHS7%2B4dGA0Pwjsj4lchBx1Mz8GioFNS0MCsBI9nq8BMQUkEJOUPG5gBAAFxwACMHA2d22DwI7gU8EmwJeQXOkkoMAAwljFACBP5KBZYgI1ig3gBxAAKAFVSU8CeS6JTNvc4GAXEF-rCmNAQG53vhkPtJG5oESZESSayXFxKGlKKguSCgoxJW51rcttiYOctlxgJIsC4VghDHA4FcDn4ndwjTBEcLKKK6OL8IaoFL6B7kOQwAALZAAWQgu0RAl9ICwtmAKmAOrBhnYaMM32wuAIgJh%2BFQfGAAC9KGCRk8KyBq5QACpQYBPSRUIL5rbDEod-BdygAZWb7wADOd8gKMXAB52qAA1LXY96BEIe85WLiaqArVLpLIraq1eq5NbEADaHudV6nE%2BIC6HVDHNYAuoRb3Ar%2Bp24vR2bYg-0HYc30oT9vyvZ8wKAuAQIA8DIOdd81i3AASCNyAgfwV1gRRAWqfCFAZU1BRgqgAEEQAgJZ3iRCdZ37f8X0oVkIDeSYN3ILcdz3FZv0PZBMi4ATnXEuBilKcoHW-CSFERPJCjk8TREUgovwkiTeBgQN1OUrTUU0rSKMoajaLoYznUvD00Odc5MPIbD-A8VwK3wchRBHPAWGJE1DEMLhvHKOF8HrctKxrNtQO7dZEA9Pt4EgIJdFCzif3fIxnS4aA4BWKh4GASd9DgIqAB55xY4dzKWErgAAanqxlHQkxK4AUd5YzcKNzhYCKQDigAqOB8ng5EsvEtrRE67reobPghpGsakQm502p0wMZpgHq%2BsbRauu285WQASTgYaZ2-ZLUqGc4ZCCKMHXa4hRGIDa7AIVEJvYD1Tl8c5-HbdxsF3LUVlM9igmIK73u2NFvvRYY3qOLjgnIc4uHwAADE9EVPOpiAA-TGVUAA%2BBoz3i50CqFDj3jxsTxJPc4OuGwYggPVi1mJvLKnOabhpS-AOeHLmrJ55mzsk%2BxhaoLm4Hq8X%2BacDiZcoLnbImlwYDtMLkqMdhMbIucwAzShyHsZGRiWP6pS0TxaF2KBWVN838EoWTnSI7FERayaE0oRFuMxlTqfsYonkOY78By950IQcGOPOV5XLQAhPO86BkD8tZ2CvOOrBsOx8HOMPdPwSPy0UdhMpDkkRggXT3FQWOECR9gGcMuPTLw7Ek6CHuCJzsWJNLiPKCjnLeobwMVPzQzqYgXdRVxcm6g7rTR-L8fo4gZnh-EzeK8n0RZ9uee6%2BSumagAFlEpHm4VxeuGX4gH2IJFzgnNFz-gHgs-ZJc7wVj33lqvUSXcqqvmbOwYgECYqARrHmRksgwErDgYhaBkt8if2-uJTGYtaIwBkN6SmWkrwF3TMXaGoV3xJmSjmQyf9JAANxjUfG34YEek4dlXyNA6A%2B2-IMRMcAg610xNhKAKJJinlyCsJEABOAAbJ-OAKD8gAFZ1Gf3fhOB8qiRqaO0QYrRE59EaJMbgiS1NBgSNGtIxoKx8jyJUWowxj5kRImvi44xRj8jXz0a4ixZ8tLU1QMAYYkwqBDm2isJhACxr0ynOo1%2B5x1Fc2CVYuuNjcqTCbAoFY2TJHEEKYUF04SYBzy0lrHW5Nr4FM0NAd%2BODVpwHwd%2BXSUBiQkJvIZX2jCvQ%2BhFGKGGwZQz724eJZCHBjLClAKlaoAiJJ4EgNhSQal2iQMoKoc2xQGHTNzPmXakVWybPZmiJgLBVhxXGGTX2JsJCuwuIoGoOB3Z9OVhIyiuBkCOCjHwmAQREQ9K0u8iS%2BxKD%2BERGaSkqoyR2hcHQFslI7TuzWJaeY7glxZn8Osfea0qCpCXBGLAAcfzuPJa-KZ88IBoAyGAJMjgCVQD2YZYo0BKB0qTGylwLLxITJQmLL2ihyRLERLkMWh9KAiv4ZVeBNVLJcMqb9Gg6NyBYHuv5PMRggA"
    target="_blank"
  />
  </TabItem>
  <TabItem label="WebGPU">
  <details>
  <summary>See code</summary>
  ```ts
  import { addElement, addButton, onFrame } from '@typegpu/example-toolkit';

  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();

  if (!device) {
    throw new Error('Failed to acquire a device');
  }

  const canvas = await addElement('canvas', { aspectRatio: 1 });
  const context = canvas.getContext('webgpu') as GPUCanvasContext;
  const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

  context.configure({
    device,
    format: presentationFormat,
    alphaMode: 'premultiplied',
  });

  addButton('Randomize', randomizeTriangles);

  const triangleSize = 0.2;
  const triangleVertexData = new Float32Array([
    0.0,
    triangleSize,
    -triangleSize,
    -triangleSize,
    triangleSize,
    -triangleSize,
  ]);

  const triangleAmount = 10;
  const trianglePos = device.createBuffer({
    size: triangleAmount * 3 * 4,
    usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
  });

  const triangleVertexBuffer = device.createBuffer({
    size: triangleVertexData.byteLength,
    usage: GPUBufferUsage.VERTEX,
    mappedAtCreation: true,
  });
  new Float32Array(triangleVertexBuffer.getMappedRange()).set(triangleVertexData);
  triangleVertexBuffer.unmap();

  function randomizeTriangles() {
    if (!device) {
      return;
    }
    const data = new Float32Array(triangleAmount * 3);
    for (let i = 0; i < triangleAmount; i++) {
      data[i * 3] = Math.random() * 2 - 1;
      data[i * 3 + 1] = Math.random() * 2 - 1;
      data[i * 3 + 2] = Math.random() * Math.PI * 2;
    }
    device.queue.writeBuffer(trianglePos, 0, data);
  }

  const wgslCode = `
    fn rotate(v: vec2f, angle: f32) -> vec2f {
      let pos = vec2(
        (v.x * cos(angle)) - (v.y * sin(angle)),
        (v.x * sin(angle)) + (v.y * cos(angle))
      );
      return pos;
    };

    struct TriangleData {
      x : f32,
      y : f32,
      rotation : f32,
    };

    struct VertexOutput {
      @builtin(position) position : vec4f,
      @location(1) fragUV : vec2f,
    };

    @binding(0) @group(0) var<storage, read> trianglePos : array<TriangleData>;

    @vertex
    fn mainVert(@builtin(instance_index) ii: u32 ,@location(0) v: vec2f) -> VertexOutput {
      let instanceInfo = trianglePos[ii];

      let rotated = rotate(v, instanceInfo.rotation);
      let offset = vec2(instanceInfo.x, instanceInfo.y);

      let pos = vec4(rotated + offset, 0.0, 1.0);
      let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
      return VertexOutput(pos, fragUV);
    }

    @fragment
    fn mainFrag(@location(1) fragUV : vec2f) -> @location(0) vec4f {
      let color1 = vec3(196.0 / 255.0, 100.0 / 255.0, 255.0 / 255.0);
      let color2 = vec3(29.0 / 255.0, 114.0 / 255.0, 240.0 / 255.0);

      let dist = length(fragUV - vec2(0.5, 0.5));

      let color = mix(color1, color2, dist);

      return vec4(color, 1.0);
    }
  `;

  const module = device.createShaderModule({
    code: wgslCode,
  });

  const pipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex: {
      module: module,
      buffers: [
        {
          arrayStride: 2 * 4,
          attributes: [
            {
              shaderLocation: 0,
              offset: 0,
              format: 'float32x2',
            },
          ],
        },
      ],
    },
    fragment: {
      module: module,
      targets: [
        {
          format: presentationFormat,
        },
      ],
    },
    primitive: {
      topology: 'triangle-list',
    },
  });

  const bindGroup = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      {
        binding: 0,
        resource: {
          buffer: trianglePos,
        },
      },
    ],
  });

  randomizeTriangles();
  onFrame(() => {
    const commandEncoder = device.createCommandEncoder();
    const textureView = context.getCurrentTexture().createView();

    const renderPassDescriptor: GPURenderPassDescriptor = {
      colorAttachments: [
        {
          view: textureView,
          clearValue: [0, 0, 0, 0],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
    };

    const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder.setPipeline(pipeline);
    passEncoder.setVertexBuffer(0, triangleVertexBuffer);
    passEncoder.setBindGroup(0, bindGroup);
    passEncoder.draw(3, triangleAmount);
    passEncoder.end();

    device.queue.submit([commandEncoder.finish()]);
  });

  ```
  </details>
  <LinkCard
    title="Run it in the playground!"
    href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoKIBsCmIcB2MANCugEICuMMEBpdAYlMvnAL5wBmUEIcAcgACMAJ5gcAczCUA9DgAerMLgC0tCFgDWwGAIDcAKEMBjOgGd4aZGBg4ocALwoA7sl1wCyAG7BJyWigAOmlKAH4gqBwAR0ocSwBBVBs7KAAKAEojMwJLOFQcXxMcJ1d3K2Tbewio2PiYABFC4GLMo0NgLjg0gEICopwMxEM4OBgAC14XTxxpjChedIFGd1xUMYgUE1jgKJR85uKBLMN2Yxy8k2QCb2RzUuQ3DzRMXHwiNIErm7uBUiQ7hITDAAEoBYAQABccAAjBwThd4Dk7Ap4M5vrdzCEcDAAMJ0FEwT4uHAAI1CxxQ9wA4gAFACquOumPxREUMGyFngYCi5kIMHBTGgIACpS8vn8gRCMmxMFpUS49iiqCZP3MjGFATa5wJ7KCOS4fkoUTSCBGBwGxHNXE1MGhPPi-MFBA1UBFJHNyCwYHGyAAshACtCBA6QJQsDBgCpgDhUH9TidDC8qDQ6J8wQRUHxgAAvHB-OAsTPZvMAFSgwGuklw5kTiLGFaruAAyrmSs4AAxBABMnNy8BgjYI1ZwADV7CiGgFkGLZnBGFgIAEAMzdhILZCiNIAbXNXY7VtGg8rw5bbcPcHUQ5HrbzF6vJ5v5-Nx6bOFvOHvr9P7%2BfAF06y5BtH1wBIQAgSgiFKGEOz7PJvxHWkIHuZx%2BhaHB9SiAIcCoLhFXSM1RnMNtoQQ0DwMg%2BAACo4GXOAaIAFgvShzGQSQcGhOl6Vw-D6VY9igmbUsAHkQQSakMDgAAfOAuJ4%2Bw%2BLYjDcWE2kAE0AH0GiEq12EA-tgLfcdYEUeSHFQw4MJMLC7DM01zWIvNSOvXBjMnacglJUQ7AAGUISQJmY-iONkhkzMUgTRwwEFSwwAANC8RTACRUASPEbIhAhnLiXSTgIOcFyXGBV3XFgtzIscJ1Myg8PsWU-RsFKM3YzIMiCPkiQqtzFCnAUTi6qqFDMoJIKS7VDC4SDgUywtrizEA23LED4kyYZRk6bo%2BksoZCNGQscWNAgjFGM5RnrZIBVnaZCpXNcN3KlycDAiCoJo5cTlGG0HDSXB4GAUpYLgf6AB5DJ-Z7KP0IGAGpoZ281Rgu5Bt3%2Bt6-1KBqJkiOa%2BFWmju0vWFjr2pGUfo2i4Gh2F0ecTHxmx4sQDxuACdUImEfyacybeymWZpuA6YZ%2BbmcF2kAElyd7c1TotdCgjqOIghcCtbJq-C0gqpDzFIA9Ob6owzlMICXEkcwsHxApSgAA2tAhCwgAU7DSbxoW8HATG7LhSDfaEuFXIZVAAPjgN2Pa6XbRl%2BuBIBQkP3e7NIOdGZ2ggUcmzHMNI3wyAPum8IJRHJ4iCCzn8c4vPa89TovgBL7OhiplPC5ojPS5HHOOY%2BvaohgQ7o%2BQ4n2HaIjB0oYE4CWt9epnCO4DT33VwruBC4X7sl94R2ZtXi8h%2BMEeoDH%2BBuoUYTqBkeBZ6EUlKGACNa7SGPdEyoZH8jOg4Fd92GK9jmhEXK434lxhEMHgbF6Sjg-nHMOO9h5wCvrXVAtdJBpA7EMIQkheCUDACgoYtwoDA0sNAJSpAsKoGDprZCkDkD3WBpPH809A6wKEG7EyChbZwBFLXNyaQr43zviXWulhrjFA0ggxQQxgDAGhJQVccBiB-wgAAzKOCQ6fzDgHYOx9T4wHPmtPaUdBECgIMUMWBAbSlAoeYFGwA-ywMjjie2jtYylA3thZ2pBDHCJwKYm0kQHbOi7vY%2BAEA8IdVKKHBOnjjHeLMRAVOHj%2BxeJ8XE0QiZK5RxjuEr%2BaRXF2HWFTEJXAOo6yCLrGEpTAlwCjqAyQ4DSg5P8Xk3mESuBpAACQIAqh%2BdgpAOldLbHpIYsgoGe3aZ0x63TJYVOJqMHufctFn2oA-ZCpAangK7obUYQganvBgOwzhLoWDIIUUotMwDuBHLqWoz2Gi4H-2dCo0O389FBLgGYRcUA4TOFDsuNIMIACcAA2UpcBhndgAKzgtKaQGC%2B5QUs0hdChFUKOzwohSiypUd3nQAJt892vzuz-JBWCxFZSYQMWJcipF3YGJwpJRiuxVSHGILyM4XAw4JhpDWRAtmESUFBHBSU8FOdGVYs0NAUoC0FBpGxZ80gsq175GAJYNJ3cDpQDtk8mV4qoAwumdLQwVt2j1nAqgcM7ZZbFEwjgbCzZfQFCgAGM1uB7JnUDCFE2ZsLafgTMaoCYAow4CwLXC1aErXWRtXYEEhAHW0kDcG-KrqqmbggnaQQyBqAQHjKMFhKJoSz1Nea6EhbcBL2vrVKA5hoS7krqMWeldqFlWbMeIMLNyZMSTntAIx5r52CrXAGttbK71qHXAcw9r7A%2BUUc6aEB5O1DsKR1WdS9R3cFtMGLgi5boKG7Nm1dHAV17T-IenpHNj3SwvDs-k%2BaOYlpCnepeAooDsRgP2wdw751rrdAEe0vInSANdO6E9S9z0nQvDyUAT83Y3srrQSAi5JCiGDBVVQwbLB7tPXpP1BlSQIOpJgsApQw1WRsjhPDBGk1YBTdQe08aQ2ynIORiCYAfLUaJKgi8-IKzxGrRzEduHMxIOXZ23kEEoDFBg6O8t%2BFnLLS1sBjmp7Rjnqw8YIs81FqPUzicJgLB8BpFWo4YOu16xmBACKTMGBjHuvMpakjkacD4nM3NKzZgHXajdQZQkxoxwxmmOiXUqJZS4mNFEIgpZ2Q%2BcyNa7Co4-PjU83kMLsa7jmCaOYayUZAicQZNGzM9haSpfS5l2wErnCz1lWlAUJhxi7LfZ2kdOa-OkUi1EOLsxD1nVwNQ0cXo4jVt1oNnWoHR1btQMJMAwYTDdagHuodhCogTeDAt-MCnK4jd3uaesYBUuuZs6UMzFnMDWYdZ5KQtc8spfMJnZLBWivxBK4ELuO3rt7dOx1ONEgE04AfnR-Kz3dsnbqh1Y%2BdldYDVYWZAHr2gfBA6oxzM%2BHmMoNIAJ1ASOsHQ-MG9uqqAWAuDSMuUgFUIZECxzj4IMaEt2flnERW5hKCkgWkSbch2XOw6CIaAgyrxiZAAgbE4QA"
    target="_blank"
  />
  </TabItem>
</Tabs>


## Incorporating a compute shader to move the triangles

Now that we have basic triangle rendering, we can start incorporating a compute shader to move the triangles.
For now, we will apply some simple movement to the triangles.

Let's create the compute shader:

```ts
const computePipeline = runtime.makeComputePipeline({
  code: wgsl`
    let index = ${builtin.globalInvocationId}.x;
    var instanceInfo = ${trianglePos.asMutableStorage()}[index];
    let triangleSize = ${triangleSize};

// wrapping the 2d space around the edges
    if (instanceInfo.x > 1.0 + triangleSize) {
      instanceInfo.x = -1.0 - triangleSize;
    }
    if (instanceInfo.y > 1.0 + triangleSize) {
      instanceInfo.y = -1.0 - triangleSize;
    }

    instanceInfo.rotation += 0.01;
    instanceInfo.x += 0.01;
    instanceInfo.y += 0.01;

    ${trianglePos.asMutableStorage()}[index] = instanceInfo;
  `,
});
```

<Aside type="danger" title="Remember to add proper permissions!">
  The code above will not compile because trianglePos.asMutableStorage() returns null.
  This happens because we need to add the proper permissions to the buffer.
  ```diff lang=ts
  const triangleAmount = 10;
  const trianglePos = wgsl
    .buffer(
      arrayOf(
        struct({
          x: f32,
          y: f32,
          rotation: f32,
        }),
        triangleAmount,
      ),
    )
    .$allowReadonlyStorage()
  +  .$allowMutableStorage();
  ```
</Aside>

If you do not specify the workgroup size, the default is `[1, 1, 1]`.
To define it, you can use the `workgroupSize` property in the `makeComputePipeline` function.

```diff lang=ts
const computePipeline = runtime.makeComputePipeline({
  code: wgsl`
    ...
  `,
+  workgroupSize: [1, 1, 1],
});
```

Now, all we need to do is execute the compute pipeline before rendering the triangles.

```diff lang=ts
randomizeTriangles();
onFrame(() => {
+  computePipeline.execute({
+    workgroups: [triangleAmount],
+  });
  pipeline.execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
    instanceCount: triangleAmount,
  });

  runtime.flush();
});
```

<Tabs>
  <TabItem label="TypeGPU">
    <details>
      <summary>Click to see the full code</summary>
      ```ts
      import { addButton, addElement, onFrame } from '@typegpu/example-toolkit';
      import { builtin, createRuntime, wgsl } from 'typegpu';
      import { arrayOf, f32, struct, vec2f } from 'typegpu/data';

      const runtime = await createRuntime();
      const device = runtime.device;

      const canvas = await addElement('canvas', { aspectRatio: 1 });
      const context = canvas.getContext('webgpu') as GPUCanvasContext;
      const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

      context.configure({
        device,
        format: presentationFormat,
        alphaMode: 'premultiplied',
      });

      addButton('Randomize', randomizeTriangles);

      const triangleSize = 0.2;
      const triangleVertex = wgsl
        .buffer(arrayOf(vec2f, 3), [
          [0.0, triangleSize],
          [-triangleSize, -triangleSize],
          [triangleSize, -triangleSize],
        ])
        .$allowVertex('vertex');

      const triangleAmount = 10;
      const trianglePos = wgsl
        .buffer(
          arrayOf(
            struct({
              x: f32,
              y: f32,
              rotation: f32,
            }),
            triangleAmount,
          ),
        )
        .$allowReadonlyStorage()
        .$allowMutableStorage();

      function randomizeTriangles() {
        const positions = [];
        for (let i = 0; i < triangleAmount; i++) {
          const x = Math.random() * 2 - 1;
          const y = Math.random() * 2 - 1;
          const rotation = Math.random() * Math.PI * 2;
          positions.push({ x, y, rotation });
        }
        runtime.writeBuffer(trianglePos, positions);
      }

      const rotate = wgsl.fn`(v: vec2f, angle: f32) -> vec2f {
        let pos = vec2(
          (v.x * cos(angle)) - (v.y * sin(angle)),
          (v.x * sin(angle)) + (v.y * cos(angle))
        );
        return pos;
      }`;

      const pipeline = runtime.makeRenderPipeline({
        vertex: {
          code: wgsl`
            let instanceInfo = ${trianglePos.asReadonlyStorage()}[${builtin.instanceIndex}];
            let rotated = ${rotate}(
              ${triangleVertex.asVertex()},
              instanceInfo.rotation
            );

            let offset = vec2f(
              instanceInfo.x,
              instanceInfo.y
            );

            let pos = vec4f(rotated + offset, 0.0, 1.0);
            let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
          `,
          output: {
            [builtin.position]: 'pos',
            fragUV: vec2f,
          },
        },
        fragment: {
          code: wgsl`
            let color1 = vec3(196.0 / 255.0, 100.0 / 255.0, 255.0 / 255.0);
            let color2 = vec3(29.0 / 255.0, 114.0 / 255.0, 240.0 / 255.0);

            let dist = length(fragUV - vec2(0.5, 0.5));

            let color = mix(color1, color2, dist);

            return vec4(color, 1.0);
          `,
          target: [
            {
              format: presentationFormat,
            },
          ],
        },
        primitive: {
          topology: 'triangle-list',
        },
      });

      const computePipeline = runtime.makeComputePipeline({
        code: wgsl`
          let index = ${builtin.globalInvocationId}.x;
          var instanceInfo = ${trianglePos.asMutableStorage()}[index];
          let triangleSize = ${triangleSize};

          if (instanceInfo.x > 1.0 + triangleSize) {
            instanceInfo.x = -1.0 - triangleSize;
          }
          if (instanceInfo.y > 1.0 + triangleSize) {
            instanceInfo.y = -1.0 - triangleSize;
          }

          instanceInfo.rotation += 0.01;
          instanceInfo.x += 0.01;
          instanceInfo.y += 0.01;

          ${trianglePos.asMutableStorage()}[index] = instanceInfo;
        `,
      });

      randomizeTriangles();
      onFrame(() => {
        computePipeline.execute({
          workgroups: [triangleAmount],
        });
        pipeline.execute({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              clearValue: [0, 0, 0, 0],
              loadOp: 'clear',
              storeOp: 'store',
            },
          ],
          vertexCount: 3,
          instanceCount: triangleAmount,
        });

        runtime.flush();
      });

      ```
    </details>
    <LinkCard
      title="Run it in the playground!"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoEIFcYwgOwBoV0BRAGwFMRL8ZiCAxKZGuAXzgDMoIQ4A5AAEYATzCUA5mCwB6SgA9WYKgFo8EcgGtgMAQG4AUKEixEcAEZZg5GMCJwAxlErIYlAEpY6oSsQDukgDO5BzcvPwCYhLSWAbG4NDwSMhQLKIA8lzEXADMAEzEQTBQWI70cABulI75XGE8fILRUjKyqG7I8YaOBMVwpT5sALwo-si6Ti5unt52NAAUAJRGvfj9qJSVwI6UcKOD85QAdJvbu0Y9ffCOyPiVyEH7YxPwaKgU1LQwCwK3948BMQUkEJOUPG5gBAAFxwACMHBWV3WNwI7gU8FG-weQWOkkoMAAwmjFD8BP5KBZYgIligngBxAAKAFVCXcccS6KTVtc4GAXEFvpCmNAQG5nvhkNtJG5oHiZHiCYyXFxKGlKKg2QCgoxRW5lpc1uiYMc1lxgJIsC4FghDHA4Gcdn47dw9TBYfzKIK6ML8LqoGL6C7kOQwAALZAAWQgm1hAk9ICwtmAKmAGqBhnYSMM72wuAIvwh%2BFQfGAAC9KECBncSyBy5QACpQYB3SRUILZtb9Eot-BtygAZXrzwADMd8jyUXAe62qAA1NXo56BEIu45WLiqqALVLpLILaq1bJwXJLYgAbRd9vPY5HxBnfaoQ4rAF1CFe4Of1M3Z4P68Rv17ftn0oN8P3PB9gP-OBAN-ECwPtF8ljXAASENyAgfwF1gRRfmqHCFBpQ1eUgqgAEEQAgOZnjhEdJ27H9H0oRkICeUYV3INcNy3BYP13ZBMi4Xj7REuBilKcobQ-USFFhPJCmkkTRDkgp31E0TeBgX0VIU9TETU9TSMoCiqLoAz7TPF1kPtY40PIDD-A8VwS3wchRAHPAWHxZZUPQzDIxwZALCfTzkG87MuG8cooXwati1LCsmyA9tlkQF0u3gSAgl0GK2M-F8jHtLhoDgBYqHgYBR30OBKoAHmnRj%2BxMuZquAABqNraVtUSMrgBRnkjNww2OFh4pAVKACo4HyGD4UKkTetEAahpGms%2BEm6bZrheb7V6zTfWWmBhtG2sNsGo7jkZABJOAponD8spyvpjhkIIwxtPriFEYh9rsAhEXm9gXUOXxjn8Zt3GwTc1QWIyWKCYhHr%2B9YkSB5F%2Bl%2BvZ2OCchji4fAAAMD1hQ86mIX8dNpVQAD4qhqOo0vtcq%2BVY55SeEkSD2Ofqpt6IIdyYpYqdKypjiWqbsvwAX%2ByF8yRe526xPsaWqCFuA2vl8WnFYlXKCFqz5pcGArVirKjHYAniKnMAU0och7CxgY5lBsUtE8WhNigRlbft-BKCk%2B18PRWFuoWmNKFhDiCcU5n7GKO5diu-BiueFCEDh1jjkeJy0AINyPOgML-aWdhzzTqwbDsfBjjjrT8ET4tFHYAqY4JAYIC09xUFThBMfYDm9LTozsPRLOghH3CS7l0Ta4Tygk%2BKkaO99RTsz05mIE3QVMTpo8B-U2f6-n5OIG56eRMPhvF9EVfLnXtusrZmoABYhMx7uNc3rht%2BIW9iDhY4I4kT33gDwMKzI5zPAWO-dWu86gLCHo1J89Z2DEEQclP8FYsy0lkHAoS6C4IoMVvkQBwCRIEzllRGAMh3SM3UueCuyZq5Ixii%2BOMWUMx6TAZICBJN6bZA-Kgl0QiipeRoHQEOH5eixjgFHVuqIMJQARKMQ8uQFhwgAJwADZAFwFwfkAArAYwB-8Ry3j0dNIxJjLHGJHBYwxtiyGiWZr0RRM0VE1DUfkDRuj9FWLvPCOEz9fE2OsfkZ%2B5i-GOLvupZmqBgD9FGFQPsR0FjcIgbNdmY4DG-2OAYoWMTnFt1cSVUYdYFALBKUo4gVTCgOgSTANe6kjYm13s-SpmhoD-1ITtOAFCPxaSgPiWhl49Khy4W6D0AohTI39IGc%2BIiRIIQ4AZfkoAcrVEkaJPAkAMKSGUs0JBlBVD22KJwlZmZOy8l6OAHAzEfYO2eCDGgxxXaUGJLc9w3sJC%2B39qHaREdZE42jkUiqjd%2BqjHLtYJheIMIWBDEnSoEBbjIyuqgdg3NekPCgDVFEc8F4QB7hnXEjwApaWCoOUK4VS72E2AoFuoKGoYJAkSo5IF2CFJqvUBYl9j6L36rTABdiNZGRAl1RSvKCUK1GKoIVs1RX1l6UDGe3LJUnzFnAQVuiRVsvrOKvSarr7PFlbo1QTLCEViVYYD8hrT6-RiurUYt5to2rxUfKV-U2pOsAS6mebqr6nyWl6uAzrOUEKYvDMeZKgohULtS88tLFAvmeLa%2Ba-SsyXBOglRsRz%2BZIiYCwRYqVhi03%2BXwGh9yfkO2OIoGodyA4iX8NALQkheBYDAEEWEEEjnNToMsjNLobZVr9jWhQdb3ANt2p0qAZFcDIEcGGcRMBO2fkUuM9S2xKD%2BFhEaUkioiRWhcHQBspIrTF1NNMdwc40z%2BGWOfXaVBUhzhDFgQFN5f4fpDcs9eEA0AZDAHGRwj6oDnL0sUaAlB-1xnAy4UDIlFmITlkHRQxI5iwlyHLXlqGJHmqYr2oM9oB3A2di8rg5AsBvQNJcowQA"
      target="_blank"
    />
  </TabItem>
  <TabItem label="WebGPU">
    <details>
      <summary>Click to see the full code</summary>
      ```ts
      import { addButton, addElement, onFrame } from '@typegpu/example-toolkit';

      const adapter = await navigator.gpu?.requestAdapter();
      const device = await adapter?.requestDevice();

      if (!device) {
        throw new Error('Failed to acquire a device');
      }

      const canvas = await addElement('canvas', { aspectRatio: 1 });
      const context = canvas.getContext('webgpu') as GPUCanvasContext;
      const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

      context.configure({
        device,
        format: presentationFormat,
        alphaMode: 'premultiplied',
      });

      addButton('Randomize', randomizeTriangles);

      const triangleSize = 0.2;
      const triangleVertexData = new Float32Array([
        0.0,
        triangleSize,
        -triangleSize,
        -triangleSize,
        triangleSize,
        -triangleSize,
      ]);

      const triangleAmount = 10;
      const trianglePos = device.createBuffer({
        size: triangleAmount * 3 * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      });

      const triangleVertexBuffer = device.createBuffer({
        size: triangleVertexData.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true,
      });
      new Float32Array(triangleVertexBuffer.getMappedRange()).set(triangleVertexData);
      triangleVertexBuffer.unmap();

      function randomizeTriangles() {
        if (!device) {
          return;
        }
        const data = new Float32Array(triangleAmount * 3);
        for (let i = 0; i < triangleAmount; i++) {
          data[i * 3] = Math.random() * 2 - 1;
          data[i * 3 + 1] = Math.random() * 2 - 1;
          data[i * 3 + 2] = Math.random() * Math.PI * 2;
        }
        device.queue.writeBuffer(trianglePos, 0, data);
      }

      const wgslCode = `
        fn rotate(v: vec2f, angle: f32) -> vec2f {
          let pos = vec2(
            (v.x * cos(angle)) - (v.y * sin(angle)),
            (v.x * sin(angle)) + (v.y * cos(angle))
          );
          return pos;
        };

        struct TriangleData {
          x : f32,
          y : f32,
          rotation : f32,
        };

        struct VertexOutput {
          @builtin(position) position : vec4f,
          @location(1) fragUV : vec2f,
        };

        @binding(0) @group(0) var<storage, read> trianglePos : array<TriangleData>;

        @vertex
        fn mainVert(@builtin(instance_index) ii: u32 ,@location(0) v: vec2f) -> VertexOutput {
          let instanceInfo = trianglePos[ii];

          let rotated = rotate(v, instanceInfo.rotation);
          let offset = vec2(instanceInfo.x, instanceInfo.y);

          let pos = vec4(rotated + offset, 0.0, 1.0);
          let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
          return VertexOutput(pos, fragUV);
        }

        @fragment
        fn mainFrag(@location(1) fragUV : vec2f) -> @location(0) vec4f {
          let color1 = vec3(196.0 / 255.0, 100.0 / 255.0, 255.0 / 255.0);
          let color2 = vec3(29.0 / 255.0, 114.0 / 255.0, 240.0 / 255.0);

          let dist = length(fragUV - vec2(0.5, 0.5));

          let color = mix(color1, color2, dist);

          return vec4(color, 1.0);
        }
      `;

      const wgslCodeCompute = `
        struct TriangleData {
          x : f32,
          y : f32,
          rotation : f32,
        };

        @binding(0) @group(0) var<storage, read_write> trianglePos : array<TriangleData>;

        @compute @workgroup_size(1)
        fn mainCompute(@builtin(global_invocation_id) gid: vec3u) {
          let index = gid.x;
          var instanceInfo = trianglePos[index];
          let triangleSize = ${triangleSize};

          if (instanceInfo.x > 1.0 + triangleSize) {
            instanceInfo.x = -1.0 - triangleSize;
          }
          if (instanceInfo.y > 1.0 + triangleSize) {
            instanceInfo.y = -1.0 - triangleSize;
          }

          instanceInfo.rotation += 0.01;
          instanceInfo.x += 0.01;
          instanceInfo.y += 0.01;

          trianglePos[index] = instanceInfo;
        }
      `;

      const module = device.createShaderModule({
        code: wgslCode,
      });
      const moduleCompute = device.createShaderModule({
        code: wgslCodeCompute,
      });

      const pipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: module,
          buffers: [
            {
              arrayStride: 2 * 4,
              attributes: [
                {
                  shaderLocation: 0,
                  offset: 0,
                  format: 'float32x2',
                },
              ],
            },
          ],
        },
        fragment: {
          module: module,
          targets: [
            {
              format: presentationFormat,
            },
          ],
        },
        primitive: {
          topology: 'triangle-list',
        },
      });

      const computePipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: moduleCompute,
        },
      });

      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries: [
          {
            binding: 0,
            resource: {
              buffer: trianglePos,
            },
          },
        ],
      });

      const bindGroupCompute = device.createBindGroup({
        layout: computePipeline.getBindGroupLayout(0),
        entries: [
          {
            binding: 0,
            resource: {
              buffer: trianglePos,
            },
          },
        ],
      });

      randomizeTriangles();
      onFrame(() => {
        const commandEncoder = device.createCommandEncoder();
        const textureView = context.getCurrentTexture().createView();

        const renderPassDescriptor: GPURenderPassDescriptor = {
          colorAttachments: [
            {
              view: textureView,
              clearValue: [0, 0, 0, 0],
              loadOp: 'clear',
              storeOp: 'store',
            },
          ],
        };

        const computePass = commandEncoder.beginComputePass();
        computePass.setPipeline(computePipeline);
        computePass.setBindGroup(0, bindGroupCompute);
        computePass.dispatchWorkgroups(triangleAmount);
        computePass.end();

        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setPipeline(pipeline);
        passEncoder.setVertexBuffer(0, triangleVertexBuffer);
        passEncoder.setBindGroup(0, bindGroup);
        passEncoder.draw(3, triangleAmount);
        passEncoder.end();

        device.queue.submit([commandEncoder.finish()]);
      });

      ```
    </details>
    <LinkCard
      title="Run it in the playground!"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoEIFcYwgOwBoV0BRAGwFMRL8ZiCAxKZGuAXzgDMoIQ4A5AAEYATzCUA5mCwB6SgA9WYKgFo8EcgGtgMAQG4AUIYDGBAM7w0yMDEpQ4AXhQB3ZLrj5kAN2CTkeFAAdNJYAPxBUJQAjliUlgCCqDZ2UAAUAJRGZviWcKiUviaUTq7uVsm29hFRsfEwACKFwMWZRobAXHBpAIQFRZQZiIZwcDAAFrwunpTTpFC86QKM7lSoYxAoJrHAUSj5zcUCWYbsxjl5Jsj43sjmpchuHmioFNS0MGkCVzd3AsRIO4SEwwABKAWAEAAXHAAIwcE4XeA5OwKeDOH63cwhSgwADCBFRnwELkoACNQscUPcAOIABQAqnjrliCXRFDBshZ4GAouYPhCmNAQAFSl5fP5AiEZDiYHSolx7FFUMzfuZGMKAm1zoSOUEclw-FgomkECMDgNCOauJqYDDefEBTBIfgNVARfRzchyGBxsgALIQAowgQOkBYcjOlTASiof6nE6GF7YXAEL7g-CoPjAABelH%2BcBYmezeYAKlBgNdJFRzImkWMK1WqABlXMlZwABiCACYubl4DBG-hq5QAGr2VENALIMWzOCMcgQAIAZm7CQWyFEaQA2uaux2raNB5Xhy224e4OohyPW3mL1eTzfz%2Bbj03KLfKPfX6f38%2BALp1tyDaPlQCQgBAWB0KUsIdn2eTfiOdIQPczj9C0lD6lEASUNgXCKukZqjOYbYwghoHgZB8AAFRwMucA0QALBeWDmMgkiUDC9IMrh%2BEMqx7FBM2pYAPKggkNKkHAAA%2BcBcTx9h8WxGF4sJdIAJoAPoNEJVrsIB-bAW%2B46wIo8kOKhhwYSYWF2GZprmsReakdeVDGZO05BGSoh2AAMrQkgTMx-EcbJjJmYpAmjqQoKlqQAAaF4imAEioAk%2BI2S6zlxLpJz4HOC5LjAq7riwW5kWOE6mVgeH2LK-o2ClGbsZkGRBPynzlW5ihTjAyAnJ1lUKGZQSQUl2qGFwkEgi6hbXFmIBtuWIHxJkwyjJ03R9JZQyEaMha4sa%2BBGKMZyjPWyS9bO0wFSua4bmVLmUGBEFQTRy4nKMNoOGkVDwMApSwXA-0ADyGT%2Bz2UfoQMANTQzt5qjBdyDbv9b1-qU9UTJEc18KtNHdpecLHXtSMo-RtFwNDcLo84mPjNjxYgHjcAE6oRMI-k05k29lMszTcB0wz83M4LdIAJLk725qnRa6FBHUcRBC4Fa2dV%2BFpOVSHmMQB6c71JxnKYQEuJI5jkASBSlAABta%2BCFhAvV2Gk3gwt4lAmN2XDEG%2BMJcKuQyqAAfHAbse10u2jL9cCQChIfu92aQc6MztBAo5NmOYaRvhkAfdN4QSiOTxH4FnP45xee156nRfACX2dDFTKeFzRGelyOOccx9e1RDAh3R8hxPsO0RGDlgIJwEtb49TOEdwGnvurhXcCFwv3ZL7wjszavF5D8YI9QGP8BdQowk4DI8Cz0IZJYMAka12kMe6C6QyP86BBwK77sMV7HNCIuVxvxLrCIYPA2IMlHB-OOYcd7DzgFfWuqBa6SDSB2IYQhJC8CwGAFBQxbhQGBpYaASliBYVQMHTWyFIHIHusDSeP5p6B1gUIN2JkFC2zgCKWubk0hXxvnfEutdLDXGKBpBBighjAGADCLAq44CED-hAABLocEh0-mHAOwdj6nxgOfNae0o6CN6vgYoYt8A2lKBQ8wKNgB-lgZHXE9tHaxlKBvbCztiCGOEZQUxNpIgO0FPgLu9j4AQDwu1UoocE6eOMd4sxEBU4eP7F4nx8TRCJkrlHGOESv5pFcXYdYVNQlcHajrIIutYRlKCXAKOoDJDgNKLk-x%2BTeaRK4GkAAJAgcqH52DEE6d0tsekhiyCgZ7DpXTHo9MlpU4mowe59y0WfHAD9kLEFqeAruhtRhCFqTQOg7DOGuhYMghRSi0zAO4Mc%2BpajPYaLgf-AJKjQ7fz0cEuAZhFxQHhM4UOy40iwgAJwADYylwBGd2AArBCspxAYL7jBSzKFMLEXQo7AiyFqKqlRw%2BdAAmPz3Z-O7AC0F4KkXlNhAxElKLkXdgYvC0lmK7HVIcYgvIzgqDDgmGkdZEC2aRJQUECFpSIU5yZdizQ0BSgLQUGkHFXziByrXvkYAlh0ndwOlAO2zzZUSqgLCmZ0tDBW3aPWE2ZsLaUAJOAHA7Y4A233ofCej1p6vLnpAv2a8OYr24IvDmeSt4%2Bs9SdJhZIEFIJUegzB2DUEh2oQQwIxD9poA0srXQlByGPS1lQmhdCRwMKYWYa1dg4EuGgFoDBEEwAaUcpQf5GQDnuHwFa8%2BtbeG32dCXasEAyTelETcRRATRGoCGJIYAqA1HLiwPDDJDixFp2cKO1AqdZmxocNEkxcSLGZuQijTMihbEcyjgMvMpR%2BmTMGUyjaaR12xN8WnYOFS0VU2PYMV160kkxJSdXZwqhH2ExfSumW60ujXo-Ru3xhcH2gufeevM07K5AzA7e1JpRf2grZgBjmWy9o3q-f69%2B0NOxlNhCu3DcTq6EbgPuEjHMyMQcpkRjsNGOaWN3QUBQ-M6MQEHkak1QFwKoAjLatCxRMKUGws2P0BQoCBkE1QeyZ0gwhTNebJTOU4LwAE0J5tNrSgiasjZd8Un7CyaEwp95SmYQqYtTpuw6mdQGTAMACQ5Ba7CcsmJ7CoJaDSbpM5ygrm8rmfIJuCCdpBDIBwBAeMowWGohhLPLTVAYRJc-Bza%2BNUoDmBhLuBDb69rUNKs2Y8wYWbkyYknAruAKzXzsNluAuW8t7Vnk1uA5hjNQB8gOwBMIDyVby0U9qvWl6ta%2Bh6EMXBFy3QUN2GLrWOAjb2n%2BRbvSObLelheXZHwEsc1SyloMQml69SgOxGA9XGuVxa3tMbAR7R8idC6N0HoVtL3WydC8vJQBPzdjtyueBICLkkKIEM5VVCucsHN1bek%2BMGULS2vzLm3N6Y89ZcTdhbOUARwFtzwXQs4BDJFvAc24c2t%2B3tPbHCDtUAxzvezRsDKhszDSKNyOBiedsgg5nlbceiDC-afzgWMKnYwJzqNPk8efFQReD4FZ4g5Y5ldxniDhzDcq3yCCUBihk7yxl-Czllpaxe1hi863ocObyErrnWCMes7lqj7CIumdRp53zizRbMcC7c7KR3qArdgHF7z5ZUvzQy5jOdhXlWldINV3l9Xxotf5dGLr%2Bw%2Bu3yG8q6tyume4Cm8TEWeai1HqZxOEwFgNA0irUcMHXa9ZC0ikzKQYxSnzKy1E-b9HfB6%2BvCb9J7UimDJEmNGOGM0wMS6jRLKPExooh0FLByIfmR2fD9mONfveQZ%2B%2BbuOYJo5hrLOcCJxRk3m91QDpFvnfe-bCSucLPOVaVeomHGHss78u8tXdiyP0i8%2BoijhH4ts6VA1Co43ocQOWus4BOsb2TWU2qAwkYAIYJggBUAc2eWhCUQcBIYaB%2BYRulcUBu85otefA8OW%2BpQdec0jeZg0mnkUgtcGOZ%2B5gxexMJOdg9B2I7UWOguOq7uHBbmXczBmOW%2BbUuIPufuKCxAluUaGOfBRBNqrBQQrKYAAQj%2BAA6mWhWlgpnOVBDHQNIdwYIT5qvhZo5lvhQc3qQZ3uQT3rVGSDQfgMfpvgwbkj5vYKwRfhWFflAF3IoQwaYVQewZ7kFk5ojnlF4SYVYcEO1MfHZLrANKwmZKET4eEUITACIc7rrBIZWgkeYL4bVKgCwC4GkMuMQFoRRDocTN4dkUkQYWqvpvLHEIrOYFgGSAtJ8NuGQQ3kkYaPgCquMJkABEYGbkAA"
      target="_blank"
    />
  </TabItem>
</Tabs>

## Adding the boids logic

Now that we have the basic structure of our program, we can start thinking about the logic that will make our triangles behave like boids.
First, we need to consider how we read and write to our buffer.
The current implementation only reads and writes to a single element in the buffer, so there is no need to worry about race conditions.
However, to implement boids logic, we need to read from multiple elements in the buffer to calculate the new position of each boid.
This situation seems prone to race conditions. To avoid this, we can take multiple approaches.
We'll opt for the simplest one, which is to create two buffers: one for reading and one for writing.

<Aside type="tip">
  In this particular case, we could also use a single buffer and employ atomic operations to read and write to it.
  However, this would make our simulation nondeterministic, as there would be no way to guarantee that the order of operations is the same every time.
</Aside>

Before we jump into the boids logic, let's get familiar with the concept of slots.
A slot in TypeGPU is similar to a template. We can define typed slots and use them in our WGSL code as their underlying type.
As an exercise, let's use a slot to make our triangle rotations invertible.

```ts
const rotationDirection = wgsl.slot<number>();
```

Now that we have our slot, we can use it in our WGSL code.

```diff lang=ts
const computeCode = wgsl`
  let index = ${builtin.globalInvocationId}.x;
  var instanceInfo = ${trianglePos.asMutableStorage()}[index];
  let triangleSize = ${triangleSize};

  if (instanceInfo.x > 1.0 + triangleSize) {
    instanceInfo.x = -1.0 - triangleSize;
  }
  if (instanceInfo.y > 1.0 + triangleSize) {
    instanceInfo.y = -1.0 - triangleSize;
  }

-  instanceInfo.rotation += 0.01;
+  instanceInfo.rotation += 0.01 * ${rotationDirection};
  instanceInfo.x += 0.01;
  instanceInfo.y += 0.01;

  ${trianglePos.asMutableStorage()}[index] = instanceInfo;
`,
```

<Aside type="caution">
  Now that we have code that uses a slot, we need to ensure the slot is bound to a value before creating the compute pipeline.
</Aside>

Let's create two compute pipelines: one inverted and one not inverted.

```ts
const computePipelines = [-1, 1].map((direction) =>
  runtime.makeComputePipeline({
    code: wgsl`
    let index = ${builtin.globalInvocationId}.x;
    var instanceInfo = ${trianglePos.asMutableStorage()}[index];
    let triangleSize = ${triangleSize};

    if (instanceInfo.x > 1.0 + triangleSize) {
      instanceInfo.x = -1.0 - triangleSize;
    }
    if (instanceInfo.y > 1.0 + triangleSize) {
      instanceInfo.y = -1.0 - triangleSize;
    }

    instanceInfo.rotation += 0.01 * ${rotationDirection};
    instanceInfo.x += 0.01;
    instanceInfo.y += 0.01;

    ${trianglePos.asMutableStorage()}[index] = instanceInfo;
  `.with(rotationDirection, direction),
  }),
);
```

To check if our new pipelines work, we will create a toggle to switch between them.

```ts
let invertRotation = false;
addParameter(
  'Invert Rotation',
  {
    initial: false,
  },
  (value) => {
    invertRotation = value;
  },
);
```

And add some logic to the main loop.

```diff lang=ts
randomizeTriangles();
onFrame(() => {
-  computePipeline.execute({
+  computePipelines[invertRotation ? 0 : 1].execute({
    workgroups: [triangleAmount],
  });
  pipeline.execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
    instanceCount: triangleAmount,
  });

  runtime.flush();
});
```

<LinkCard
  title="Run it in the playground!"
  href="/examples#example=playground__JYWwDg9gTgLgBAbwFBzgQwCYYEIFcYwQB2ANCulgKIA2ApiLUTGasQGJRoMsUYAKaTgxi0oZAL5wAZlAgg4AcgACMAJ5haAczC4A9LQAeXMHQC0hCNQDWwGAoDcSUJFiI4AI1zBqMYKTgAxlC0aCIASrhMoLQkcADumgDO1HCSMnKKahrauA5O4NDwCOhQnKoA8lKxUgDMAEyxiTBQuAHMcAButAF1UqnSsvIKWVo6uhihaHlIAcRNcC1RDHAAvOhxaLaBwaG0EUu0ABQAlI6zRPMYtB3AAbSrC5G%2BDAB0Vzd3jjNz8AFoRB00IkHmgNltMBgaPRGDBDgo-gCgQpYsUgRo2mFQsAIAAuOAARlSp2%2BF1%2BxBEBngawRgMSL00tBgAGFyYZYQo4rR3DkFMd0MCAOJ8ACqTP%2BtJZTDZZx%2BcDAwUSMKx7GgIFCDyIaBumlC0HpOnpjL4wSkomCGDFiMSbFVoROX3OFJgL3OUmAmlwwUOyFQ71uMXIUltMDx8toiqYyqINqgauY5DQ1DAAAs0ABZCBXPEKMMgXA%2BYAmYC0DDIpDiYlICF4AjEOGYogYOTAABetGRC3%2BTZArdoABUoMB-po6IlK%2Bd5rIYFGACLAYJtbFEB4JZIvZIQGAAHiIuBA7lEAD57UgSfNmkOiCPaABlXsPAAMLzqMtJcAvw7oADVRBSV0lqHIF5PCkU0oEOQQykqQ4uh6Ko4BqY5YgAbXIVBkKfB9Yg-K86DvNsAF0eHQ8xB0-W9e1iUjL2vfDaCItC4GQnDaMouBqPIuiGNQAjjiAgASRNqAgOIf1gQw4S6cSDF5B1ZRYugAEEQAgJ4HnxB9X3PMjcNoPgIGBNZV0A1BgNwUDREORjILQCopCs1BHLgJoWjab1GKcgw8VqBoPMc1RvPqYinIWTco0C3yQqJYLUAU2hlNUphgqQ8g%2BNMwTqGEuIwhCJsiGoVQb0ITgGROAShJEtN8DQdw8OKtBSsrKRIkXYhO0bZs2wHGjRxORByAneBIESWwl0MpiCMcVAgygOBDjoeBgEfew4CWrd3x068EqeFbgAAaj2vkfUcwa4AMB401CZMXk4DqQD6gAqOA6nYgkppO2VVAuq6bq7ORHue178Xe1BTqnKNvpga7bu7AHLqhl4%2BAASTgJ6X0Y4bRrmF4dESZNvTO2JVFicHfDait3vEchFmeWgXjiQcRDwCzwLi-TEliTGyYuYkqbPeBSfuIyAJeKQiAAAxgvFYN6WJyIivlTEPTpul6frUAWuUDIeGWHMcmCXnOp7ZkSCDdOORW5o6F4vqekaiDN68LeCg2jecvxHboC24D2q2bdRwIDM92gLdS97ghgT1l2GxxxHFuS3zAQtaGoPwhceA4XjVKw9kYK4oD4ZPU6II5jqkik8WO0HM1oPFjPFvzNb8Jp-juJGiCDB5%2BIQNmDJeIEcswYgCqK6AGqOY5xGQ7vPG8XwiBeZvpyINvG0McRJsbxlQunEQMC7hBBfEPWou7uKxIpfvEgviTJ5ixyl9b2h26DG6wu5vzKyizWIFAxUqRVnBE%2BIVH4r2fh3CAht76oFAavV%2BqhP5fG-tvYaOtugABZ7KC33r7X%2BUh-6xEwrEfELwHzEmQfAGQDVhRfgeIcbBPtAG9EOGfTaeFeziFiKwnqFE2wVj5LoJh9luGcQ4QHOopDyGOXFsFVSMAdAhnViFZCs8CwLy5kuAi2ZhpliilQzQNDpaqyqIxTh5AzHTRKgwJgldGKzCzPEACDcKGB2ElAQkaxYI1EOPiAAnAANlIXAQRdQACsoTSHEIfJhYJz1wmRLiREh8sSwlJKkU5TWsw3EvU8d0bxdRfFBJCfErCBJ8ToKKYkhJdR0ExOKWkpBIVNYYGAPMNYdArxQ0OPomhr1dZPlCYQl4oSLaNIydvLJ0AHg9gMIcSZ7jYjzIaHAFpTQv4hQjlHQB6C5mWGgMQyRIM4AyMYtOKADJFGoSilXEKM04yhgVEqbmMY4z3wsY5biqQeDylAKNLotinKEEgMJTQAVMhsNoKYVOTRdFfPLOOWUsxwD4D0kXNO41kKmHxMQgiWc0BgEOIcFpC5uZ8hWIeamTxoh4pziyZFIhC4aGLqXOxNc65OMYk3Ne501gzy8Go%2Bkwl3CJnbh0CAfxuZIwwOIQ2RzASzVgeAzuvKe4QvZlfKq05aq3nqo1KefgrgGE3uM%2BAcU6IHzNRwsZq0%2BiHEVS-SB51lYkOSb7S1bYjp%2BXtRAw2DwsVBNMBtHhdEjlUycsAW13r4FwGdUEt1EK6KeqilGyBX01j%2BuSYG91tBQ2nnDaSJ%2BDq367yXD7NYmFCRPW7qTJcc4SVLnEEclNvq9rltIcDRizavqtrgBW61IjdLqqBJqmqdUx56uQgawwBEHgpveuLemth8Y1uIHW7o3NYjEvXUuFKqAKxkErFy8uYR36lrWFIRMipHAQgEEIRkllyAKFFb%2BOAJ6S3EFhTcvwo1EzeUvQGPdPAYKJlwCHVYysv0Al-G%2BiGniQM5vMQer4MNOr9ghabYk7A72ErJRBgacgFGoqZeiydUHYAwe5nAAA-L2uAeJ8S4sMN0FF7knJxGgFYTQshcBgESHiZiELtpME%2BRTcgSdiMlxeExgILGbnzMUgQNAARkzWJgHxpifkblORuLQOIeJHRskNMyT0wQmB9jZJ6CeLodgiC-MWOIJxoGBDoIIL88H%2BOlM84Qz538ICYHKGAbMAQXNQFhVFJo0BaABezBF4IYXHLvJ4sFcuhgWRPDxDUYKiq0s2KDeRIT8Y93rJptSqQ1BcB4xPKJoAA"
  target="_blank"
/>

### Double buffering

Now that we understand how slots work, let's use them to implement our double-buffer mechanic.
We will replace the rotation direction slot with two slots: one for reading from the buffer and one for writing to it.

```ts
const readSlot =
  wgsl.slot<
    WgslBufferUsage<
      WgslData<
        {
          x: number;
          y: number;
          rotation: number;
        }[]
      >,
      'readonly_storage'
    >
  >();
const writeSlot =
  wgsl.slot<
    WgslBufferUsage<
      WgslData<
        {
          x: number;
          y: number;
          rotation: number;
        }[]
      >,
      'mutable_storage'
    >
  >();
```
<Aside type="caution" title="Well, that's not very readable">
  To make the code more readable and concise, we can use a type alias for the buffer data type.
  ```ts
  const triangleAmount = 10;
  const trianglePosData = arrayOf(
    struct({
      x: f32,
      y: f32,
      rotation: f32,
    }),
    triangleAmount,
  );
  type TrianglePosData = typeof trianglePosData;
  ```
  Now we can simplify the slot definitions.
  ```ts
  const readSlot = wgsl.slot<WgslBufferUsage<TrianglePosData, 'readonly_storage'>>();
  const writeSlot = wgsl.slot<WgslBufferUsage<TrianglePosData, 'mutable_storage'>>();
  ```
</Aside>

Now that we have our data type extracted, we can also shorten the buffer definition. While we're at it, let's create two of them.

```diff lang=ts
-const trianglePos = wgsl
-  .buffer(
-    arrayOf(
-      struct({
-        x: f32,
-        y: f32,
-        rotation: f32,
-      }),
-      triangleAmount,
-    ),
-  )
-  .$allowReadonlyStorage()
-  .$allowMutableStorage();

+const trianglePosBuffers = Array.from({ length: 2 }, () => {
+  return wgsl
+    .buffer(trianglePosData)
+    .$allowReadonlyStorage()
+    .$allowMutableStorage();
+});
```

### Great! Now that we have our buffers set up, we can adapt our pipelines to use them properly.
<Aside>
We will create a convenience object to hold the buffer pairs, but you can skip this step and easily adapt the code to use the buffers directly if you prefer.

```ts
const pairs = [
  [
    trianglePosBuffers[0].asReadonlyStorage(),
    trianglePosBuffers[1].asMutableStorage(),
  ],
  [
    trianglePosBuffers[1].asReadonlyStorage(),
    trianglePosBuffers[0].asMutableStorage(),
  ],
] as [
  WgslBufferUsage<TrianglePosData, 'readonly_storage'>,
  WgslBufferUsage<TrianglePosData, 'mutable_storage'>,
][];
```
</Aside>

We will adapt the pipelines using slots, just as we did when adding the rotation direction slot.

```diff lang=ts
-const computePipeline = runtime.makeComputePipeline({
+const computePipelines = [0, 1].map((idx) =>
+  runtime.makeComputePipeline({
    code: wgsl`
    let index = ${builtin.globalInvocationId}.x;
-    var instanceInfo = ${trianglePos.asMutableStorage()}[index];
+    var instanceInfo = ${readSlot}[index];
    let triangleSize = ${triangleSize};

    if (instanceInfo.x > 1.0 + triangleSize) {
      instanceInfo.x = -1.0 - triangleSize;
    }
    if (instanceInfo.y > 1.0 + triangleSize) {
      instanceInfo.y = -1.0 - triangleSize;
    }

    instanceInfo.rotation += 0.01;
    instanceInfo.x += 0.01;
    instanceInfo.y += 0.01;

-    ${trianglePos.asMutableStorage()}[index] = instanceInfo;
+    ${writeSlot}[index] = instanceInfo;
  `
+   .with(readSlot, pairs[idx][0])
+   .with(writeSlot, pairs[idx][1]),
  }),
);
```

```diff lang=ts
const renderPipelines = [0, 1].map((idx) =>
  runtime.makeRenderPipeline({
    vertex: {
      code: wgsl`
-      let instanceInfo = ${trianglePos.asReadonlyStorage()}[${builtin.instanceIndex}];
+      let instanceInfo = ${pairs[idx][0]}[${builtin.instanceIndex}];
      let rotated = ${rotate}(
        ${triangleVertex.asVertex()},
        instanceInfo.rotation
      );

      ...

  })
);
```

Finally, all that's left to do is add some logic to switch between the pipelines and adapt our initialization code to write the initial values.

```diff lang=ts
randomizeTriangles();
+let even = false;
onFrame(() => {
+  even = !even;
-  computePipeline.execute({
+  computePipelines[even ? 0 : 1].execute({
    workgroups: [triangleAmount],
  });
-  pipeline.execute({
+  renderPipelines[even ? 1 : 0].execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
    instanceCount: triangleAmount,
  });

  runtime.flush();
});
```

<Aside type="tip">
  You probably noticed that we are calling `renderPipelines` in the reverse order of `computePipelines`.
  This is because we want to display the buffer that was just written to.
  The code will still work if you don't switch the order, but you will not see the most recent updates.
</Aside>

We will write the randomized positions to both buffers.
This is because, when we call the function, there is no guarantee which buffer is used as the source and which as the destination.

```diff lang=ts
function randomizeTriangles() {
  const positions = [];
  for (let i = 0; i < triangleAmount; i++) {
    const x = Math.random() * 2 - 1;
    const y = Math.random() * 2 - 1;
    const rotation = Math.random() * Math.PI * 2;
    positions.push({ x, y, rotation });
  }
-  runtime.writeBuffer(trianglePos, positions);
+  runtime.writeBuffer(trianglePosBuffers[0], positions);
+  runtime.writeBuffer(trianglePosBuffers[1], positions);
}
```

And that's it! We have successfully implemented double buffering in our example.
You can test it in the playground!

<LinkCard
  title="Run it in the playground!"
  href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoEIFcYwgOwBoV0BRAGwFMRL8ZiCAxKZGuAXzgDMoIQ4A5AAEYATzCUA5mCwB6SgA9WYKgFo8EcgGtgMAQG4AUKEixEcMRLgB1SQGdy2Ll0pQAqneSTKxAEZZgchhgIjgAYyhKZBhKACUsOlAfOAB3e3IObl5%2BAUspGQNjcGh4JGQoFlEAeS5iLgBmACZiOxgoLDD6OAA3SjDGrkyePkE86TlUaORCwzCCVrh2xLYAXhQU5F1wyOi4hOCaAAoASiM5-AXUSm7gMMo4NaWDygA6K5u7o1n5%2BDDkfG6yDsD3Wm3gaFQFGotBghwEfwBQIExDKdgknVi0WAEAAXHAAIwcU7fC6-AgxBTwNYIwF2F7eGAAYXJilhAhSlF84wExxQwIA4gAFNyM-605l0VlnH5wMCROwwrFMaAgaIg-DIG6SaLQekyemUGCCyIuCqUVCixF2Rgq6InL7nCkwF7nLjASRYSKHBCGOBwd63Hy%2B7i2mB4uWUBV0JX4G1QVX0YPIchgAAWyAAshArniBBGQFggsAVMBzcjDOxiYYIdhcAQ4Zj8Kg%2BMAAF6UZGLf7NkBtygAFSgwH%2Bkiodir5wWbWH%2BFHlAAyn2QQAGF6NaWkixDkdUABqrgpILSDmDL38zlch3KlRqh16-VqcHqx2IAG1g37X6vl8RpzuF32AC6hAfnAr7qNus5UIu7bEBBM5zjBlDAaBr5-lBAGwXA8H-khKF%2BoBxyngAJMm5AQCk%2B6wIocK9NRCg8g6MroXOACCIAQPsIL4suG5TpBc6ChAdgACJTCC17INUXCHMGrTtJ03qgQoeINM0oGiKpTQgX6fq8DAMZaepfqVjpW4IVQ7GcXQIHEnkcCDhZlBCaJ4lrHkECDCxVAuWJBlMZu3nOcJTimsCaysRUUkvMMIDenAVCzjAqZ4o0HDECcDwAHyIMGkQwJ6%2BCpOkoFnlgF5QIcQW%2BVMRG6XALykeQ5EpLEUTNvg5CiPOeAsN4JylU1LUZjgyC%2BNBvVeJQ9oVhOMpgJsUDhWBwbvvV1UheVYVfoBLxAm1aAEF1PXQFNJxmX6G12KFrh2K%2B%2BK7UCI0GeNC6Tf1L7BvhK3rQJPmbRVd0PXtdgHR1x3vdNn2-U5Lk3UtO0g89Y0TadH1mShgF8j9NjpPDHhTQAPI5-41QZxACDs4OiAA%2Bq0aMdllZm2A4%2BOeN4xN-cFrnk4IBYvVQdOQwITOGIBr6AQFCxU-O5FUsGx7kC8DgQDAhMs44W2uATHMkxhZPIBTVNHbT9N9YzWUzZO8ApEOMSy6rDwK%2Bkyty%2BreNa%2B47OUJzsPCX5ht86Nr1CwzIuW1WXAJJ02JFSwTYtu2etznYmU%2Bn61uysJuix8tEtGH6XDQHAhxUPAwArvocAV4T5n-lZ%2BxV8AADUze8unumZwoIIZtEqYvPHPaZQAVHAaWqASBedzKog933A-dnwI9j9hk%2BgZn%2BkxnPyULwncW8qPvc74KACScCj%2BuoGQHYOfzC8Mh2Km8UKMQojEJvwQEESU-sHl%2BxJC8W2uhKDwyqlzOGns7rLmAlnG%2Bn8LjEj0v-GggC7YgM9mAv211IH3RgdfW%2BCCjC-xJNLVWuwjwuy4PgAABnePE94BjEH-EZXkqgcoMMGB3MusCQQMNkvVO8Lxu6jzmKnf8xxWEl26C8Weo8b74CvBhCRF0pFCPPnAeRii5wSLgM3VRsjwjCS0VQCRwZEGLENIVWBRDqFS3gJEJsrhBTFkoOQEIkYQRfmIMDVUYBDiHGAKgBQvIVhZT-ssV4qotBxFoFcKAziJBuPwNNDufo6IUjxKk6eOZioOGoaBP03CQitH%2BHcE%2B%2BAi4gmIggBawAEaBIUOLaB7BXzVP8IEYI%2BAXjFIMvgMpjiFDsElgUhKhpFhkJiKgKpCAP6UHYPw%2BqulqlBSohSEGqyaLHHYCo%2BqPTSmUHKUXAeEzY4jKrIs0Z8BPJcAVFSHofQBgLIuXsvpByKkQCETs3SLz%2BlHNEGcr4FzuHX14X0AALDJWZUy9HXNucQb83iXjLnMfVbhPAvBuF3CCQ4ULdH3IfIcZZXMkLbLgESpyJKdGyHxY88luE%2BycAvkilFcBqFfM4jAGQYZcoXM-O0osXT8HwMArma%2B5ZeVZAxbuehDzagjO2aBBV9V0WSBoHQTJIy5g5MVvkoFYy5jkSgISNY956iHHxAATgAGxIrgNSxoABWB1SLvHLm-HaseTqXWeudcuD1jrfUssKfqzQ0A0omr6GaxoFrbX2q9T%2BAk%2BIwWxp9d6xoYL3VxsDYCxZ3DUDAAWGsRKkhkqHBVZi1efDVwOvhS8B1Eic2opDYakEvYFCHANdAfExBO1QGaP6AtMBzmLPylY%2B8YKO2hqgIi5FU8-RspGQZKADI8RrV5Vki5Rd4zRHDPKRU8C4wJi%2BSZL530T1XyHL2YIvQNUXLwJAcikhNKjC5qoNxrRxW6SVUSWydjDHgBwM5FxSSPFrC8QSXavj-ENJCWEpBESXhRMoMyADMQEmuPcUpeqWrKB4h1aBIpAzpn8s6fScivhkzlO6BAP48CT6oHYEIudPRyjV1JPsw5EBpkyzli0kIVxGnMe4UFJC0yRMMsbdXQYAT2OvM42onK%2BJbV6PE%2B2duIyflvKOd3NYqglN%2BonqpygzHf67Ok5p%2BTs9FPKbrhhJC6nnmyd%2BR82eun9OryMyZwwoELPvOOQZeBui1jfnxMx3z2mgtwBC2FpzWmXORei95%2Bq1SgH2146%2BfjigsZrHCxAKeurFmAN0E-HjqtiC1PqUEpphERlFdLalhcctyuLTug08WD1oY-sMFWQeicBxc1TsSbh1xaAgi4MmBURgmAsCOJlUJPK4AjaKmsAAhEtqecxUNAcSe4u6S24AAH4otwDxMDRQfRANYd0ikaAWhJC8CwGAOwq6goNzoN9SsU8HFxPQyBvbvQipHcJHiaBLxzthEu1k3trFcDIDCKmNVMBns43qhu3SNxKApDxI6VkBomSegcTAfsrJPRQxdDsGIu5SwpHOiMjOVByi7mTFgXDYEE3s-hWe3NEA0BVDALmMIDOoCfouWbSgfPcxi5F1%2BlRXP0mKGZPsPE9QVGacV%2Bq2zbEOL7DMp9pLixkGvC4OQLAj8Zp66AA"
  target="_blank"
/>

### Boids logic

Now it's time to finally add some logic to how our triangles move. This guide assumes some familiarity with [boids](https://en.wikipedia.org/wiki/Boids), but some of the concepts will be explained as we go along. First, let's adapt our triangle information struct to include velocity in addition to position.

```diff lang=ts
const trianglePosData = arrayOf(
  struct({
-    x: f32,
-    y: f32,
-    rotation: f32,
+    position: vec2f,
+    velocity: vec2f,
  }),
  triangleAmount,
);
```
<Aside>
  We can remove the rotation field since the triangles will infer their rotation from their velocity.
  This change will also align our struct to 16 bytes, allowing us to use it as a uniform buffer.
  All calls to `allowReadonlyStorage` and `asReadonlyStorage` will be replaced with `allowUniform` and `asUniform`.
  This adjustment will improve memory speed but will limit us to 4096 triangles. You don't need to make this change, as readonly storage will work just fine.
</Aside>

Let's also create a helper function to calculate a triangle's rotation based on its velocity.

```ts
const getRotationFromVelocity = wgsl.fn`(velocity: vec2f) -> f32 {
  return -atan2(velocity.x, velocity.y);
}`;
```

And use it in our vertex shader.

```diff lang=wgsl
const vertexCode = wgsl`
  let instanceInfo = ${pairs[idx][0]}[${builtin.instanceIndex}];
  let rotated = ${rotate}(
    ${triangleVertex.asVertex()},
-    instanceInfo.rotation
+    ${getRotationFromVelocity}(instanceInfo.velocity)
  );

-  let offset = vec2f(
-    instanceInfo.x,
-    instanceInfo.y
-  );
+  let offset = instanceInfo.position;

  let pos = vec4f(rotated + offset, 0.0, 1.0);
  let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
`,
```

Now we need to update our compute shader to account for the changes in the triangle struct.

```diff lang=ts
  let computeCode = wgsl`
  let index = ${builtin.globalInvocationId}.x;
  var instanceInfo = ${readSlot}[index];
  let triangleSize = ${triangleSize};

-  if (instanceInfo.x > 1.0 + triangleSize) {
-    instanceInfo.x = -1.0 - triangleSize;
-  }
-  if (instanceInfo.y > 1.0 + triangleSize) {
-    instanceInfo.y = -1.0 - triangleSize;
-  }
+  if (instanceInfo.position[0] > 1.0 + triangleSize) {
+    instanceInfo.position[0] = -1.0 - triangleSize;
+  }
+  if (instanceInfo.position[1] > 1.0 + triangleSize) {
+    instanceInfo.position[1] = -1.0 - triangleSize;
+  }

-  instanceInfo.rotation += 0.01;
-  instanceInfo.x += 0.01;
-  instanceInfo.y += 0.01;
+  instanceInfo.position += instanceInfo.velocity;

  ${writeSlot}[index] = instanceInfo;
`;
```

<Aside type="caution">
  Now that our triangles will move in less predictable ways, we need to add additional clipping logic.
  ```diff lang=ts
  +  if (instanceInfo.position[0] < -1.0 - triangleSize) {
  +    instanceInfo.position[0] = 1.0 + triangleSize;
  +  }
  +  if (instanceInfo.position[1] < -1.0 - triangleSize) {
  +    instanceInfo.position[1] = 1.0 + triangleSize;
  +  }
  ```
</Aside>

The final step of our mini-rework is to update the initialization of the triangles to include velocity.

```diff lang=ts
  function randomizeTriangles() {
    const positions = [];
    for (let i = 0; i < triangleAmount; i++) {
-    const x = Math.random() * 2 - 1;
-    const y = Math.random() * 2 - 1;
-    const rotation = Math.random() * Math.PI * 2;
-    positions.push({ x, y, rotation });
+    const position = [
+      Math.random() * 2 - 1,
+      Math.random() * 2 - 1
+    ] as [
+      number,
+      number,
+    ];
+    const velocity = [
+      Math.random() * 0.01 - 0.005,
+      Math.random() * 0.01 - 0.005,
+    ] as [number, number];
+      positions.push({ position, velocity });
    }
    runtime.writeBuffer(trianglePosBuffers[0], positions);
    runtime.writeBuffer(trianglePosBuffers[1], positions);
  }
```

<LinkCard
  title="Run it in the playground!"
  href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoEIFcYwgOwBoV0BRAGwFMRL8ZiCAxKZGuAXzgDMoIQ4A5AAEYATzCUA5mCwB6SgA9WYKgFo8EcgGtgMAQG4AUKEixEcMRLgB1SQGdy2Ll0pQAqneSTKxAEZZgchhgIjgAYyhKZBhKACUsOlAfOAB3e3IObl5%2BAUspGQNjcGh4JGQoFlEAeS5iOxgoLDD6OAA3SjCAJi5Mnj5BPOk5VGjkQsMwgnq4RsS2AF4UFORdcMjouITgmgAKAEojSfxp1EpW4DDKOEXZ7coAOlPzy6MJqfgw5HxW5DtrpZW8DQqAo1FoMB2Ak%2B31%2BAmIZTsEmasWiwAgAC44ABGDgHN7HD4EGIKeCLaE-Oz3bwwADCRMUEIEKUoviGAj2KD%2BAHEAApuGlfCl0ugMw7vOBgSJ2cGopjQEDRf74ZDnSTRaBUmRUygwHmRFwVSioAUwuyMeXRfavI7EmD3I5cYCSLCRHYIQxwOBPC4%2BD3cC0wTGSyjSuiy-DmqAK%2Bh%2B5DkMAAC2QAFkIKdMQJgyAsEFgCpgEa4YZ2HjDMDsLgCJCUfhUHxgAAvShwmZfOsgRuUAAqUGAX0kVDspaO0waffwA8oAGVO-8AAz3TpigkWXv9qgANVcxP%2BaQcfvu-mcrh25UqNR27S6tTgAGY9sQANp%2Bz2Phdz4hj9fTzsAXUIL5wI%2B6hrhOVAzk2xAgeOk4QZQ-6AY%2BX5gT%2BkFwNB35wQhnq-nsB4ACRxuQEApFusCKJC7TkQo7LWuKyGTgAgiAEBbP8WJzsuo6gZOPIQHYAAioz-GeyDVFwOx%2BvUjTNG6gGQHYuhovgmJXt0AGep67TEWEuiiKpHTqX6JYaauMFUMxrF0ABeJ5HAPbmZQfGCcJix5BAPQMVQzlCTAyB0SuXlOfxTgGn8iyMRUYn3H0IBunAVATjACaYp0HDEPs1wAHyIH6kQwC6%2BCpOkh5YMeUA7EFPmjHs9yEeQxEpG4%2BDAFw8r7HVREkcmODIL44F4Cw3hWsWw7imAKxQOFQF%2BkhPHeSFZVhW%2Bv73L8zWte1D5md%2Bzmha4diPliq2-D1fn9dOg1eJQ%2BzYUBVWLeVh3HWtdgbW1Ub7J%2B83BXY%2B1TStr1nX1A3QNdt0Ab%2BnIzZ6tgOP9HjXQAPA5u38b5yDEAICSbVGAhZaZcOOEtriI94KM-dVflY9m51UAA%2BvUYPePjkOPr%2BAXTOsqBTsRpLFQ49wOBAMBI0TCOeOTqMoVTmOCDjH0gPjWUjSO8ApL2MS8yL1x%2Bnu5BC3zYvpBLyPS7x6OjDTvUXYzV0s1lKullwCTNMpra1vWTbm4OmXup6asSvxSlTP87NGJ6H1wDsVDwMA876HA8dIztKGWVsifAAA1FnHL%2B5pgcKSHRWLI%2BybRAm9wsJ7cUcgAVHAaWqNixDl8lVdtnwmUN032JQ78MOaZ6%2BBYCAviuKZQ8j2PE%2BARzgGB9pEC6WIYeAZ6beV9X7bd3A744s375zgArJPmmbx3Ne7-v6F7-cc4n2f-d-I%2B0-j1AxBv6489D0XwRTPcGQdgEzxT-spYgS8V6iFxBHDgeUthJHuBrXQlB-qVUpo9Zac5-xB0Uv-Y4eJPS3EQcgmIaCHp-RJgDY6xAwFTDxOwQw%2BIuYiw2LuEqXB8AAANLwGWvMQb8mIuC3k6ByVQOU1I9HzrHXB-w1KSSHpee4Cg4AN0mHYU8KE9hiOjq0e40CG6KXwJoyc2iz5KJUYYkIJiqDaLgFnXR%2BjVHhH4jYyg2i-SEJmDqQquCjDsC4ZzeA1JYisPwcwPgW4dJ6XYYLThPDIF6T4d0MROVhFpXzvlXxqhRj4E6JeSg0SxDKIgYU5eel9EMMCUwwOkRayuB5HmQpIQQxhw-H3e4CowA7B2MAVACgOTzCyvAuYDwFRaDiLQU4UBGkSHIC0uSQ8qLEkxPnIekx0wC3IFw9eCUdRJwJF8S4ABJfAbV-j4QQBNYAAM%2BkKF-Ctdgj5Ln%2BECMEfA9wQj1COZQU5pwFDsB-kPPZ8BeB%2BRiKgC5CAwUbHYAo4FnpLlBTIsSV6KKKJ7HYGfIelyQlhOUhEkAUTyliDhV8vy%2BATlnIgPcRJYgHy7NLAimRHkuDSn5uSn5py2qAODvg14zL9kKTkR0AALBJGFEL7FwFZey4g75iBYnvl4oeMieBeDcBuf4OxJVGmlZInYSKfpwSxXAI1jkTV2NkG0QyElzWYU7JwHuyrYGei4dimVOAZCBlygi18rzcwfLofgX8GYFJFj9VkDVG5km1F2ViwCCah7qskDQOgqzdkbMoJifWOzBWEmIlAHEiwry3h2FiAAnAANnvnAa1nRj7H3voqh%2Btb62NubY3Dtc461dqbXOFVmkZGTELWlEtHQy2dArW2vtnasRYlFTOht-biCdFFe%2BXty6XVMPzV6YA0xFiJUkMlHYKbNW33kQuU%2Bd9j7aIFcC4dmhoD-A7AoHYI7oBYmIB%2BqAnRiCoH3TAJlwKslQCKleUV76n0f2xNuoe7rdl%2BSgNSTEz5I1rL9YraIQYpQynCQGD1nok3ArukRs%2BkpQBKXaBmhFeBIDEUkPpAYP1VDzPqBGzSxGTKGDGiuSY4AcBOSafM-ArTS7tJel0npdzBnDKIQgmgnTkATLpAJmIszmmicWQXNM2atl5qHfskI-yoUBveVSYivg4ynNaMvcMxzUDsGUa6to5QDnfMpb86lULubaxgE84ziggWehkUFOCUKwuOvvZ6Vq0dOWee5TS4NK04A5SVT2hxkWmx512fFqlPLkvYP%2BKodLt8suUBc4woesXemHIS9S3leDlJHShml2tmXjWdhywivLXmCt8ua8dYrpXm7lcq4BGrvXEuNeLillOJXa2jc69l31wKpsNcK1DRYpWOsWs7ON6rPRasefy0lgbBAWtwHmyN1OsEuureq3V07M38GXe2%2B1274F9uJp3Zpdb-WmsEHsYsf7NK6WiGi2ahApDpx8wC-U%2B5-xQewIM0PJBugQG%2Bb5rQyah07kPOwXhBF6OT0w78zjm5eP%2BkPOOgyojDLSzby9t2H6Gi8QyLOLQf4XA4zSiMEwFguxMpDNW5zkucAACEYvYH8e9UJuZLTDpi7gAAfj3nATEL1FAdEE9pz0KRoBaEkLwLAYA7CoaCunOgd0SywLqdMjTImQyPmV2rnEmJsH3G12EXXGGf2MVwMgMICY00wHN4PIeGGlkFhSJiG0DJtS0hdHUmAXYGQuhurVCIUQYgbhj19XZAcqDlA3HGLAem3zyqr3vUjD6IBoCqGADMYRi9QA4wipmkRG8Zk782D1xGcJn2WYoOkWxMS3jPr10f6bPuUCtzGen97iGKa4OQLAwCRq28MEAA"
  target="_blank"
/>

Well, that was a lot of changes! Now, all that's left to do is to manipulate the velocity of our triangles so they move in a flocking-like behavior. Boids work by following three simple rules:

- Separation: Boids will try to avoid each other by steering away from their neighbors.
- Alignment: Boids will try to align their velocity with their neighbors.
- Cohesion: Boids will try to move towards the center of mass of their neighbors.

Let's prepare a buffer that will store the parameters for each of these rules.

```ts
const parametesBuffer = wgsl
  .buffer(
    struct({
      separationDistance: f32,
      separationStrength: f32,
      alignmentDistance: f32,
      alignmentStrength: f32,
      cohesionDistance: f32,
      cohesionStrength: f32,
    }),
    {
      separationDistance: 0.09,
      separationStrength: 0.005,
      alignmentDistance: 0.3,
      alignmentStrength: 0.005,
      cohesionDistance: 0.3,
      cohesionStrength: 0.001,
    },
  )
  .$allowReadonlyStorage();
```

Now, for the implementation of the rules:
<Aside type="caution">
  The following snippets contain the logic for the rules. They are separated for better readability. Later, we will combine them into a single code block and add them to the shader.
</Aside>

<Steps>

1. Add the logic for separation:

   ```ts
   const separationCode = wgsl`
    var separation = vec2(0.0, 0.0);

    for (var i = 0u; i < ${triangleAmount}; i = i + 1) {
      if (i == index) {
        continue;
      }
      var other = ${readSlot}[i];
      var dist = distance(instanceInfo.position, other.position);
      if (dist < params.separationDistance) {
        separation += instanceInfo.position - other.position;
      }
    };

    instanceInfo.velocity += separation * params.separationStrength;
   `;
   ```
   To implement the separation rule, we create a vector to store the combined separation forces.
   We then iterate over all the triangles in the buffer and calculate the distance between the current triangle and the other triangles.
   If the distance is less than the separation distance, we add the vector pointing away from the other triangle to the separation vector.

2. Add the logic for alignment:

   ```ts
   const alignmentCode = wgsl`
    var alignment = vec2(0.0, 0.0);
    var alignmentCount = 0u;

    for (var i = 0u; i < ${triangleAmount}; i = i + 1) {
      if (i == index) {
        continue;
      }
      var other = ${readSlot}[i];
      var dist = distance(instanceInfo.position, other.position);
      if (dist < params.alignmentDistance) {
        alignment += other.velocity;
        alignmentCount++;
      }
    };

    if (alignmentCount > 0u) {
      alignment = alignment / f32(alignmentCount);
    }

    instanceInfo.velocity += alignment * params.alignmentStrength;
   `;
   ```
   Alignment is implemented similarly to separation.
   We create a vector to store the combined alignment forces, which are just the velocities of the other triangles.
   This time, we also keep track of the number of triangles within the alignment distance. This count is used to normalize the alignment vector.

3. Add the logic for cohesion:

   ```ts
   const cohesionCode = wgsl`
    var cohesion = vec2(0.0, 0.0);
    var cohesionCount = 0u;

    for (var i = 0u; i < ${triangleAmount}; i = i + 1) {
      if (i == index) {
        continue;
      }
      var other = ${readSlot}[i];
      var dist = distance(instanceInfo.position, other.position);
      if (dist < params.cohesionDistance) {
        cohesion += other.position;
        cohesionCount++;
      }
    };

    if (cohesionCount > 0u) {
      cohesion = (cohesion / f32(cohesionCount)) - instanceInfo.position;
    }

    instanceInfo.velocity += cohesion * params.cohesionStrength;
   `;
   ```
   Cohesion essentially involves calculating the center of mass of the other triangles and moving towards it.
   After summing the positions of the triangles within the cohesion distance, we normalize the vector and subtract the current position to determine the direction to move towards.

4. Combine the rules into a single code block and normalize the velocity of the triangles:

   ```ts
   const boidsCode = wgsl`
    var separation = vec2(0.0, 0.0);
    var alignment = vec2(0.0, 0.0);
    var alignmentCount = 0u;
    var cohesion = vec2(0.0, 0.0);
    var cohesionCount = 0u;
    for (var i = 0u; i < ${triangleAmount}; i = i + 1) {
      if (i == index) {
        continue;
      }
      var other = ${readSlot}[i];
      var dist = distance(instanceInfo.position, other.position);
      if (dist < params.separationDistance) {
        separation += instanceInfo.position - other.position;
      }
      if (dist < params.alignmentDistance) {
        alignment += other.velocity;
        alignmentCount++;
      }
      if (dist < params.cohesionDistance) {
        cohesion += other.position;
        cohesionCount++;
      }
    };

    if (alignmentCount > 0u) {
      alignment = alignment / f32(alignmentCount);
    }

    if (cohesionCount > 0u) {
      cohesion = (cohesion / f32(cohesionCount)) - instanceInfo.position;
    }

    instanceInfo.velocity += (separation * params.separationStrength) + (alignment * params.alignmentStrength) + (cohesion * params.cohesionStrength);
    instanceInfo.velocity = normalize(instanceInfo.velocity) * clamp(length(instanceInfo.velocity), 0.0, 0.01);
   `;
   ```
   This code block combines the separation, alignment, and cohesion rules into a single block.

</Steps>

<Aside type="tip">
  The boids logic is the most subjective part of the implementation. Feel free to experiment with the parameters and rules to achieve different flocking behaviors.
</Aside>

To properly observe the flocking behavior, we will increase the number of triangles to 500 and reduce their size:

```ts
const triangleSize = 0.04;
const triangleVertex = wgsl
  .buffer(arrayOf(vec2f, 3), [
    [0.0, triangleSize],
    [-triangleSize / 2, -triangleSize / 2],
    [triangleSize / 2, -triangleSize / 2],
  ])
  .$allowVertex('vertex');

const triangleAmount = 500;
```

## Final result

That's it! We've implemented the boids flocking algorithm in WebGPU. Let's see how our code looks and compare it to WebGPU:

<Tabs>
  <TabItem label="TypeGPU">
    <details>
      <summary>Click to see the full code</summary>
      ```ts
      import {
        addButton,
        addElement,
        addParameter,
        onFrame,
      } from '@typegpu/example-toolkit';
      import { type WgslBufferUsage, builtin, createRuntime, wgsl } from 'typegpu';
      import { arrayOf, struct, vec2f, f32 } from 'typegpu/data';

      const runtime = await createRuntime();
      const device = runtime.device;

      const canvas = await addElement('canvas', { aspectRatio: 1 });
      const context = canvas.getContext('webgpu') as GPUCanvasContext;
      const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

      context.configure({
        device,
        format: presentationFormat,
        alphaMode: 'premultiplied',
      });

      addButton('Randomize', randomizeTriangles);

      const parametesBuffer = wgsl
        .buffer(
          struct({
            separationDistance: f32,
            separationStrength: f32,
            alignmentDistance: f32,
            alignmentStrength: f32,
            cohesionDistance: f32,
            cohesionStrength: f32,
          }),
          {
            separationDistance: 0.09,
            separationStrength: 0.005,
            alignmentDistance: 0.3,
            alignmentStrength: 0.005,
            cohesionDistance: 0.3,
            cohesionStrength: 0.001,
          },
        )
        .$allowReadonlyStorage();

      const triangleSize = 0.04;
      const triangleVertex = wgsl
        .buffer(arrayOf(vec2f, 3), [
          [0.0, triangleSize],
          [-triangleSize / 2, -triangleSize / 2],
          [triangleSize / 2, -triangleSize / 2],
        ])
        .$allowVertex('vertex');

      const triangleAmount = 500;
      const trianglePosData = arrayOf(
        struct({
          position: vec2f,
          velocity: vec2f,
        }),
        triangleAmount,
      );
      type TrianglePosData = typeof trianglePosData;

      const trianglePosBuffers = Array.from({ length: 2 }, () => {
        return wgsl.buffer(trianglePosData).$allowUniform().$allowMutableStorage();
      });

      const pairs = [
        [trianglePosBuffers[0].asUniform(), trianglePosBuffers[1].asMutableStorage()],
        [trianglePosBuffers[1].asUniform(), trianglePosBuffers[0].asMutableStorage()],
      ] as [
        WgslBufferUsage<TrianglePosData, 'uniform'>,
        WgslBufferUsage<TrianglePosData, 'mutable_storage'>,
      ][];

      const readSlot = wgsl.slot<WgslBufferUsage<TrianglePosData, 'uniform'>>();
      const writeSlot =
        wgsl.slot<WgslBufferUsage<TrianglePosData, 'mutable_storage'>>();

      function randomizeTriangles() {
        const positions = [];
        for (let i = 0; i < triangleAmount; i++) {
          const position = [Math.random() * 2 - 1, Math.random() * 2 - 1] as [
            number,
            number,
          ];
          const velocity = [
            Math.random() * 0.1 - 0.05,
            Math.random() * 0.1 - 0.05,
          ] as [number, number];
          positions.push({ position, velocity });
        }
        runtime.writeBuffer(trianglePosBuffers[0], positions);
        runtime.writeBuffer(trianglePosBuffers[1], positions);
      }

      const rotate = wgsl.fn`(v: vec2f, angle: f32) -> vec2f {
        let pos = vec2(
          (v.x * cos(angle)) - (v.y * sin(angle)),
          (v.x * sin(angle)) + (v.y * cos(angle))
        );
        return pos;
      }`;

      const getRotationFromVelocity = wgsl.fn`(velocity: vec2f) -> f32 {
        return -atan2(velocity.x, velocity.y);
      }`;

      const renderPipelines = [0, 1].map((idx) =>
        runtime.makeRenderPipeline({
          vertex: {
            code: wgsl`
            let instanceInfo = ${pairs[idx][0]}[${builtin.instanceIndex}];
            let rotated = ${rotate}(
              ${triangleVertex.asVertex()},
              ${getRotationFromVelocity}(instanceInfo.velocity),
            );

            let offset = instanceInfo.position;

            let pos = vec4f(rotated + offset, 0.0, 1.0);
            let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
          `,
            output: {
              [builtin.position]: 'pos',
              fragUV: vec2f,
            },
          },
          fragment: {
            code: wgsl`
            let color1 = vec3(196.0 / 255.0, 100.0 / 255.0, 255.0 / 255.0);
            let color2 = vec3(29.0 / 255.0, 114.0 / 255.0, 240.0 / 255.0);

            let dist = length(fragUV - vec2(0.5, 0.5));

            let color = mix(color1, color2, dist);

            return vec4(color, 1.0);
          `,
            target: [
              {
                format: presentationFormat,
              },
            ],
          },
          primitive: {
            topology: 'triangle-list',
          },
        }),
      );

      const computePipelines = [0, 1].map((idx) =>
        runtime.makeComputePipeline({
          code: wgsl`
          let index = ${builtin.globalInvocationId}.x;
          var instanceInfo = ${readSlot}[index];
          let params = ${parametesBuffer.asReadonlyStorage()};

          var separation = vec2(0.0, 0.0);
          var alignment = vec2(0.0, 0.0);
          var alignmentCount = 0u;
          var cohesion = vec2(0.0, 0.0);
          var cohesionCount = 0u;
          for (var i = 0u; i < ${triangleAmount}; i = i + 1) {
            if (i == index) {
              continue;
            }
            var other = ${readSlot}[i];
            var dist = distance(instanceInfo.position, other.position);
            if (dist < params.separationDistance) {
              separation += instanceInfo.position - other.position;
            }
            if (dist < params.alignmentDistance) {
              alignment += other.velocity;
              alignmentCount++;
            }
            if (dist < params.cohesionDistance) {
              cohesion += other.position;
              cohesionCount++;
            }
          };

          if (alignmentCount > 0u) {
            alignment = alignment / f32(alignmentCount);
          }

          if (cohesionCount > 0u) {
            cohesion = (cohesion / f32(cohesionCount)) - instanceInfo.position;
          }

          instanceInfo.velocity += (separation * params.separationStrength) + (alignment * params.alignmentStrength) + (cohesion * params.cohesionStrength);
          instanceInfo.velocity = normalize(instanceInfo.velocity) * clamp(length(instanceInfo.velocity), 0.0, 0.01);

          let triangleSize = ${triangleSize};
          if (instanceInfo.position[0] > 1.0 + triangleSize) {
            instanceInfo.position[0] = -1.0 - triangleSize;
          }
          if (instanceInfo.position[1] > 1.0 + triangleSize) {
            instanceInfo.position[1] = -1.0 - triangleSize;
          }
          if (instanceInfo.position[0] < -1.0 - triangleSize) {
            instanceInfo.position[0] = 1.0 + triangleSize;
          }
          if (instanceInfo.position[1] < -1.0 - triangleSize) {
            instanceInfo.position[1] = 1.0 + triangleSize;
          }

          instanceInfo.position += instanceInfo.velocity;

          ${writeSlot}[index] = instanceInfo;
        `
            .with(readSlot, pairs[idx][0])
            .with(writeSlot, pairs[idx][1]),
        }),
      );

      randomizeTriangles();
      let even = false;
      onFrame(() => {
        even = !even;
        computePipelines[even ? 0 : 1].execute({
          workgroups: [triangleAmount],
        });
        renderPipelines[even ? 1 : 0].execute({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              clearValue: [0, 0, 0, 0],
              loadOp: 'clear',
              storeOp: 'store',
            },
          ],
          vertexCount: 3,
          instanceCount: triangleAmount,
        });

        runtime.flush();
      });
      ```
    </details>
    <LinkCard
      title="Run it in the playground!"
      href="/examples#example=playground__JYWwDg9gTgLgBAbwFBzgQwCYYEIFcYwQB2ANCulgKIA2ApiLUTGaphgAppRoMy1Qs4xAGLcGZAL5wAZlAgg4AcgACMAJ5haAczC4A9LQAePMHQC0hCNQDWwGIoDcSUJFiI46zXADqWgM7UeNLS-ACqfmhatCRwAEa4wNQwwKRwAMZQtGh8AEq4TKDRcADu-tRwUrLySp7auo7O4NDwCOhQ3GoA8tIxfjBQuGnMcAButGkATD0yAMwTFTJyCoq1OvoY2WgNSGnEfXADBQxwALzoxWh26ZnZtHlHtAAUAJROu0T7GLQjwGm0pwd8skGAA6L4-P5OHZ7eBpNBEEZoPwAtAXK5sGj0RgwR6KOEIpGKGKtJGaIY5bLACAALjgAEYKq9oR9YcQ%2BIZ4Gd8Yi-CCojAAMJsow4xTFWixNaKZ7oZEAcXYoQF8J5QqYIreMLgYEyfmxlJE0BA2QBRDQPy02WgfN0fNoMHYmRC7VoGGVBL8wiN2ReUPe7JgIPe0mAWlwmUeyFQ4N%2B0XI0m9MFpOtoeqYBqIXqgxuY5DQ1DAAAs0ABZCBfWmKFMgXBJYCmYCuolICRMpBsPAEYi4ilEDDyYAAL1oRIO8P7ICHtAAKlBgPCtHQ-G33vswFwePbU0FnQDSgFyCD4sF%2BI9yKg%2BgMhpHz6g4Hr19xksQACLAPrwv606RzQR3%2B%2B0I%2BGYAMr9IwWgwIW36-rerDUKGRAMEwb4fkQX6zBMf53vmCFITAoGZEQEFQRhWGoLshaplSRAoTAn60NBmGwekECUX41EEeBkGMVhrZYVG-4AUBz40e%2BdFoQxcAAAwglJACcZFCRuImcUR3HSbJUkAKyKThWiIditH0bSMkzLp8H6XhqnESZmk6cxFFUa%2BYnGRpZkOaxTlENZ6kyVJUl0rxgjPIeAAk%2BbUBAxQ5Fk-ZENQaigdAkRPCuWr9PORF0MBU4An5AAsmosh4c4LnQABq-DsnuZSHsezqPFwHTdI8YyTNMMzPDEADat7dX5MQZWVtA5cOAC6WHdRYpVZSNuV6HAmFwNNmWLnNw5wAtEwTX1Q2zaN-xbTEK3DQdm2LTtqBjSFqAguF1CRcUlWwEYuJjC9hjSn66UzWtACCIAQECAJaf5RX7Hta3sBAfgvpsKLtGgXTSGeF79IMOICagkDsSJtJtVMWFjJFaR2Go%2BPjIT5B8eQkN0ADQNMGQTK1HAs6rXQ0Ow-DZy1BA0glRztBc3DdHfcVdPCzDO78MiZx-YjagglUICRnAdBqSR8wSDELynAAfIg5CZDA4ZECUZRHrgJ5QI8ksi5szx3RFUWhEQwAJtmLzOw9UUlvgaCxNlhDcFEvotmlxXrsAUBy3AvWoN19vS9bzp%2BP1Y0gkibse0aLyDb9nMpzb6d0pnSL%2B3RQcjSHKUvJd8fJ34Mux91ZdZ34Oee6rXWC8NXMt%2BnUnl34leB8HyVh88O1jbK8fkL4AQt%2BEKUADzs-3MOi2gMSKPkufZoo%2BuCIvgSp2EERROvhdS9zdG7zWVd0AA%2Bn0k8jsfSBjd1Y3i-sNwYGApFTkFsAgggCBAGAq9T7L0vrQa%2BQsHb3yUPvbuR99bh1XPAYoc4%2BBAMgaccg%2B5qDgOAdAsosC14b1mkgneShH7j1oK-WuUR0HhyQNIfIQxqJjj7AOYc1C1p%2BD1gJLB2oYZ2GonHH%2BThUCezgI8Og8BgB5QcHAFRq8%2B6zQZkCNRwAADU%2BiZRYxYlHCRIkATdRLNkQsIJuB8J7nAAAVItZa9IYjWMgnY8c8g9YuPmGYeks8kTz0EnAIguAQCxH4IpCJUSYm3l-reMRxMICk3UJY5injbH2InH4jSDJAl%2BXsmE7J3iHH5JkoUjS2ksLBORN1OJ0SBDhMic0pJ-4caSL2CCXQfhCxqy6SJGIqT0lqEZLIioxsgSFBBDguwtAW52xvgPc%2Brdh4xCGVIpkqBDjAloHM3Biy1nLMQcXNObcJriNxtspwEgkDMn-pA24NUwHSCIAAA1ahTdqMRhqMRlGYQ2BMBYCSUdcgEBNUZ3laiCQwziWLCOGs8QFCiRggnGS49iRBGqzRRVhWF8KsUpFxWtFFcB9FooxQi3YSK8U3TgDsg49ozbXLuR8v%2B8B%2BQ5GeSJUQ8hKokzJq8kh7yvmjLJj8qYgLDY-nmAJE2rKzCbCIBMVqtAhXqDhSMjVaSyYYqZBIDlDyxGES%2BFAdg9YNUpFTJYqSMR27GjAI8R4wAMCGBlCcfW0yHggmNNYO4jBzWWs0PBIgTwTHvXZLSEx5FyySWIR85i4KUioT%2BAASSIAmAEoUEDR1bm6ww39h4SG6rm%2BIiRkhEBBKm8SGa%2BxGAkB0wS4K5B0T4BgHNCA223AkNCsJubJbPXZB3Ydr1ng62YqgXN3LeXUX5SAQVer1B9trfRTNCYQQSvUF1ZibYwngv5tIPUIC10SQ3RAXp5jqJQgPfaCFZw2r5RRj2jtFKhDBBPTEAa9JZJMv-OC2QkRQjlQBI8V9rp30gseIOm%2BB0dZwFg0LeD5KFrQaQ6dKcUh-F-smagD5ikgYwF0EmI2YTE4VrrNWrZxAxqVhxs2cjixgPlSlT0Zik7-ycbvEBrQeEY0eQrKA6gSa72skilABkj7xgzEeHSOSAA2WS50JhaS0rJB1-llNbTUxpxaumpIqYM-%2Bu84LdgSfmNJtIsmJhyW0-p9T9r6R0nyvZ1TjmYgTHyn5Izjn90tvvRgMSAINbEUeLxkDbioUyR0hpLSKLb0BfE9AAEk5DCPHM9AQKLELMxCC30fz-5FVQHNk%2BjLVhoAOtw7eAjzE6JQH5LSBO5HY2CW7tkZMup9R8sTIpVA3H-wN361hHUoBJFjAE2EwgkBIpaHJjUG%2BZh4J9EY3ebjNNI77F2OAfAwsrVhttWcfqDrM5OpdYWz13rdkzNBP62gQodt8BDda8NN5-y7CE4m28KaG3wrOOWhIVG%2BSRViPmTNIw0kZnTRgCQcK8OjC4Oolk66s0QC7QA-BMBS0pC%2BEW%2BH4KgIgDjrmwnW5m5rI7jFTAxAEpJVDqlCQiXUCIigEpJ8PCrNqp-X5EzLP0AWQMkwSFlNHjc%2Bq-%2BPnelBeCkZiAqSuB4d88cuxYgwvJii70zzxXiPlfUSFMDM48v4fyNaojlRhuFfqLgJojD2jAZAkZ1bs4KjKV0mMcxD2CjzfO9%2B%2B7pj-oUi4FoPD-rzE%2BeQMoqz-73bYqY%2Bx82iXiP8sgOT-RV1yPz2o6vTc4gMQI-8Gz90ogJnUCe8eMn632oNxE-AYBZS1EjIST9%2BRh89fVf6J92m2gF7C8WMCfnqAveb0cY9wLcvwXNGE95FLvCje-jN7CTP7EFKzgD63bqsZIfsIC7wvrpghit-3LCWXivk-q%2B8l185LvC-BKX-Nh3oQkEC80aIFvuNbE9ey4PyPrjTP1Fj6XyYD33gENnlxvzglwmXzOEAPgAWjlUah32xGAJM3uVvDLzv2ALgFANwHAJYg-1VzOHK3wPNjgLmCIK8mQNRTPXrU3Rf3h1QP-GoO7yz23XGQf0eFb3Z1VxcSn1r2Eg4jAk1hlEpQQMgKFx4PPyzkQKYB8kLGEIUTvwRV4Lv1kJMyYJ71YNNG9HgmHHTy7w0I3zJhlBcTSGoBMEUS4gGXUJYMMJ3W-U11kjdz-3BUljOmj1cKw3hzL2sNoOvWIAziwN-UM0pQ8OHFwJ8MvRfwCLODMDpGU0CVCOD1vCPzvG8IzxoMiL8KIEuUCLiOCK0TWgOnCPSOYN8Jz2yLLgBFiPiIKOyinHoLQLHwiKH38OHkr2qMMwSLgynGKP0KzyiLaLODyPfUSIaMYKaJKJ7yiMqM0Q6LcUSN6LrVKMyPKJyKGOUxCO6OHAaLQMmP6KyJXyRz6M3VYL-1zXmTwWAWx1%2B1nk7yWIvUmVE0EjmTsAGQx2AU2UuALXdWLWumYheMgkeAuJGg%2BKrxjnTkLW-jLl3X613TbFyX4RnBvmESZHBW%2BEYABGkHzD1CcBEDECeD1i9TIzgHRPNjOAAEJSTJltsSM9tQ0bV05SS4AAB%2BaSOAWkduIwcYXbN7O8YoaAawLQOQXAMAPwJrSWHRJgBuVsSZM1fgZ7A7RksYc2VkhkEyTOLktIHkkxTLKAP6AgNANIQsPCMU0JQSVrZnRsYoWkf0EUO0QUcMQiGAacEUcMVKIMG4PgcqK0-OKddIOgLgcqfMIPJrJzMM79IbFtCATAToMASsUwrIKAVbMJN%2BTIWMysVMkcRSAbOASMqNIwYA2kdyRgkows2o2gSU3MWExLPZWZaQagXAfpcOGUk1LUCAMAESOOASTgjMOfSSPyBScgHslSQQmyGpWpPMaQmAPs2yYs-nMQ-CUc3yOyQQO-GctyVczyFXbyJckiPyAKSQKEThNCCxNAMAUwLoDsqRERH1fZQ5BZJZUnPgcnG2PPK8vYQ1B5NgTgfEvgW2cgRQYCOvLg82WiVbExFISRfMWkdszsvgtvUSLvLCScIgWye1W8Y0QwWyEpO8PoQCNCg86mQQVqS7Yk1AWCqReCkCvsyFeHM8i82Mzs8OYbJANsb86vLcf81AQC4CjMOAAicC3YqC6gGC98j4KikCXc5ClINC5CtALCgpLCPCuM8cwKIi8gEig2MioQMS3kYcgQwiYiWi28eihKRi68plSdNirAH8zcP86FRQP6AXOAMCwQCC92ZIaCnSuCmAvs6S1CmpOShSmLJSvgFS-ctSli1ATSokkxCinpXylyCSYy-8Uyy8piyy5mKEdi3808ACpyhCfi-oQSks4S0Snyqc2Q-y2SjC%2BS2ySK3CsKgihq7jGKw2OK3SqQhc2QlK7Cc8sy3S5iioLKr8myji%2BygCoUYglysSEq1Ijy%2BcES7yyitcpKv4aqwK2q4KkEHCtGfC1SwQVqkYUijquC1arvXq1gfq9KiyyZKy7Ksa3KripQKaryIqpMtyoSzypa%2BK8SlQqSjCmSza-8TC%2Bq0K-aiKw64i46rS06larcgyywy69Aa68yvYIa%2B6pAIAA"
      target="_blank"
    />
  </TabItem>
  <TabItem label="WebGPU">
    <details>
      <summary>Click to see the full code</summary>
      ```ts
      import {
        addButton,
        addElement,
        onFrame,
        addParameter,
      } from '@typegpu/example-toolkit';

      const adapter = await navigator.gpu?.requestAdapter();
      const device = await adapter?.requestDevice();

      if (!device) {
        throw new Error('Failed to acquire a device');
      }

      const canvas = await addElement('canvas', { aspectRatio: 1 });
      const context = canvas.getContext('webgpu') as GPUCanvasContext;
      const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

      context.configure({
        device,
        format: presentationFormat,
        alphaMode: 'premultiplied',
      });

      addButton('Randomize', randomizeTriangles);

      const parametersBuffer = device.createBuffer({
        size: 6 * 4,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        mappedAtCreation: true,
      });
      new Float32Array(parametersBuffer.getMappedRange()).set([
        0.09, 0.005, 0.3, 0.005, 0.3, 0.001,
      ]);
      parametersBuffer.unmap();

      const triangleSize = 0.04;
      const triangleVertexData = new Float32Array([
        0.0,
        triangleSize,
        -triangleSize / 2,
        -triangleSize / 2,
        triangleSize / 2,
        -triangleSize / 2,
      ]);

      const triangleAmount = 500;
      const trianglePosBuffers = Array.from({ length: 2 }, () =>
        device.createBuffer({
          size: triangleAmount * 8 * 2,
          usage:
            GPUBufferUsage.UNIFORM | GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
        }),
      );

      const triangleVertexBuffer = device.createBuffer({
        size: triangleVertexData.byteLength,
        usage: GPUBufferUsage.VERTEX,
        mappedAtCreation: true,
      });
      new Float32Array(triangleVertexBuffer.getMappedRange()).set(triangleVertexData);
      triangleVertexBuffer.unmap();

      function randomizeTriangles() {
        if (!device) {
          return;
        }
        const data = new Float32Array(triangleAmount * 4);
        for (let i = 0; i < triangleAmount; i++) {
          data[i * 4] = Math.random() * 2 - 1;
          data[i * 4 + 1] = Math.random() * 2 - 1;
          data[i * 4 + 2] = Math.random() * 0.1 - 0.05;
          data[i * 4 + 3] = Math.random() * 0.1 - 0.05;
        }
        device.queue.writeBuffer(trianglePosBuffers[0], 0, data.buffer);
        device.queue.writeBuffer(trianglePosBuffers[1], 0, data.buffer);
      }

      const wgslCode = `
        fn rotate(v: vec2f, angle: f32) -> vec2f {
          let pos = vec2(
            (v.x * cos(angle)) - (v.y * sin(angle)),
            (v.x * sin(angle)) + (v.y * cos(angle))
          );
          return pos;
        };

        fn getRotationFromVelocity(velocity: vec2f) -> f32 {
          return -atan2(velocity.x, velocity.y);
        };

        struct TriangleData {
          position : vec2f,
          velocity : vec2f,
        };

        struct VertexOutput {
          @builtin(position) position : vec4f,
          @location(1) fragUV : vec2f,
        };

        @binding(0) @group(0) var<uniform> trianglePos : array<TriangleData, ${triangleAmount}>;

        @vertex
        fn mainVert(@builtin(instance_index) ii: u32 ,@location(0) v: vec2f) -> VertexOutput {
          let instanceInfo = trianglePos[ii];

          let rotated = rotate(v, getRotationFromVelocity(instanceInfo.velocity));
          let offset = instanceInfo.position;

          let pos = vec4(rotated + offset, 0.0, 1.0);
          let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
          return VertexOutput(pos, fragUV);
        }

        @fragment
        fn mainFrag(@location(1) fragUV : vec2f) -> @location(0) vec4f {
          let color1 = vec3(196.0 / 255.0, 100.0 / 255.0, 255.0 / 255.0);
          let color2 = vec3(29.0 / 255.0, 114.0 / 255.0, 240.0 / 255.0);

          let dist = length(fragUV - vec2(0.5, 0.5));

          let color = mix(color1, color2, dist);

          return vec4(color, 1.0);
        }
      `;

      const wgslCodeCompute = `
        struct TriangleData {
          position : vec2f,
          velocity : vec2f,
        };

        struct Parameters {
          separation_distance : f32,
          separation_strength : f32,
          alignment_distance : f32,
          alignment_strength : f32,
          cohesion_distance : f32,
          cohesion_strength : f32,
        };

        @binding(0) @group(0) var<uniform> currentTrianglePos : array<TriangleData, ${triangleAmount}>;
        @binding(1) @group(0) var<storage, read_write> nextTrianglePos : array<TriangleData>;
        @binding(2) @group(0) var<storage> params : Parameters;

        @compute @workgroup_size(1)
        fn mainCompute(@builtin(global_invocation_id) gid: vec3u) {
          let index = gid.x;
          var instanceInfo = currentTrianglePos[index];

          var separation = vec2(0.0, 0.0);
          var alignment = vec2(0.0, 0.0);
          var alignmentCount = 0u;
          var cohesion = vec2(0.0, 0.0);
          var cohesionCount = 0u;
          for (var i = 0u; i < ${triangleAmount}; i = i + 1) {
            if (i == index) {
              continue;
            }
            var other = currentTrianglePos[i];
            var dist = distance(instanceInfo.position, other.position);
            if (dist < params.separation_distance) {
              separation += instanceInfo.position - other.position;
            }
            if (dist < params.alignment_distance) {
              alignment += other.velocity;
              alignmentCount++;
            }
            if (dist < params.cohesion_distance) {
              cohesion += other.position;
              cohesionCount++;
            }
          };

          if (alignmentCount > 0u) {
            alignment = alignment / f32(alignmentCount);
          }

          if (cohesionCount > 0u) {
            cohesion = (cohesion / f32(cohesionCount)) - instanceInfo.position;
          }

          instanceInfo.velocity += (separation * params.separation_strength) + (alignment * params.alignment_strength) + (cohesion * params.cohesion_strength);
          instanceInfo.velocity = normalize(instanceInfo.velocity) * clamp(length(instanceInfo.velocity), 0.0, 0.01);


          let triangleSize = ${triangleSize};
          if (instanceInfo.position[0] > 1.0 + triangleSize) {
            instanceInfo.position[0] = -1.0 - triangleSize;
          }
          if (instanceInfo.position[1] > 1.0 + triangleSize) {
            instanceInfo.position[1] = -1.0 - triangleSize;
          }
          if (instanceInfo.position[0] < -1.0 - triangleSize) {
            instanceInfo.position[0] = 1.0 + triangleSize;
          }
          if (instanceInfo.position[1] < -1.0 - triangleSize) {
            instanceInfo.position[1] = 1.0 + triangleSize;
          }

          instanceInfo.position += instanceInfo.velocity;

          nextTrianglePos[index] = instanceInfo;
        }
      `;

      const module = device.createShaderModule({
        code: wgslCode,
      });
      const moduleCompute = device.createShaderModule({
        code: wgslCodeCompute,
      });

      const pipeline = device.createRenderPipeline({
        layout: 'auto',
        vertex: {
          module: module,
          buffers: [
            {
              arrayStride: 2 * 4,
              attributes: [
                {
                  shaderLocation: 0,
                  offset: 0,
                  format: 'float32x2',
                },
              ],
            },
          ],
        },
        fragment: {
          module: module,
          targets: [
            {
              format: presentationFormat,
            },
          ],
        },
        primitive: {
          topology: 'triangle-list',
        },
      });

      const computePipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: moduleCompute,
        },
      });

      const renderBindGroups = [0, 1].map((idx) =>
        device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: trianglePosBuffers[idx],
              },
            },
          ],
        }),
      );

      const computeBindGroups = [0, 1].map((idx) =>
        device.createBindGroup({
          layout: computePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: trianglePosBuffers[idx],
              },
            },
            {
              binding: 1,
              resource: {
                buffer: trianglePosBuffers[1 - idx],
              },
            },
            {
              binding: 2,
              resource: {
                buffer: parametersBuffer,
              },
            },
          ],
        }),
      );

      randomizeTriangles();
      let even = false;
      onFrame(() => {
        even = !even;
        const commandEncoder = device.createCommandEncoder();
        const textureView = context.getCurrentTexture().createView();

        const renderPassDescriptor: GPURenderPassDescriptor = {
          colorAttachments: [
            {
              view: textureView,
              clearValue: [0, 0, 0, 0],
              loadOp: 'clear',
              storeOp: 'store',
            },
          ],
        };

        const computePass = commandEncoder.beginComputePass();
        computePass.setPipeline(computePipeline);
        computePass.setBindGroup(
          0,
          even ? computeBindGroups[0] : computeBindGroups[1],
        );
        computePass.dispatchWorkgroups(triangleAmount);
        computePass.end();

        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setPipeline(pipeline);
        passEncoder.setVertexBuffer(0, triangleVertexBuffer);
        passEncoder.setBindGroup(0, even ? renderBindGroups[1] : renderBindGroups[0]);
        passEncoder.draw(3, triangleAmount);
        passEncoder.end();

        device.queue.submit([commandEncoder.finish()]);
      });
      ```
    </details>
    <LinkCard
      title="Run it in the playground!"
      href="/examples#example=playground__JYWwDg9gTgLgBAbwFBzgQwCYYEIFcYwQB2ANCulgKIA2ApiLUTGasQGJRoMsUYAKaTgxi0oZAL5wAZlAgg4AcgACMAJ5haAczC4A9LQAeXMHQC0hCNQDWwGAoDcSJAGNiAZ3iY0YEVDgBedAB3NFs4IjQAN2BNNEIoADptXAB%2BBKhaAEdcWg8AQQxvXwAKAEpHVyIPOAxaaOdaAODQz0KfUTSM7NyYABE64AayxyRgKThigEJa%2BtpSxHIYAAtZIPDaNcooWShihTZQugw4QnRnbOAM9BqBhoVypHEnSurnNCJItDcmtBCwzAwNHojBgezeHy%2BChIiHQbg0zhgACU4sAIAAuOAARjg4geL3glREBnggXBnzcSVoMAAwsQiaCFEFaAAjZL3WFwADifAAqtT3uTaUxDDAKu54GAMm4QSj2NAQHEmhForF4kkdJSYHwMlJRBkMPyIW42PK4sNnnSRQlKlIYrgMsVkKgZoNaDwpKaYBjJbkZTBUUQTVAFcxyGhqGAlmgALIQWoYhQ%2BkC4aj%2BkzAWgYKGPB5IAF4AjEPbIogYOTAABetChcE4pfLVYAKlBgO9NHQ3Ln8XAwIIuFTRG48FJdX5Ai6GtaMnFaMPR47yG5K7QMQA2OAAKjgABYeLg3GhNCuuby56IeQejwkAMqNgDyiLynMocAAPieeWeoBfD7QEtS7z4ABNAB9Xpbx4BUwA0DA8hpad-WIDEYCgHIJAeIgNjgNhqAgOIAGYACY8m2NBVGKXshAHKAh1wEdRE1aNvBgksjzKUoEmlUEAG1yAABgSPiAE5oQEvi%2BIAVlEhJ8Ok8SpLgATZMUwS%2BMxMgAF0Hko-tfFo%2BjElwIgoPNFxxROFs2zoa9lyaMTtzFKp4BQ1siHbWgADVRCJXo4jQJUsJwvCYCIkjOHI3jUDEngXKs2gbKrHhzEstzrNs3Q4EIpLYtS%2BL0symKUvchLGgyrLyGS1zivy8qtJGbscvcvIQAgIySTgCTxMc6pGroPgIH00dvkCMKyISGQ5EdOA6Dc5YMUInFoTKAIAD5yAnP9nAQ2c6PnJ1UDgJcq2Qoq6Ga1qmE3OAAA4rvKg64H3X80XIB7uU-Xbz0vP8eQAOQASTYB9ozfD8vx-K9bwfJ8X3fd7we%2B-9ANA8DGx4XEyC7czes87zDC-JoNqnWgZy-BdUCO48ca82BDF8mA0ASZlVBEAAZRhNGWPdvoxeHPu-RGPMoRFG0oAANSDmMzODqQQgMTrQnNHEwtYgoI4jSPI6m8YML9GKljBWNodjOKpYptdpgx6bQB4LaJPWjJM3MpCMhEA1rd4yxAZdmyqjtlv2sYJmmW45gWB6Mhge0iEcVAnlQbtCgZgLVdw9XRq107aHOtqru3B5UA9PxijoeBgDs%2Bw4HLgAeCy-ezlq2sr4AAGoW-mfbnT87jy63bcNKaJjlnST3JvmLcFtMLFY4OpO0B7vO4BbrEB8CIelhH%2BsQGWie4CnzEZ67hmF77pfMtXuB183r2d5U7Ep7EiTD5qbve53M-8Ivq%2B6xv8e773lSkkZ7xxuLMBI3QcgJCCC2EQZMcb9UGoObifENKiWhHPJm-MC6gNdOAnIkDoG2B2gZc2WcEFfjcNxTEqDFLoL8pggyDwnhmScnAIImg3DUFpLUJoAADcgUgiC1ggAzEQxRIgYkiLQZwhEpDQjihiKQRF5imBWnAKRMjxid2mlSHsA0mgaMIsUV6B1xEJAMFdVwbhihxVKCoiYkQEiqCukuIgNjcp2J4A9MxFityuPce5OxZ8zHOK3FYgJdA7EmOwagSO0c9FuGASMQuQijxIhEbKQMsgQBeVws4Ww5EpF5IKZI6RsiVFqKUQtbRcSoBCNMH5IgRiikQHyWocx0IWltNUE47B4hkmHRQrgBEcBfZxWtuHA6kAlyISEaUzRXj1G0GKWoOA8zZHowGR4VCIyaZEjvPgHQ8BtFKGZLgYAqZgBuOmbYAM8wbmzLWUs5w245EmKUHkzJxRMTzBkIeHkHknmGLeXHAZpyrkYCuZoYofF5hKE0LIXAYAYXzE%2BFAauRkxjyjUfA-RGJBDhWrmM3K1toQABIEA4xzkwcQK0wVSMtgIoRCorl7OKKc85ly3FXI8O8BoIEIWGHmMAYAGJcBETgCQD5rSvmwvUesqQFS4B7MMAcmARzJmoFLlXJyfLaD-SIB6JouLKEio0gMrVujZCiMzE0a1M5xHQjSYiDJsyOByFya0gpxQeUMyIA0A1HoEhdIKXY5%2B2qIAji4k0X1erA0QASA8gMFqdESn0YEDR25ij2pEMcZekapBcTktCTEgkYmpukJwTQAKmjZtdba5ewLigUpxiVcQ5LKVZzbUEjKTaW1duXJICeZbn61KESqgwaqjkUQGtCP51aPJ9KcKgJQ86GBMCZXAFlWTDzss%2BbM75vyq01oVUq6VbwD1yszVokx2rXC4SgNiDN0j8LfKEquQScAyoSQkoJEt4lP3ft-XxaEhEf2AcyuB2F4bdH3ugAtZ9zhX2ESEhBsDwGS2Ym3GhqDoHtxiS-ZB4DuYHrashdUQIM1OZLGKPOmtU9DEwoSApASEkw3LoOneyw0AmjewMMUODj7oSCayjUYAHgSMHTHc8rNgmS0jvIE8Xh9VzLsM4dw2gtJwD4EaIEfhFMhkjOJe5CZ2ik3ECBWUkFB0Q2rIVZsjj2zhnwAEFRPSmrDq0B0rMkC5G-UNCeVUxZ0pvMBhAtsjmyxAtEUWeGGIxkQS%2BfE-5xoiiYsmLi5oBLTBwsoUi0saL90DquCWLkMLfm9WFcWSVsrxBcsZFmgVtLRX%2BkcfBaWKFKK4DwsRciq9ggMVECxcGNRzh7QNZgMZvqeL0CayJVnUlcB%2B312pTAWlM92uQrcoe7rCLWp9dRQNjw0BfzQmnBgEChCRBqMwsSKbtAEFPIJWReb9drZ0vIJtzrhE4V7aRV1tF1djtVtoGonSIBvgYlc7pQcYLXDaZEN1oI0ArB-bAOF5ch7N3bq00c42HKLn%2Bjce2CAzJwwCo%2BDKnzwAMDzE0DT%2BZ%2BFcAd1vbowVFjAj04wOY5%2BaKdW8v9fqw1EAmhje2CCe7CCe6lkMOajjqA%2Bchb7I8xDRjoqAPLXzzL2X2qMfV2JTXgh0DUHi%2BumkF12p8VwLzo3NWlwWdV0xkDGubd%2BDtwGWkudAhW%2BfkXBxRvy7e%2Bt1XOAtdltxVW-0kPgRy7Lx%2BR51AQcfUBBjzLgwLOHoPUJFcnIz844mIV0bkRpWxxwDFxNyXA0e5y8z%2Boo3fnCbJb1T63Vgv42JoGrc4g0Ji8MXM0QctifxjFAb7XcHFIlecB8xVwXGfa%2BedCxZluqeBcBuFx3mZ7sp698SP3vPOIC9V2H6PnsfYIcJG12bpLq%2Bw7aIepfkES9Ag7%2BDcsr1ah9%2BoAf0wT3TA2775AQeiTxP3H2tAgFK3tyIGvxSzn1r3dyX2f2WD7071mU-zL3ANqyIF-xgH-0P0AJxBTST2-3N1zjUSt1gIOmIJ%2BBNyyzN0IyqRsRoJ12wPLWYSAOH3gKwItzgDIOZwT3QIgPdkCAEwwMgPoKIhEMEOIBYPsVjTb3Xz3xMTYIOjkLXyDVs2cWXwmEn0ySulAJ0J8wi0a3mGXkYNN0fy3FAOIPq3yxMImE4L0LPwpE4JsOMOflUKF3ULf26SVFNBNyrBbxv3bw0L-mcGoGMBLny0CJS2CO8NDWLUAR%2BRGFZ2cgHSrCaHD1yjbXcOHw8Pb372QQHjUVLT4jPlbWXAoMT1bzUITQKJQSaFMBKIAXKKrGfnwKTzyIUJQIDCoSKKxE-WXhaNv0P06KDQKOoQaKaKniGLaJMQ6OqM8NqO6OIEKNDz3imLrjihKkqP5xiK6M3xWPqMCCaMGLSNoFmPYImFGKWIOKIF6LWMaM-WmLOJ2OuI3y7zuImOOIGM2KyOXFmLmIWPyOWKES0LeI0JTVu0mzISr3ZwvmuOASQGUwtFYRagwBTF0xwUnC2hJhEGvCjFqCgFjHRLoHJnQPjDYQ4S4TjDdCVhYWqDRIxNxx00JlDmJhnHxMwFEGJIxLJNcApLU2pNqGZJEHQhU1YTAGAA0BN0wlZLARxJnEREYEJL4ClOWSuWNn2nCNUFai9EUDQHwAgGzAVx1gxG0UZLoAxAtNpIejOQMjcAxEikzzv0oM1mvBcgpIWj7kWXvwIBbDOREAdLgCdPn34NrzcAJNEFZip3lloUP1rwLS4gxBA3jMzyLhDATCkDThCkIgMEImNNDMWlTNQTwMWRLLjndCrTNzNJMWtKtLjAxMWQZigDSSDJDIOhdMLk9G9ClD9ADCDBDB9KLIenLOHJ7BbG9n9CkRrIekIEgFwk0FUATBxlMBNw8ALPbTpPpIJDkDx1VOlI1LlNwQVJEBFIezVJlM1PIG1N1ITANMIALPhzxxnIOjrK3QbLoDPPRjFJROqAa0JOwAhU5F62GmDOd2oQSBMh9QwHT1WnWjZJPNnCAt6zJK1TIlvJ7AvI1M1EAtLGAv21ZnQvwBRUWRBBbFyEdMP07LgGZAhShWTKHNiVyFaigAaBfNDLtNHBOnrnIX5lNRgtHNr03KErLPRlKExnFNeF3J01wowHwqRVAuQRLQ0kgu8GKGgtgv8DWmdAQu2lkvkuRW0RvPwAxCfJ033PVMwhwuQoIqItBFhVIqYHIrbKotTNoo6zcgYtTKlBYrYrDIOk4tEG4ril4vtJ7gEsYrHIemEudLcros8qxEip8vtD8uotQECqgGCtylCqGioQARpwMEEszxiuiqHOovcq200HmiSuYpSuPDSpov5m9DP2okQTEFTJKoOk6tHIxiQFzB-gbFoHu2sQeG1TqEYCaCkHDGlEcHYConUvmC0smXGqEUCEmBWpnm7HhwVFLEoH9RpNLyJkQq0x2sBH2sJPNATmxhFHtE8gzDWFJEtGJE1GpHGwlxuodA4kQo8nutMiutYX-NEAEDcDcH6DcC2ilPiF5l5CVJlygGBtBtyAhp8B40CG0UEzggZmcCWDNxctr2ouiA2GQg%2Bruo2EirCJJigA8nDByEdOd3ptEiKtIzwgwDvDAATApsEALPDPiFoDZoTGB2rCHO6oc3IC2ukpEARtFzkFOr2v5IYmZC0CuTPIRsuvQIRwey%2BAnypAssvJEI1t1o1OwTMslq1tNhgH0pQpMRTIehWrgBSHVrx0tv20oXqNMolqQrwpAt6J4GNo9oRoSHI17BgGxoAHUUc0drEqVG4mA-aDazblS-r0CJSta5aDrpaQBZbzqFalaiBYaVStbs1lSgatawbkb4hsFewQa07CTzbDbMIKIsLMJK7U7s7EguIJ0yZnc7Z8YsEZ4q63Aa6GIuJnb-tnc7aHbAaoBR6wBKEJiMQp6Z7Xa6pyAB6h7EgMBOAghihlJo6LcW7q626EhE7JMiYIE-w3BcBmRJzihuJtrPZ17xorlxMaNSgV7cRJL4AIAfAAxQL9oDCAxegm9BdkzBIRJFwvNlcAx3SGtqNQH5IeBiCgGb9QHZIwwmCzcYH8t4HJIeBODkGUtUG8HRDoG8tGscH1JHgRgXZ-VHlmJqBVA2bZkRrJkk8Q5ZgKCx1ET-rqg54U5sJszQpNZig7xmQAAraRGAYNGm3IYob%2B5h9jHSsBc%2BqBGBYheccHVqr8NBF%2BBmJhJwAEaHYQUQYxVABQa8SBqfd2Ahgs7RZ%2B-0cMDEeR3%2B02RfIgAhvVRZb2IgeBrxtAAwUBqSExDwLzCh788gcRRatRbRZx9wVxqB4gDxwXAxZ%2Behxhn%2B9wNWzc3MQxlqkocgcxyx3QmB2xwE25RxuAWJqoeJqx4gLBxrLxq5Xx2s-x0Byhh6EJ9mwBNScJ1ASJ1aDzKp7Wtx%2Bp6jFJjLaCBhph3%2BrJiSgxrAIx6iUxxQPIJguAGxngOxobBx6gJxjJ6ppB4BhoRpnxwBPxgJlSIJjpkQLpsSHpxTHgfppamJ-ZikQ5m-cZ%2B-SZ9J5h2ZvqkYXJtzExgp1Z%2BLOAEpzZspnZvZ5hi-DBkEUZrmWspps5lpi5gSdpg6TpsJh5iJyIKJwZ15uF8wpgRFgrDNVJ756ZzJvpOZvMBZvJ4Fsx2kKQoRDZ8gLZ8p3Zypol-Bo5m018lF6KNFwJ4LG5nFisvFgll52Fvlj5iliZkwH5mZ2l-5%2BZ-gRl3YApllzA8FlCUpoA7Z1sbloZsA1lslk55ph6BUdFhITFgzUJ7pzFmKp56JkxU1zgslz5ygql15v5h4IAA"
      target="_blank"
    />
  </TabItem>
</Tabs>

Congratulations! You've successfully implemented the boids flocking algorithm in WebGPU using TypeGPU.
Along the way, you learned about creating and using a TypeGPU runtime, writing shader code, managing buffers, creating pipelines, and using slots. For more information, refer to the TypeGPU documentation. Thank you for following along and happy coding!
