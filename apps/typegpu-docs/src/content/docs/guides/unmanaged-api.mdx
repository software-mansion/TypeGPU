---
title: Unmanaged API
description: A guide on how to use the unmanaged API.
---

# Introduction

This guide will show you how to use the unmanaged buffer API to allow for type-safe and convenient read and write operations on WebGPU resources.
We will explore how to adapt existing WebGPU code to use the unmanaged API, and how to use the it to create new WebGPU resources.

# What is the unmanaged API?

The unmanaged API is a set of tools for WebGPU that allow you to create and manage typed buffers.
It provides a way to read and write data to and from WebGPU buffers without having to manually translate the values to and from the raw byte arrays that WebGPU uses.

import { Tabs, TabItem } from '@astrojs/starlight/components';

<Tabs>
    <TabItem label='WebGPU'>
    ```ts
    const device: GPUDevice // WebGPU device

    // struct PlayerInfo {
    //   vec3f position;
    //   u32 health;
    // }

    // Creating a buffer, the type hint is GPUBuffer
    const buffer = device.createBuffer({
        size: 16,
        usage: GPUBufferUsage.COPY_SRC,
        mappedAtCreation: true,
    });

    // Initializing the buffer
    const initData = buffer.getMappedRange();
    new Float32Array(initData).set([1.1, 2.0, 0.0]);
    new Uint32Array(initData).set([100], 3);
    buffer.unmap();

    // To read from the buffer we need to create a staging buffer
    const stagingBuffer = device.createBuffer({
        size: 16,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
    });

    // Manually copying the data
    const commandEncoder = device.createCommandEncoder();
    commandEncoder.copyBufferToBuffer(buffer, 0, stagingBuffer, 0, 16);
    device.queue.submit([commandEncoder.finish()]);

    // Reading the data 
    await stagingBuffer.mapAsync(GPUMapMode.READ);
    const rawBytes = stagingBuffer.getMappedRange();
    const value = {
        position: [...new Float32Array(rawBytes, 0, 3).values()],
        health: new Uint32Array(rawBytes, 12)[0]
    }

    // Using the value
    console.log(value);
    ```
    </TabItem>
    <TabItem label='TypeGPU'>
    ```ts
    import { u32, vec3f, struct } from 'typegpu/data';
    import tgpu from 'typegpu';

    const device: GPUDevice // WebGPU device

    // Defining a struct type
    const PlayerInfo = struct({
        position: vec3f,
        health: u32,
    });

    // Creating and initializing a buffer. The type hint is:
    // WgslBuffer<WgslStruct<{
    //     position: Vec3f;
    //     health: U32;
    // }>> & Unmanaged
    const buffer = tgpu.createBuffer(PlayerInfo, {
        position: [1.1, 2.0, 0.0],
        health: 100,
    }).$device(device);

    // Reading from the buffer (value will be properly typed according to the buffer type)
    // value: { position: [number, number, number], health: number }
    const value = await tgpu.read(buffer);

    // Using the value
    console.log(value);
    ```
    </TabItem>
</Tabs>

In the example above, we have a `PlayerInfo` struct that we want to store in a buffer. Using just the WebGPU API alone, we need to manually copy the data to the buffer,
create a staging buffer to read the data, and then manually copy the data back to a JavaScript object.
This process involves a lot of boilerplate code and introduces room for error.
Moreover, the example given is relatively simple. If we were dealing with a more complex nested structure,
manually calculating the offsets and sizes would be even more error-prone and time-consuming.

TypeGPU addresses this issue by providing a way to define the structure of the data we want to store in the buffer and then read and write the data using a type-safe API.

# Using the unmanaged API

## Creating a buffer

import { Aside } from '@astrojs/starlight/components';

To create a buffer using the unmanaged API, you will need to define the buffer type using one of the data types provided by the `typegpu/data` module.
You can then create a buffer using the `tgpu.createBuffer` function like in the example above but that is not the only way.

### Using buffer type

Like in the example above, you can create a buffer using only the buffer type.
This will create a zero-initialized buffer (just like creating a WebGPU buffer would) when the buffer is first accessed or used inside TypeGPU read or write operations.


```ts
import { u32 } from 'typegpu/data';
import tgpu from 'typegpu';

const device: GPUDevice // WebGPU device

const buffer = tgpu.createBuffer(u32).$device(device);

// That's when the buffer is created
const gpuBuffer = buffer.buffer;
```

<Aside>
    To make the buffer 'Unmanaged' you need to call the `$device` method on the buffer object.
    That marks the buffer as unmanaged and allows you to use the buffer in the unmanaged API.
    ```ts
    // WgslBuffer<U32>
    const buffer = tgpu.createBuffer(u32);

    // WgslBuffer<U32> & Unmanaged
    const unmanagedBuffer = buffer.$device(device);
    ```
</Aside>

### Using buffer type and initial value

You can also pass an initial value to the `tgpu.createBuffer` function.
When the buffer is created, it will be mapped at creation and the initial value will be written to the buffer.

```ts
import { u32 } from 'typegpu/data';
import tgpu from 'typegpu';

const device: GPUDevice // WebGPU device

const buffer = tgpu.createBuffer(u32, 100).$device(device);

// That's when the buffer is created and the value is written
const gpuBuffer = buffer.buffer;
```

### Using an existing buffer

You can also create a buffer using an existing WebGPU buffer. This is useful when you have existing logic but want to introduce type safe data operations.
<Aside type='tip'>
    Since the buffer is already created you are the one responsible for the buffer's lifecycle and making sure the type matches the buffer's contents.
</Aside>

```ts
import { u32 } from 'typegpu/data';
import tgpu from 'typegpu';

const device: GPUDevice // WebGPU device
const existingBuffer: GPUBuffer // Existing WebGPU buffer

const buffer = tgpu.createBuffer(u32, existingBuffer);
```

## Adding usage flags

When creating a buffer using the unmanaged API, you can use one of the available builder methods to add usage flags to the buffer.

```ts
import { u32 } from 'typegpu/data';

const device: GPUDevice // WebGPU device

const buffer = tgpu.createBuffer(u32).$device(device)
  .$allowUniform() // Adds GPUBufferUsage.UNIFORM
  .$allowReadonly() // Adds GPUBufferUsage.STORAGE
  .$allowStorage(); // Adds GPUBufferUsage.STORAGE

```

<Aside>
    Along with the flags, the methods will also provide type hints.
    ```ts
    // WgslBuffer<U32> & Unmanaged & AllowUniform & AllowMutable
    const buffer = tgpu.createBuffer(u32)
      .$device(device)
      .$allowUniform()
      .$allowMutable();
    ```
</Aside>

If you want to add specific usage flags, you can use the `$addFlags(flags: GPUBufferUsageFlags)` method.


## Writing to a buffer

To write data to a buffer, you can use the `tgpu.write` function. The function takes an unmanaged buffer and the data to write to the buffer.
Because the buffer is typed the type hints will help you write the correct data to the buffer.
If you pass a mapped buffer, the data will be written directly to the buffer (the buffer will not be unmapped). 
If you pass an unmapped buffer, the data will be written to the buffer using `GPUQueue.writeBuffer`.

```ts
import { struct, vec2f, u32 } from 'typegpu/data';

const playerInfo = struct({
  position: vec2f,
  health: u32,
});

const buffer = tgpu.createBuffer(playerInfo).$device(device);

// write(WgslBuffer<U32>, { position: vec2f, health: number })
tgpu.write(buffer, {
  position: [0.0, 0.0],
  health: 100,
});
```

<Aside type='caution'>
    If you passed your own buffer to the `tgpu.createBuffer` function, you need to make sure it has the `GPUBufferUsage.COPY_DST` usage flag if you want to write to it using the write function.
</Aside>

## Reading from a buffer

To read data from a buffer, you can use the `tgpu.read` function. The function takes an unmanaged buffer and returns a promise that resolves to the data read from the buffer.
If you pass a mapped buffer, the data will be read directly from the buffer (the buffer will not be unmapped). If you pass a mappable but unmapped buffer, the buffer will be mapped and then unmapped after the data is read.
In the case of a buffer that is not mappable, a staging buffer will be created and the data will be copied to the staging buffer and then read from the staging buffer. After the data is read, the staging buffer will be destroyed.

```ts
import { arrayOf, u32 } from 'typegpu/data';

const buffer = tgpu.createBuffer(arrayOf(u32, 10)).$device(device);

// data: number[]
const data = await tgpu.read(buffer);
```

