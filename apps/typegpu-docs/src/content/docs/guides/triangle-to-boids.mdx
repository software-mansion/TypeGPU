---
title: Triangle to boids
description: A guide on how to start a simple project and scale it leveraging the power of TypeGPU.
---

Let's start off with a simple program that draws a triangle on the screen. First we need to setup the canvas and our runtime.
This setup will most look very similar in every project which draws to the screen.

```ts
// triangle.ts
import { createRuntime } from 'typegpu'
import { addElement } from '@typegpu/example-toolkit';

// create the runtime and get the GPUDevice
const runtime = await createRuntime();
const device = runtime.device;

// add the canvas element and get the context
const canvas = await addElement('canvas', {aspectRatio: 1});
const context = canvas.getContext('webgpu') as GPUCanvasContext;

// configure the canvas context
const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
context.configure({
  device,
  format: presentationFormat,
  alphaMode: 'premultiplied',
});
```

import { Aside } from '@astrojs/starlight/components';
import { LinkCard } from '@astrojs/starlight/components';

<Aside type="tip">

Im creating a canvas by running addElement form our example toolkit but that is not the only way! You can use the standard `document.createElement('canvas')` and append it to the document.

</Aside>

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Let's draw a triangle!

Now that we have our canvas setup, we can start drawing on it. We will start by creating a simple shader that will draw a triangle.

```ts
import { wgsl, builtin } from 'typegpu'

const vertexCode = wgsl`
  var verticies = array<vec2f, 3>(
    vec2(0.0, 0.5),
    vec2(-0.5, -0.5),
    vec2(0.5, -0.5)
  );

  // here we can use builtin.vertexIndex to let TypeGPU
  // know that we want to use the @builtin(vertexIndex)
  let pos = vec4f(verticies[${builtin.vertexIndex}], 0.0, 1.0);
`;
```

<Aside type="caution" title="Pay attention to how the vertex shader code looks!">
  There is no function declaration and no return statement! That is by design - TypeGPU will take care of that.
</Aside>

Since there is no function declaration there is no place for parameters - but don't worry,
every used builtin and vertex shader will be properly added by TypeGPU.

```ts
const fragmentCode = wgsl`
  // let's go with a simple purple for now
  return vec4(0.7686, 0.3922, 1.0, 1.0);
`;
```

### Time to create a render pipeline
import { Card, CardGrid } from '@astrojs/starlight/components';

The API for creating a pipeline in TypeGPU is similar to the WebGPU API, but with a few differences.
<CardGrid>
  <Card title="Layouts" icon="seti:bicep">
    There is no need pass a layout. It's automated.
  </Card>
  <Card title="Modules" icon="setting">
    The module field in both vertex and fragment objects is replaced with "code" which accepts wgsl code.
  </Card>
  <Card title="Vertex" icon="setting">
    Apart from the code field, the vertex object has an output field which maps the output of the vertex shader to the next stage.
    It works basically as an "export" from the vertex shader. The variables with matching keys will be packed into a struct and passed to the fragment shader.
  </Card>
  <Card title="Fragment" icon="setting">
    Variables present in the vertex output can be used inside the fragment code with no additional setup. The target field remains unchanged.
  </Card>
</CardGrid>

```ts
const pipeline = runtime.makeRenderPipeline({
  vertex: {
    code: vertexCode,
    output: {
      [builtin.position] : 'pos'
    }
  },
  fragment: {
    code: fragmentCode,
    target: [{
      format: presentationFormat
    }]
  },
  primitive: {
    topology: 'triangle-list'
  }
})
```

Now all we need to do is execute the pipeline! To execute it we need to pass GPURenderPassDescriptor along with the vertexCount.

```ts
import { onFrame } from '@typegpu/example-toolkit';

onFrame(() => {
  pipeline.execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
  });
});
```
<Aside type="danger" title="The code above draws nothing!">
  The pipeline.execute() method encodes all the necessary
  commands but they will not be queued until we read from a buffer or call runtime.flush().
</Aside>

```ts
onFrame(() => {
  pipeline.execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
  });
```
``` diff
+  runtime.flush();
```
```ts
})
```

## Now let's have a look at our final program and compare it to WebGPU.

<Tabs>
  <TabItem label="TypeGPU">
    ```ts
    import { wgsl, createRuntime, builtin } from 'typegpu'
    import { addElement, onFrame } from '@typegpu/example-toolkit';

    const runtime = await createRuntime();
    const device = runtime.device;

    const canvas = await addElement('canvas', {aspectRatio: 1});
    const context = canvas.getContext('webgpu') as GPUCanvasContext;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'premultiplied',
    });

    const pipeline = runtime.makeRenderPipeline({
      vertex: {
        code: wgsl`
          var verticies = array<vec2f, 3>(
            vec2(0.0, 0.5),
            vec2(-0.5, -0.5),
            vec2(0.5, -0.5)
          );

          let pos = vec4f(verticies[${builtin.vertexIndex}], 0.0, 1.0);
        `,
        output: {
          [builtin.position] : 'pos'
        }
      },
      fragment: {
        code: wgsl`
          return vec4(0.7686, 0.3922, 1., 1.0);
        `,
        target: [{
          format: presentationFormat
        }]
      },
      primitive: {
        topology: 'triangle-list'
      }
    })

    onFrame(() => {
      pipeline.execute({
      colorAttachments: [
          {
            view: context.getCurrentTexture().createView(),
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
        vertexCount: 3,
    })

    runtime.flush();
    })
    ```
    <LinkCard
      title="Run this in the playground"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgdwOYGcA2AaOBjKAUwEMZCAlAVwDsZRDcAjS4TO6uAXzgDMoIQcAOQwAnmEKowlIQChQkWIjjEAJqoCimQiEK1cEagDEoxXV179BQgAJiJUygHpCADzNhtAWhgQImAGtgGCEAbllZPEN0eCgaOnMAXhVkYmD8IlIKePoACgBKcKjqGLhVQgA3YDxCOGS42noAOnKqmvDI6Pg8YmoK4nQ6lLT4NU1tXVpcoR6%2BgaFcBAGJPBhyUmAIAC44AEZOQs6S7sMyV3hk2f70JtRCGABhU7cYaeRCRkchfJVBgHEAAoAVQevWuT1oLyKXTgYCI6D0MA2hiM0BApCG1GIVVQpGgt2kt3uAKIPEIUCIqlBc3QqKg6NehyOZxgTWKPGAqEoRFyCFkcDKlWqDH5vDRpB2cMICNoyOM4pg2FFxEwYAAFsQALIQco7IRSkCUNjATzAQiqBayA4dYqlMAmwiYYDUWr1HK6JrogIUPTlKAAh1Ol280UVclnHZ8gUCqK6lAYTAAA1F0bg-SgafD1TNg2SxApxFEAB4w3gAEw8XAAZgAfLkU6nM%2BXcgAGJot3BtgCs%2BSVjejpbLuS83dwI6aPb7-abQ9HcHHPYbAqZ-e08EguabABYeLkw7Bs9KANoAEgQzFY7Ca%2B7OAElqOVXJwALqd9u4Xbtw6pxNTgUQSgYGkGBIyXOAjwvY1qCaDdgk2ahnzgPUNzkVNOFFTgpz4YhUEmEDEAbWNCB2NAsGTfsiBgbkOFLLdWyaAB2AA2AAOJi3yrABOMsyw-Jo%2BJbb9o1-BskSgO58KPKNGx4BVJXhRE5TpBkGxfDCpzhUA4LDUDU18SBMAgVBRD1GAoGAXpUG8J0YlQrgrXyCIUVMXRcgKOoawIgV7QkINCCaNxCDwQDCBDGN-GgABBGAkTwNU8PQHYjzA6T%2ByqQhkB2YoWSJR5uSIWgABUXm5UL8jZTIyAANTNZACj-Rs8G0fMqpVShiPAjs4C6nrXzAgVDLUAB5MA9SakgoEtac4BiaBCBGvVZqIKbG0whs%2BtTG83CeeIdirKcDgiAUGgSfyeEwSh0DVApwgOIA"
      target="_blank"
    />
  </TabItem>
  <TabItem label="WebGPU">
    ```ts
    import { addElement, onFrame } from '@typegpu/example-toolkit';

    const adapter = await navigator.gpu?.requestAdapter();
    const device = await adapter?.requestDevice();

    if(!device) {
      throw new Error('Failed to acquire a device')
    }

    const canvas = await addElement('canvas', {aspectRatio: 1});
    const context = canvas.getContext('webgpu') as GPUCanvasContext;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'premultiplied',
    });

    const pipeline = device.createRenderPipeline({
      layout: 'auto',
      vertex: {
        module: device.createShaderModule({
          code: `
            @vertex
            fn main(
              @builtin(vertex_index) VertexIndex : u32
            ) -> @builtin(position) vec4f {
              var pos = array<vec2f, 3>(
                vec2(0.0, 0.5),
                vec2(-0.5, -0.5),
                vec2(0.5, -0.5)
              );

              return vec4f(pos[VertexIndex], 0.0, 1.0);
            }
          `,
        }),
      },
      fragment: {
        module: device.createShaderModule({
          code: `
            @fragment
            fn main() -> @location(0) vec4f {
              return vec4(0.7686, 0.3922, 1.0, 1.0);
            }
          `,
        }),
        targets: [
          {
            format: presentationFormat,
          },
        ],
      },
      primitive: {
        topology: 'triangle-list',
      },
    });


    onFrame(() => {
      const commandEncoder = device.createCommandEncoder();
      const textureView = context.getCurrentTexture().createView();

      const renderPassDescriptor: GPURenderPassDescriptor = {
        colorAttachments: [
          {
            view: textureView,
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
      };

      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.draw(3);
      passEncoder.end();

      device.queue.submit([commandEncoder.finish()]);
    })

    ```
    <LinkCard
      title="Run this in the playground"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoKIBsCmIcB2MANHBAQGJTL5wC%2BcAZlBCHAOQACMAnmDgHMwAVwD0OAB40wuALQwIELAGtgMdgG4AUFoDG5AM7w0yMDBxQ4AXhQB3ZGrgFkAN2ADkCqADohwgPzeUDgAjsI4RgCCqKbmUAAUAJTa%2BgRGcKg4bro41nYOxjFmFoHBYREwACJZwDlJ2lrAjPEAhJnZOImIWnBwMAAWLLZOOMMYUCwJ7BQOuKh9ECi6YcDBKBk1OeyJWnQ6qem6yAQuyAZ5yPaOaJi4%2BETx7EcnZ%2BykCGf8ujAASp7AEAAXHAAIx0ZJ6QzwVLmCTwGzPU4GXw4GAAYXIsJgj1sOAARn5tihzgBxAAKAFU0cckRiiJIYCkoXAwMEDIQYP9yBRoCBPHlnG4PF5fCIUTAycFGBZgqhqS8DDyoHzsRDIfS4d5Uox3MJgvEED0Nh1iEbGLzPMDWREOVzKBaSEbkFgwP1kABZCCZYHsa0gYRYGDAGTAHCoN67NUHeBgYM4LDAAi5GztWo4LXBTw4H6ETJQMlxhNJg1GrDIHgQYQwH3IKsQCO9FwWWHAw29XogL0BnDA1M5DM4LMAZTdec9qG7Jfb7f03rgAAMjdPepwm7BJEvl4wCHA%2BYn4pvl3BOHjhMBA-u17CAPqJzISLoANWbkgAkgR73BgcIAMwAJkPdsulkAA%2BY9T3PIMCHiSADDUAECC6JtdAAFkYboj2nU5LFgi4JnLAAeZC-0YUgfxAg9MOXYj4gABm8WjSHogBWRJTSorCcF0P94lkFjSD47xWPYjjGy4nj%2BLgQTWMA6c1VE4IYD1HdkLQmCIAMABtZ91wkd97wAXSYhjSBBBiISovYj3nETenBES6BE5hkAEe5qww9tOwnXBe02dNdEzcwRzQCxx0nNtl1nHsF1k49nNcjlYu3XcHGg4CwM4LAICOINyDopCuLQjyqMU5S4FUujvAAdgANgADhq4yfwATj-P9TJM0FzO0SzAJszd7M3TkoAEVEDGBTTAIio9zWVS0WTZW1cvtObHSPRzNyMo0Nt6VlQHgptWyGiBICygQeB9GAoGAY4BDkBMjAbehTXBBotG5ah8HiJJrDAiLozgfQQD5D8MAIKLLBTPyByzDFgeOTBwa9Cx6iNAGsT1HBH1DYYEUxBlxTRPVgiIAAVBlMaSGHzGx0ZUbR5kSbzMkzgMaoDAC4MvGBckKRzD8LBZgw2YiTmzGgPJpsBpRoEiGBOV0fo3PGuBJqPKWsJx4EMeCWnbFsyLcGQKBH2dcIJsYuBLetraqKytAAHkwB9XQjagJ6jyMaAcCdn0veCD32x29tbfoBpegBsBWbBiG8iBkHEYh7w8UERN%2BeZ1n4iZwXWfZsWvAsllo6RvNvHZCVC0THAYMrpNC6j4WY%2BRnxUGoWx4h-evi6T3N6d6Pt03KcIy%2BEPEQDUeJNPjhGm9LnUCGAAx%2BiSAyIXBLQgA"
      target="_blank"
    />
  </TabItem>
</Tabs>

<Aside>The benefit of using TypeGPU may not be very obvious yet. Sure we lost some lines of code - but is it worth it? Let's keep going!</Aside>

## Let's add some parametrization!

There is nothing wrong with a simple static triangle, but let's make it a *bit more interesting* by adding some parameters to our shader.
We will add x and y position buffers and a rotation buffer that will let us move the triangle around! Now isn't that **awesome**?

#### But first let's upgrade our program a little.

Currently the verices are hardcoded in the shader.

```wgsl
var verticies = array<vec2f, 3>(
  vec2(0.0, 0.5),
  vec2(-0.5, -0.5),
  vec2(0.5, -0.5)
);

let pos = vec4f(verticies[${builtin.vertexIndex}], 0.0, 1.0);
```

That is certainly not the best way to do it. Let's create a vertex buffer that stores the coordinates and use it in the shader.

```ts
import { vec2f, arrayOf } from 'typegpu/data';

const triangleVertex = wgsl
  .buffer(arrayOf(vec2f, 3), [
    [0.0, 0.5],
    [-0.5, -0.5],
    [0.5, -0.5],
  ])
  .$allowVertex('vertex');
```
<Aside type="tip">
You can also pass `'instance'` into the `$allowVertex()` method. This will change the way the values are read.
</Aside>

Now we can use the buffer in the shader.

<Tabs>
  <TabItem label="Before">
    ```ts
    const vertexCode = wgsl`
      var verticies = array<vec2f, 3>(
        vec2(0.0, 0.5),
        vec2(-0.5, -0.5),
        vec2(0.5, -0.5)
      );

      let pos = vec4f(verticies[${builtin.vertexIndex}], 0.0, 1.0);
    `;
    ```
  </TabItem>
  <TabItem label="After">
    ```ts
    const vertexCode = wgsl`
      let pos = vec4f(${triangleVertex.asVertex()}, 0.0, 1.0);
    `;
    ```
    <Aside title="Thats it!">TypeGPU will take care of the rest.</Aside>
  </TabItem>
</Tabs>

Great! Now that we have that out of the way, let's add some parameters to our shader. Here is the game plan:

import { Steps } from '@astrojs/starlight/components';

<Steps>

1. Create the parameters:

   ```ts
   import { addSliderParam } from '@typegpu/example-toolkit';

   const params = {
     rotation: addSliderParam('rotation (rad)', 0, {
       min: 0,
       max: 3.14 * 2,
       step: 0.1,
     }),
     x: addSliderParam('x', 0, {
       min: -1,
       max: 1,
       step: 0.1,
     }),
     y: addSliderParam('y', 0, {
       min: -1,
       max: 1,
       step: 0.1,
     }),
   };
   ```

2. Create the buffers:

   ```ts
   import { f32 } from 'typegpu/data';

   const rotationBuffer = wgsl.buffer(f32, params.rotation).$allowUniform();
   const xBuffer = wgsl.buffer(f32, params.x).$allowUniform();
   const yBuffer = wgsl.buffer(f32, params.y).$allowUniform();
   ```

3. Prepare a helper function to rotate the triangle:

   ```ts
   const rotate = wgsl.fn`(v: vec2f, angle: f32) -> vec2f {
     let pos = vec2(
       (v.x * cos(angle)) - (v.y * sin(angle)),
       (v.x * sin(angle)) + (v.y * cos(angle))
     );
     return pos;
   }`;
   ```

4. Use the buffers inside the shader code:

   ```ts
   const vertexCode = wgsl`
    let rotated = ${rotate}(
      ${triangleVertex.asVertex('readonly_storage')},
      ${rotationBuffer.asUniform()}
    );

    let offset = vec2f(
      ${xBuffer.asUniform()},
      ${yBuffer.asUniform()}
    );

    let pos = vec4f(rotated + offset, 0.0, 1.0);
   `;
   ```

4. Voilà! You have a movable and rotatable triangle!

</Steps>
<Aside type="tip">
Remember that there are many ways to achieve the same result.
This is just one of them. Having three separate buffers for x, y, and rotation may not be the most efficient way to do it.
You can experiment with different approaches to find the one that suits your needs best.
</Aside>

#### Let's compare TypeGPU to WebGPU again:

<Tabs>
  <TabItem label="TypeGPU">
    ```ts
    import { wgsl, createRuntime, builtin } from 'typegpu';
    import { f32, vec2f, arrayOf } from 'typegpu/data';
    import { addElement, onFrame, addSliderParam } from '@typegpu/example-toolkit';

    const runtime = await createRuntime();
    const device = runtime.device;

    const canvas = await addElement('canvas', { aspectRatio: 1 });
    const context = canvas.getContext('webgpu') as GPUCanvasContext;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'premultiplied',
    });

    const params = {
      rotation: addSliderParam('rotation (rad)', 0, {
        min: 0,
        max: 3.14 * 2,
        step: 0.1,
      }),
      x: addSliderParam('x', 0, {
        min: -1,
        max: 1,
        step: 0.1,
      }),
      y: addSliderParam('y', 0, {
        min: -1,
        max: 1,
        step: 0.1,
      }),
    };

    const rotationBuffer = wgsl.buffer(f32, params.rotation).$allowUniform();
    const xBuffer = wgsl.buffer(f32, params.x).$allowUniform();
    const yBuffer = wgsl.buffer(f32, params.y).$allowUniform();

    const triangleVertex = wgsl
      .buffer(arrayOf(vec2f, 3), [
        [0.0, 0.5],
        [-0.5, -0.5],
        [0.5, -0.5],
      ])
      .$allowVertex('vertex');

    const rotate = wgsl.fn`(v: vec2f, angle: f32) -> vec2f {
      let pos = vec2(
        (v.x * cos(angle)) - (v.y * sin(angle)),
        (v.x * sin(angle)) + (v.y * cos(angle))
      );
      return pos;
    }`;

    const pipeline = runtime.makeRenderPipeline({
      vertex: {
        code: wgsl`
          let rotated = ${rotate}(
            ${triangleVertex.asVertex()},
            ${rotationBuffer.asUniform()}
          );

          let offset = vec2f(
            ${xBuffer.asUniform()},
            ${yBuffer.asUniform()}
          );

          let pos = vec4f(rotated + offset, 0.0, 1.0);
        `,
        output: {
          [builtin.position]: 'pos',
        },
      },
      fragment: {
        code: wgsl`
          return vec4(0.7686, 0.3922, 1., 1.0);
        `,
        target: [
          {
            format: presentationFormat,
          },
        ],
      },
      primitive: {
        topology: 'triangle-list',
      },
    });

    onFrame(() => {
      pipeline.execute({
        colorAttachments: [
          {
            view: context.getCurrentTexture().createView(),
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
        vertexCount: 3,
      });

      runtime.flush();
    });

    ```
    <LinkCard
      title="Run it in the playground!"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgdwOYGcA2AaOBjKAUwEMZCAlAVwDsZRDcAjS4TO6uAXzgDMoIQcAOQwAnmEKowlIQG4AUKEixEvAMwAmXADdCeDT1zEoUYqIDyPLr36CR4ydID0AE1LE5i8NHhJiLlwBRTEIQQlpcCGoAMVMwowCAZUxgF0IoAAVjYkFuPgFhAAExCSlKJ0IADxywEIBaGAgITABrYBhPeTwo9HgoGjowuABeOGJkYnb8IlIKAfoACgBKBW7qXrg07WA8QhG4ftp6ADotncIFLp74PGJqbWJ0ffHJ%2BH8gkLDaBaFb%2B8ehLg-OgJHgYORSMAIAAuOAARi4Kyu6xuUTIlXgoz%2BD3Qx1QhBgAGE0VUYD9kIRGGUhEsxk8AOIZACqhLuOOJtFJq2ucDARHQ4RgkKi0WgIFI%2B2oxG2qFI0Dx0jxBIyRB46SILlZ-3Qoqg4rJSOR6JgxzWPGAqEoRAWCHkcE2hG2u2wdt4YtIsL5hAFtGFMXdMBd9uImDAAAtiABZCBpWFCL0gShsYC1YCEFyA%2BScQ1rDZgbIgJ6jW32-hCuhRWHvZKpdJZOI-Mt%2BuALUwuJaAuAABiBrvtIGA1FhPb7cHFlVhamOcIALHAAFRwLSj3qEMDD6dBxFbidjJIpNKZAs-SqdnuIUcDodwOpwrf94i7u8rsjr7ub13ZreiKv72tHhshFEM9e3tftB1hW97zHR9YWfMC4FXN8uw-e0vyzS5cz6CByyhagACFKB4NUoH2NAsGOZhiPSBYeE0XB8ziXEmwraglmOAASENMAgZAmWoYAeDFZZuRROBKkI6jSNGcjMEooiSNo%2BjeQLXFKnYrjMB4viBKEvURORDZREkkiyIwOSqMUuitBUpjjlEDTuN4-jBOEnMeRgKBgDuVAQgANXSdEzKwV15KkhZjFMCweAWXR9EMOA1CWXAAG1RxSlDzxQgBWABdaCUrqHLcCK448oK4qbxy-LXVypZQs07SAtgKofl0FrT3csSWL2GTzOOHhqAAA1i2E4oMIxqF8whYWs2k6gAPjgcarBLOAQngSAi2WvQNAWUdYuOSoF3wCB0AiqaQiWeaW20eyTvQQcLum67oMO47F0e6hnqu2kAGpbvuxdunOnzftdJFSwJK0OC2hROCGzCeTAFNCBSaheoOeYwmOcUWgocJDwyVH0cIG1XXa9FYTW%2B1uljFBzKG0d7Q2g4cNmFx9g4hAes4faEIQ7nPO8y7CGa9FjkecXWqWThoMFnn2dYkz0kl9AXL0kBlk4Zm4ENAX1oJOAIGIgVMR2%2BL%2BYNuBuYkhTVceDW3Ll3X7W54z7agNWnf02Xdf1gXWa2-Y4pnGKes5gGTZ4M3cEy3A4WOLtIbAoboIgSgYGkGBqd1lLmFYdhji29o8NyuMtszBCXbQrc%2BGIVAvhzi8ELpmaGawJmDaIGAYYtmcFhQgB2AA2AAOEe4%2BONQAE4NBsxOE6TlP7TT0chSgfFm7Sg2aYFzWPV5flBT9XV9XlrhoJq2vXT5UBS90XOEMaSAeNQH9hGFsHCDqFJeiry%2BWZDQijiGTZYIwlprRRhIUmxwqh6EzmTPe3QeJQAAIIwCFHgMMTd0Cwh3gLPeCFtiEGQLCNYxolREitEQWgAAVUkVoybsQICQMgfk0zIGWBfWmIRjB%2BRDJQduGU46iO7Nfa2PF-DmDfL8PhUAAEG16NAQgMi4zKKIIosCNcwISPtJTKoxIBiTi3NmS4pZsaEAGpgSg6AwwGTMfIIAA"
      target="_blank"
    />
  </TabItem>
  <TabItem label="WebGPU">
    ```ts
    import { addElement, onFrame, addParameter } from '@typegpu/example-toolkit';

    const adapter = await navigator.gpu?.requestAdapter();
    const device = await adapter?.requestDevice();

    if (!device) {
      throw new Error('Failed to acquire a device');
    }

    const canvas = await addElement('canvas', { aspectRatio: 1 });
    const context = canvas.getContext('webgpu') as GPUCanvasContext;
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
      alphaMode: 'premultiplied',
    });

    const triangleVertexData = new Float32Array([0.0, 0.5, -0.5, -0.5, 0.5, -0.5]);

    const triangleVertexBuffer = device.createBuffer({
      size: triangleVertexData.byteLength,
      usage: GPUBufferUsage.VERTEX,
      mappedAtCreation: true,
    });
    new Float32Array(triangleVertexBuffer.getMappedRange()).set(triangleVertexData);
    triangleVertexBuffer.unmap();

    const parametersBuffer = device.createBuffer({
      size: 4 * 3,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });

    addParameter(
      'rotation',
      {
        initial: 0,
        min: 0,
        max: 3.14 * 2,
        step: 0.1,
      },
      (value) => {
        const data = new Float32Array([value]);
        device.queue.writeBuffer(parametersBuffer, 0, data);
      },
    );

    addParameter(
      'x',
      {
        initial: 0,
        min: -1,
        max: 1,
        step: 0.1,
      },
      (value) => {
        const data = new Float32Array([value]);
        device.queue.writeBuffer(parametersBuffer, 4, data);
      },
    );

    addParameter(
      'y',
      {
        initial: 0,
        min: -1,
        max: 1,
        step: 0.1,
      },
      (value) => {
        const data = new Float32Array([value]);
        device.queue.writeBuffer(parametersBuffer, 8, data);
      },
    );

    const wgslCode = `
      fn rotate(v: vec2f, angle: f32) -> vec2f {
        let pos = vec2(
          (v.x * cos(angle)) - (v.y * sin(angle)),
          (v.x * sin(angle)) + (v.y * cos(angle))
        );
        return pos;
      };

      struct Parameters {
        rotation : f32,
        x : f32,
        y : f32,
      };

      @binding(0) @group(0) var<uniform> params : Parameters;

      struct VertexOutput {
        @builtin(position) position : vec4f
      };

      @vertex
      fn mainVert(@location(0) v: vec2f) -> VertexOutput {
        let rotated = rotate(v, params.rotation);
        let offset = vec2(params.x, params.y);

        return VertexOutput(vec4f(rotated + offset, 0.0, 1.0));
      }

      @fragment
      fn mainFrag() -> @location(0) vec4f {
        return vec4(0.7686, 0.3922, 1.0, 1.0);
      }
    `;

    const module = device.createShaderModule({
      code: wgslCode,
    });

    const pipeline = device.createRenderPipeline({
      layout: 'auto',
      vertex: {
        module: module,
        buffers: [
          {
            arrayStride: 2 * 4,
            attributes: [
              {
                shaderLocation: 0,
                offset: 0,
                format: 'float32x2',
              },
            ],
          },
        ],
      },
      fragment: {
        module: module,
        targets: [
          {
            format: presentationFormat,
          },
        ],
      },
      primitive: {
        topology: 'triangle-list',
      },
    });

    const bindGroup = device.createBindGroup({
      layout: pipeline.getBindGroupLayout(0),
      entries: [
        {
          binding: 0,
          resource: {
            buffer: parametersBuffer,
          },
        },
      ],
    });

    onFrame(() => {
      const commandEncoder = device.createCommandEncoder();
      const textureView = context.getCurrentTexture().createView();

      const renderPassDescriptor: GPURenderPassDescriptor = {
        colorAttachments: [
          {
            view: textureView,
            clearValue: [0, 0, 0, 0],
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
      };

      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.setVertexBuffer(0, triangleVertexBuffer);
      passEncoder.setBindGroup(0, bindGroup);
      passEncoder.draw(3);
      passEncoder.end();

      device.queue.submit([commandEncoder.finish()]);
    });
    ```
    <LinkCard
      title="Run it in the playground!"
      href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoKIBsCmIcB2MANCugArJTL4w5SkQEBi1%2BcAvnAGZQQhwA5AAEYATzA4A5mACuAehwAPGmFwBaGBAhYA1sBiCA3ACgTAYyYBneGmRg6UOAF4UAd2QG4BZADdgUshaUAB0MrIA-CFQOACOsjg2AIKo9o4AFACUppYENnCoOP7mOC7unrapDvRRMfGJMAAiRcAlWaYmwNxw6QCEhcU4mYgmcHAwABZ8bt44MxhQfFDpgsyeuKjjECjm8cAxKAUtJYLZJhxmufnmyAS%2ByFZlyB5eaJi4%2BEQrN3cPgqRIB6ScwwABKQWAEAAXHAAIycM5XeC5OhKeCuH73KxhHAwADCTFRMBWbhwACNwqcUI8AOLkACqeNuWIJRGUMBy1ngYBiVkIMAhTGY0BAQTKPn8gWCYTkOJg5Bi3HoMVQTN%2BVmFUFFxLOFkJ7JCuW4AVkMXSCFGR0GxEt3BFQRhPMS-MFLHtJEtyCwYAmyAAshBCjDBE6QLIsDBgGpgDhUP9zrqkeMoMBblJcAA1eioxpBZDiuZwZhYCBBADMACYkotkGJ0gBtAAMIUbpGbAFZSOoO12e3A%2B92Qu2ALqJrnJ1MEdM4LOwZQAIVk3CVTlcA1aOENMSCOEXy-o5stVmAAC8cDCYCm05ns8pcwKQmSxHQADKEKSTG1jWRWZBSc9wHS9J7iu9K-v%2BIQZhgoIACoYAAGl%2BcCimAkioEk%2BLbpGTAXlACQ2hwZwEIWxaljAlbVtQdaXpO06zqiIH0HKfr2Gh4JTjgWSZCEfLEjR14zreSj3sgZz8VON5zkojGhLIBAoe0lzjmAVA0Li9BWDJZTriUW44DuMmHmMx5njCAAscAAFRwGWSE-n%2BAFATJYEOSE9IAHIAJLMAA8qCfpwAAPoBDLOeBm54j55AAJoAPqNAAyjBBG6m8lBsOpyyWoIfACthBDxmMFpjGMwAEAYqZYDCraWmMIBldVSF1cgSgwmWISwhZ1kVk1cA2DgYDVR1SEcEh6T3FgCTDM4AB8IwlXASapAKBYzKR5ZVjWdb1hNCSjqYC06Zu9QJCEbgpnQhkqRljiaUuK5tqQy2iQdnA2qlFCqbQB7ZUohXzSVZUVV6jW1chDVwOosK9aKrVwr1-WDf2w2WqNlrjV6U0uHNxUlUtearUWJYbZRtYNrtOD7WDR0hCdm7nQYu73Qe11qbdMmkGZT15mcYxox9qDpWzP1jIIYj-bjpXlZGIP9jDENQzDLUwtDYOI0Nqt82NFPTTjYP4ytrjEWtxPkZtVHk5jlO8yVNN02dF1M-uyys99UB3c7pAABzcwKNv8x0SZuFIVhYAShRlAABraBBwLlO7jTCvg4OYFbcKQAkwtwlbDOoc3J6n3SS3AuDchAjyuAXFbpGDYzjSEShWYt5fpAJmS5z0vghGITfHgQrcSUMmS9XXXeN9ZfcD9O7dwAA1J33dN5YVhT7g7dgzbYwxDApqx5AVivRwHTGZesggnAQtu48xfx-lcBZ5WvWNw-PVgz3L8jcfcDCGSZWoGVUh0iNmGMIKQfBZBgCAcMe4UAAA8ckugijmq7R4MJL6ZQPmYE%2BeFz70WUD5WQMA5DwGLj-WQwAIxlXSPvCqTBhg0LvknFOZluCoy-sIZOUkY7IU8AQei6RhAlhuPlKBcBfBMMLrnOaeClAEKIYQgGYxS5xwgHlWMZRb6cV8KQFB0RVGuk3iXXEcAIDLl4mUKu1CvrYiUDo6x3ddQLW3rvOAMi5HEPGsw7g6RNGbHnqY7gvE2wtlILCFs7dD5YO-rwP8nwYDcNFGVVgf4siQzmoIiAwjIT92AWIrxii464hcQXMyQCQgAHYABsXtKnBLLAATgrD1OEISWnAMiZHQO44QCBnDKUNcxxNzmCwjgBKvpChQADKgPpRlm5BjgMHUO4ccApS6XkbkUYcBYDKv0q0G49I7lBIQCZ5BNnbOIrMrAtYICEODMgQhEB-qcNRDCYuPTpm4BhO8vpvUyTM3djCestcCkLSoFRBKNF5kViblzYFYwgg0T%2BXQKwgK4UlWLgtBaVhxn0BfJk10oNMVEpMWY3EhLiULTtFqB0QhuCm0rEoCs-0KVowpcOEeb0wbstRkhGJUg4mvLBt8z5yFem4F6gKKA-4YAorgEColGKSpUu1I6XkLp8qam1By1lJVuVa0tDyUAFVk6CoWloSAJYpBiGDOJac6htk2H%2BmjQiaz8i-wIKgGk4CwDaUGQcy6f8vU3MgbjK5YgbkwEdGcnZcp5yBu9S%2Ba5hCoFIX5CmRIqKFqKvdf-Kc5KnGJBuVAEopriV-Odo6L6GCObAp1fqsY3KXVmCFBldIqTZoAyTJYEAooPUYAIJYCZvrBj%2BpwASHttxMADsDAeG2SYiSmhnDGGYGJ9RojlHiU0MQiAwXZIurIo6MzLsUpaJM26TkPCsM0KwwyozBBhEBI5Hr6CUCsFexIt6HDQDKMXSwJYoAYQFOYCYcTZXysxYqsY-g5gXj3TEI9cwOVjHMLgKgGYraAtbHLbDjY9XEuJqgHySNBAof0lAZlmKbDQBwER4MVGYgUfrbqz%2BUSkwqTff2wd9Ayjdt7VOrjoQyTSDKk%2Bi9b6fHHJfZe69n7gg23Y1YTjM7Qi8VOZIc5nEwDRuIvJy9SmJk8VxDIwyWHbWSQYv83THHp0Gd4nGj1QaIFANIDmxzYArOKZs0xVA1A3DpDLB5-TTFjknrGHbBIp0rCyDJPVYk9ZeOTqC6EY05VsVZCpk2oAA"
      target="_blank"
    />
  </TabItem>
</Tabs>

## Let's create some more triangles

Now that we have a single movable triangle, let's create him some friends. But first let's upgrade our program a little.
At the moment the size of our triangle is defined by the values written to the buffer at its creation. That's ok but let's make it a little more convenient by extracting it to a variable. We should also make it a little smaller so that we can fit more triangles on the screen.

<Tabs>
  <TabItem label='Before'>
  ```ts
  const triangleVertex = wgsl
    .buffer(arrayOf(vec2f, 3), [
      [0.0, 0.5],
      [-0.5, -0.5],
      [0.5, -0.5],
    ])
    .$allowVertex('vertex');
  ```
  </TabItem>
  <TabItem label='After'>
  ```ts
  const triangleSize = 0.2;
  const triangleVertex = wgsl
    .buffer(arrayOf(vec2f, 3), [
      [0.0, triangleSize],
      [-triangleSize, -triangleSize],
      [triangleSize, -triangleSize],
    ])
    .$allowVertex('vertex');
  ```
  </TabItem>
</Tabs>

As for the triangles, we will need to create a buffer containing the positions and rotations of each triangle. We will also need to update the vertex shader to use these values. There are two different approaches - each with its own pros and cons. We can either create another vertex
buffer (this time using the 'instance' version) or we can use a uniform/storage buffer. Let's explore both options.

<Tabs>
  <TabItem label='Instance vertex buffer'>
  ```ts
  const triangleAmount = 10;
  const trianglePos = wgsl
    .buffer(arrayOf(vec3f, triangleAmount))
    .$allowVertex('instance');
  ```

  One potential downside of this approach is that the data type of the buffer is limited to scalar types. This means that our data type can't be a struct, which could possibly make our code less readable.

  ```diff
  const vertexCode =  wgsl`
+  let instanceInfo = ${trianglePos.asVertex()};
    let rotated = ${rotate}(
      ${triangleVertex.asVertex()},
-    ${rotationBuffer.asUniform()}
+    instanceInfo[2]
    );
    );

    let offset = vec2f(
-    ${xBuffer.asUniform()},
-    ${yBuffer.asUniform()}
+    instanceInfo[0],
+    instanceInfo[1]
    );

    let pos = vec4f(rotated + offset, 0.0, 1.0);
  `;
  ```
  <Aside type='tip'>
    In the above code we extracted `trianglePos` to a `instanceInfo` variable. This is not necessary as each call to `trianglePos.asVertex()` will return the same value. `${trianglePos.asVertex()}[x]` is equivalent to `instanceInfo[x]` in this case.
  </Aside>
  As we are using a vertex buffer, we don't need to index into the buffer data in the vertex shader. One downside of this approach is that
  we need to know which variable is at which index in the vector. This can be a little confusing and less readable than using a struct.
  Lastly, we need to provide our render pipeline with the number of instances we want to render.

  ```diff
  onFrame(() => {
    pipeline.execute({
      colorAttachments: [
        {
          view: context.getCurrentTexture().createView(),
          clearValue: [0, 0, 0, 0],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
      vertexCount: 3,
+    instanceCount: triangleAmount,
    });

    runtime.flush();
  });
  ```
  </TabItem>
  <TabItem label='Uniform buffer'>
  ```ts
  const triangleAmount = 10;
  const trianglePos = wgsl
    .buffer(
      arrayOf(
        struct({
          x: f32,
          y: f32,
          rotation: f32,
        }),
        triangleAmount,
      ),
    )
    .$allowReadonlyStorage();
  ```
  This time we are using a buffer of structs. This makes our code a little more readable as we can access the data using the struct fields.
  We are using a readonly storage buffer as the current alignement of the data in the buffer is 12 bytes. This is not a multiple of 16 bytes which is required for a uniform buffer. We could also pad the struct to make it 16 bytes but let's stick to readonly storage for now.

  ```diff
  const vertexCode =  wgsl`
+  let instanceInfo = ${trianglePos.asReadOnlyStorage()}[${builtin.instanceIndex}];
    let rotated = ${rotate}(
      ${triangleVertex.asVertex()},
-    ${rotationBuffer.asUniform()}
+    instanceInfo.rotation
    );
    );

    let offset = vec2f(
-    ${xBuffer.asUniform()},
-    ${yBuffer.asUniform()}
+    instanceInfo.x,
+    instanceInfo.y
    );

    let pos = vec4f(rotated + offset, 0.0, 1.0);
  `;
  ```
  In the vertex shader we need to index into the buffer data using the `builtin.instanceIndex` variable. This variable will contain the index of the current instance being rendered. This step was not necessary when using a vertex buffer as the data was already indexed for us. Lastly, we need to provide our render pipeline with the number of instances we want to render (just like in the other approach).

  ```diff
  onFrame(() => {
    pipeline.execute({
      colorAttachments: [
        {
          view: context.getCurrentTexture().createView(),
          clearValue: [0, 0, 0, 0],
          loadOp: 'clear',
          storeOp: 'store',
        },
      ],
      vertexCount: 3,
+    instanceCount: triangleAmount,
    });

    runtime.flush();
  });
  ```

  </TabItem>
</Tabs>

In the rest of this guide we will assume the use of the storage buffer approach. If you prefer the vertex buffer approach, you can try to adapt the code to use that instead.
#### Initializing the buffer
Since we have no initial values for the buffer, we will create a helper function that fills the buffer with random values.

```ts
function randomizeTriangles() {
  const positions = [];
  for (let i = 0; i < triangleAmount; i++) {
    const x = Math.random() * 2 - 1;
    const y = Math.random() * 2 - 1;
    const rotation = Math.random() * Math.PI * 2;
    positions.push({ x, y, rotation });
  }
  runtime.writeBuffer(trianglePos, positions);
}
```
<Aside type='tip'>
  If you went with the vertex buffer approach, remember to have the correct data type when writing to the buffer. The writeBuffer function will hint at the correct data type for you.
</Aside>

We will call this function before the first frame is rendered to ensure that the buffer is initialized with random values. Let's also add a button that will call this function when clicked.

```ts
addButton('Randomize', randomizeTriangles);
```

```diff
+randomizeTriangles();
onFrame(() => {
  pipeline.execute({
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: [0, 0, 0, 0],
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
    vertexCount: 3,
    instanceCount: triangleAmount,
  });

  runtime.flush();
});
```

<LinkCard
  title="Run it in the playground!"
  href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoEIFcYwgOwBoV0BRAGwFMRL8ZiCAxKZGuAXzgDMoIQ4A5AAEYATzCUA5mCwB6SgA9WYKgFo8EcgGtgMAQG4AUKEixEcAEZZg5GMCJwAxlErIYlAEpY6oSsQDukgDO5BzcvPwCYhLSWAbG4NDwSMhQLKIA8lzEXADMAEzEQTBQWI70cABulI752VU1uVxhPHyC0VIysqhuyPGGjgTFcKU%2BbAC8KP7Iuk4ubp7edjQAFACURoP4w6iUlcCOlHCTo8uUAHS7%2B4dGA0Pwjsj4lchBx1Mz8GioFNS0MCsBI9nq8BMQUkEJOUPG5gBAAFxwACMHA2d22DwI7gU8EmwJeQXOkkoMAAwljFACBP5KBZYgI1ig3gBxAAKAFVSU8CeS6JTNvc4GAXEF-rCmNAQG53vhkPtJG5oESZESSayXFxKGlKKguSCgoxJW51rcttiYOctlxgJIsC4VghDHA4FcDn4ndwjTBEcLKKK6OL8IaoFL6B7kOQwAALZAAWQgu0RAl9ICwtmAKmAOrBhnYaMM32wuAIgJh%2BFQfGAAC9KGCRk8KyBq5QACpQYBPSRUIL5rbDEod-BdygAZWb7wADOd8gKMXAB52qAA1LXY96BEIe85WLiaqArVLpLIraq1eq5NbEADaHudV6nE%2BIC6HVDHNYAuoRb3Ar%2Bp24vR2bYg-0HYc30oT9vyvZ8wKAuAQIA8DIOdd81i3AASCNyAgfwV1gRRAWqfCFAZU1BRgqgAEEQAgJZ3iRCdZ37f8X0oVkIDeSYN3ILcdz3FZv0PZBMi4ATnXEuBilKcoHW-CSFERPJCjk8TREUgovwkiTeBgQN1OUrTUU0rSKMoajaLoYznUvD00Odc5MPIbD-A8VwK3wchRBHPAWGJE1DEMLhvHKOF8HrctKxrNtQO7dZEA9Pt4EgIJdFCzif3fIxnS4aA4BWKh4GASd9DgIqAB55xY4dzKWErgAAanqxlHQkxK4AUd5YzcKNzhYCKQDigAqOB8ng5EsvEtrRE67reobPghpGsakQm502p0wMZpgHq%2BsbRauu285WQASTgYaZ2-ZLUqGc4ZCCKMHXa4hRGIDa7AIVEJvYD1Tl8c5-HbdxsF3LUVlM9igmIK73u2NFvvRYY3qOLjgnIc4uHwAADE9EVPOpiAA-TGVUAA%2BBoz3i50CqFDj3jxsTxJPc4OuGwYggPVi1mJvLKnOabhpS-AOeHLmrJ55mzsk%2BxhaoLm4Hq8X%2BacDiZcoLnbImlwYDtMLkqMdhMbIucwAzShyHsZGRiWP6pS0TxaF2KBWVN838EoWTnSI7FERayaE0oRFuMxlTqfsYonkOY78By950IQcGOPOV5XLQAhPO86BkD8tZ2CvOOrBsOx8HOMPdPwSPy0UdhMpDkkRggXT3FQWOECR9gGcMuPTLw7Ek6CHuCJzsWJNLiPKCjnLeobwMVPzQzqYgXdRVxcm6g7rTR-L8fo4gZnh-EzeK8n0RZ9uee6%2BSumagAFlEpHm4VxeuGX4gH2IJFzgnNEJMxsXaJgGQ3pKZaSvAXdMxdoahXfEmZKOYJLsGMggj0PAs40DoD7b8gxExwCDipLWOtybXxWFOAA7AANgABxkNfucXIABOfIhRkTnHfp-b%2B4lf7fl0lAYkQCbyGV9oZHKIY3A%2BhFGKGGwZQz7yQRJZCHBjLClAKlaoGCJJ4EgNhSQal2hVTUObYocCFG5nzLtSKrY9F%2Bn8kwFgqw4rjDJr7E2EhXYXEUDUHA7tBHK2wlASiuBkCOCjGgmAQRET8K0t4iS%2BxKD%2BERGaSkqoyR2hcHQFslI7TuzWJaeY7glxZn8Osfea0qCpCXBGLAAcfyPjgDUup8j54QDQBkMASZHClKgEYwyxRoCUBaUmHpLguniVkeJBpDRiLkiWIiXIYtD6UCmegyqMUzI0SWIgueVsxgXC4OQLA91-J5iMEAA"
  target="_blank"
/>

Great! But now we have a little problem. When we had just one triangle, we could easily see the triangles. But now, with multiple triangles, it's hard to see the individual triangles. Let's add a gradient color to each triangle to make them more distinguishable.

<Steps>

1. Add additional output to the vertex shader that will represent the UV coordinates inside the triangle:

   ```diff
   output: {
     [builtin.position]: 'pos',
   +  fragUV: vec2f,
    },
   ```

2. Create the UV coordinates inside the vertex shader:

   ```diff
   const vertexCode = wgsl`
     let instanceInfo = ${trianglePos.asReadonlyStorage()}[${builtin.instanceIndex}];
     let rotated = ${rotate}(
       ${triangleVertex.asVertex()},
       instanceInfo.rotation
     );

     let offset = vec2f(
       instanceInfo.x,
       instanceInfo.y
     );

     let pos = vec4f(rotated + offset, 0.0, 1.0);
   +  let fragUV = (rotated + vec2f(${triangleSize}, ${triangleSize})) / vec2f(${triangleSize} * 2.0);
   `;
   ```
   To calculate the UV coordinates, first we add a vector of the triangle size to the rotated postion to get rid of the negative values. Then we divide the result by the size of the triangle multiplied by 2 to get the UV coordinates.

3. Update the fragment shader:

   ```ts
   const fragCode = wgsl`
     let color1 = vec3(196.0 / 255.0, 100.0 / 255.0, 255.0 / 255.0);
     let color2 = vec3(29.0 / 255.0, 114.0 / 255.0, 240.0 / 255.0);

     let dist = length(fragUV - vec2(0.5, 0.5));

     let color = mix(color1, color2, dist);

     return vec4(color, 1.0);
   `;
   ```
   <Aside>
    Notice that we can just use `fragUV` directly in the fragment shader. This is because the `fragUV` value was present in the vertex shader output. TypeGPU will automatically pass this value to the fragment shader.
   </Aside>
   First, we define two colors. Then we calculate the distance from the center of the triangle to the current fragment. We use this distance to mix the two colors. The closer the fragment is to the center, the closer the color will be to `color1`. The further the fragment is from the center, the closer the color will be to `color2`. This way we get a nice radial gradient.

</Steps>

<Aside type="tip">
  The proposed solution is totally arbitrary. Feel free to experiment with different ways to color the your triangles!
</Aside>

<LinkCard
  title="Run it in the playground!"
  href="/examples#example=playground__JYWwDg9gTgLgBAbzgQwCaoEIFcYwgOwBoV0BRAGwFMRL8ZiCAxKZGuAXzgDMoIQ4A5AAEYATzCUA5mCwB6SgA9WYKgFo8EcgGtgMAQG4AUKEixEcAEZZg5GMCJwAxlErIYlAEpY6oSsQDukgDO5BzcvPwCYhLSWAbG4NDwSMhQLKIA8lzEXADMAEzEQTBQWI70cABulI752VU1uVxhPHyC0VIysqhuyPGGjgTFcKU%2BbAC8KP7Iuk4ubp7edjQAFACURoP4w6iUlcCOlHCTo8uUAHS7%2B4dGA0Pwjsj4lchBx1Mz8GioFNS0MCsBI9nq8BMQUkEJOUPG5gBAAFxwACMHA2d22DwI7gU8EmwJeQXOkkoMAAwljFACBP5KBZYgI1ig3gBxAAKAFVSU8CeS6JTNvc4GAXEF-rCmNAQG53vhkPtJG5oESZESSayXFxKGlKKguSCgoxJW51rcttiYOctlxgJIsC4VghDHA4FcDn4ndwjTBEcLKKK6OL8IaoFL6B7kOQwAALZAAWQgu0RAl9ICwtmAKmAOrBhnYaMM32wuAIgJh%2BFQfGAAC9KGCRk8KyBq5QACpQYBPSRUIL5rbDEod-BdygAZWb7wADOd8gKMXAB52qAA1LXY96BEIe85WLiaqArVLpLIraq1eq5NbEADaHudV6nE%2BIC6HVDHNYAuoRb3Ar%2Bp24vR2bYg-0HYc30oT9vyvZ8wKAuAQIA8DIOdd81i3AASCNyAgfwV1gRRAWqfCFAZU1BRgqgAEEQAgJZ3iRCdZ37f8X0oVkIDeSYN3ILcdz3FZv0PZBMi4ATnXEuBilKcoHW-CSFERPJCjk8TREUgovwkiTeBgQN1OUrTUU0rSKMoajaLoYznUvD00Odc5MPIbD-A8VwK3wchRBHPAWGJE1DEMLhvHKOF8HrctKxrNtQO7dZEA9Pt4EgIJdFCzif3fIxnS4aA4BWKh4GASd9DgIqAB55xY4dzKWErgAAanqxlHQkxK4AUd5YzcKNzhYCKQDigAqOB8ng5EsvEtrRE67reobPghpGsakQm502p0wMZpgHq%2BsbRauu285WQASTgYaZ2-ZLUqGc4ZCCKMHXa4hRGIDa7AIVEJvYD1Tl8c5-HbdxsF3LUVlM9igmIK73u2NFvvRYY3qOLjgnIc4uHwAADE9EVPOpiAA-TGVUAA%2BBoz3i50CqFDj3jxsTxJPc4OuGwYggPVi1mJvLKnOabhpS-AOeHLmrJ55mzsk%2BxhaoLm4Hq8X%2BacDiZcoLnbImlwYDtMLkqMdhMbIucwAzShyHsZGRiWP6pS0TxaF2KBWVN838EoWTnSI7FERayaE0oRFuMxlTqfsYonkOY78By950IQcGOPOV5XLQAhPO86BkD8tZ2CvOOrBsOx8HOMPdPwSPy0UdhMpDkkRggXT3FQWOECR9gGcMuPTLw7Ek6CHuCJzsWJNLiPKCjnLeobwMVPzQzqYgXdRVxcm6g7rTR-L8fo4gZnh-EzeK8n0RZ9uee6%2BSumagAFlEpHm4VxeuGX4gH2IJFzgnNFz-gHgs-ZJc7wVj33lqvUSXcqqvmbOwYgECYqARrHmRksgwErDgYhaBkt8if2-uJTGYtaIwBkN6SmWkrwF3TMXaGoV3xJmSjmQyf9JAANxjUfG34YEek4dlXyNA6A%2B2-IMRMcAg610xNhKAKJJinlyCsJEABOAAbJ-OAKD8gAFZ1Gf3fhOB8qiRqaO0QYrRE59EaJMbgiS1NBgSNGtIxoKx8jyJUWowxj5kRImvi44xRj8jXz0a4ixZ8tLU1QMAYYkwqBDm2isJhACxr0ynOo1%2B5x1Fc2CVYuuNjcqTCbAoFY2TJHEEKYUF04SYBzy0lrHW5Nr4FM0NAd%2BODVpwHwd%2BXSUBiQkJvIZX2jCvQ%2BhFGKGGwZQz724eJZCHBjLClAKlaoAiJJ4EgNhSQal2iQMoKoc2xQGHTNzPmXakVWybPZmiJgLBVhxXGGTX2JsJCuwuIoGoOB3Z9OVhIyiuBkCOCjHwmAQREQ9K0u8iS%2BxKD%2BERGaSkqoyR2hcHQFslI7TuzWJaeY7glxZn8Osfea0qCpCXBGLAAcfzuPJa-KZ88IBoAyGAJMjgCVQD2YZYo0BKB0qTGylwLLxITJQmLL2ihyRLERLkMWh9KAiv4ZVeBNVLJcMqb9Gg6NyBYHuv5PMRggA"
  target="_blank"
/>
