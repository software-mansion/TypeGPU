---
title: Data Schemas
---

As you might have noticed by now, TypeGPU uses data schemas like `d.u32` or `d.vec3f` in quite a lot of places, like buffer or function definitions.

GPU programs usually involve sharing data between the host (CPU) and the device (GPU).
In the case of WebGPU, even though data is strongly typed in WGSL shaders, the communication between JavaScript and WGSL involves reading raw bytes from buffers.
Any misalignments or misinterpretations of data can lead to faulty code that is hard to debug (no `console.log()` on the GPU, I am afraid).
This is precisely what TypeGPU data schemas help with.

:::note
Complex data types such as structs require particular byte alignment and padding between fields. TypeGPU does this automatically when transforming JS values into binary.
:::

## Examples

Let's look at some examples of defining a custom compound data type using the `typegpu/data` module. 

```ts twoslash
import * as d from 'typegpu/data';

const Circle = d.struct({
  centerPos: d.vec3i,
  radius: d.f32,
});

const redCircle = Circle({
  centerPos: d.vec3i(2, 4, 0),
  radius: 0.2,
});
```

Make no mistake, `d.vec3i` and `d.f32` are not types, but instead they are JS objects describing WGSL types, just like the `Circle` schema we just created.

If you're familiar with [Zod](https://zod.dev/), then this style of schema definitions may already seem familiar.
By defining the `Circle` struct in TypeScript via TypeGPU, in a similar way to how we would in WGSL, we gain access to its TypeScript type
definition, which we can use to validate our data values. When reading from or writing data to the GPU, the type of the JavaScript value
is inferred automatically, and it's enforced by TypeScript. 

```ts twoslash
// @errors: 2740 2322 2339 2345

import * as d from 'typegpu/data';

const Circle = d.struct({
  centerPos: d.vec3i,
  radius: d.f32,
});

// ---cut---
const redCircle1 = Circle({
  centerPos: d.vec2i(2, 4), 
  radius: 0.2,
});

const redCircle2 = Circle({
  centerPos: d.vec3i(2, 4, 0), 
  radius: "0.2",
});

const redCircle3 = Circle({
  centerPos: d.vec3i(2, 4, 0), 
});

const diam = redCircle1.rad * 2;
```

Defined data structures automatically measure and hold information about their memory layout parameters, which is useful for writing to and reading data from the GPU.

```ts twoslash
import * as d from 'typegpu/data';

const Circle = d.struct({
  centerPos: d.vec3i,
  radius: d.f32,
});

type Circle = d.Infer<typeof Circle>;

// ---cut---
d.sizeOf(Circle) // 16
d.alignmentOf(Circle) // 16
```

TypeGPU data types are essential for the library's automated data marshalling capabilities.

:::tip
If you wish to extract the JS type equivalent of a TypeGPU schema, you can do so with `d.Infer`:
```ts twoslash
import * as d from 'typegpu/data';
import { sizeOf, alignmentOf } from 'typegpu/data';

const Circle = d.struct({
  centerPos: d.vec3i,
  radius: d.f32,
});
// ---cut---
type u32 = d.Infer<typeof d.u32>;
//   ^?
type Circle = d.Infer<typeof Circle>;
//   ^?
```

:::

## Scalars, vectors and matrices

### Constructors

For scalar WGSL types `f32`, `u32`, `i32`, `f16` and `bool`, TypeGPU has `d.f32`, `d.u32`, `d.i32`, `d.f16` and `d.bool` schemas respectively.
Apart from using them to describe buffers and functions, you can also call them to cast a value to a given type. 
This works both in TGSL, as well as in plain JavaScript.

```ts twoslash
import * as d from 'typegpu/data';
// ---cut---
d.u32(31.1); // 31
d.u32(-1); // 4294967295
d.f32(true); // 1
d.i32(); // 0 (default value)
d.bool(0.01); // true 
```

:::caution
On JavaScript side, the type of any number remains a number regardless of any casts.
```ts twoslash
import * as d from 'typegpu/data';
// ---cut---
const myUnsignedInt = d.u32(1);
//    ^?
const one = d.u32(3)/d.u32(2); // 1.5
```
:::

For each of the scalar types, there is a vector schema of 2, 3 and 4 elements of that type.

For vector WGSL types `vec2f`, `vec2u`, `vec2i`, `vec2f` and `vec2<bool>`, TypeGPU has `d.vec2f`, `d.vec2u`, `d.vec2i`, `d.vec2f` and `d.vec2b` schemas respectively. Analogously for 3 and 4 components.

Just like scalar schemas, vector schemas can be called to create values of corresponding types.

```ts twoslash
import * as d from 'typegpu/data';
// ---cut---
const v1 = d.vec3f(1, 2, 3); // a vector of three elements [1, 2, 3]
//    ^?
const v2 = d.vec4f(v1.x, v1[1], 4, 5); // a vector of four elements [1, 2, 4, 5]
const v3 = v1.xy; // a vector of two elements [1, 2]
const v4 = d.vec4f(0, v3, 3); // a vector of four elements [0, 1, 2, 3]
```


:::note
Be mindful not to confuse the schema (e.g. `d.vec2f`), the schema instance (`d.vec2f(1, 2)`), the schema type (`d.Vec2f`) and the instance type (`d.v2f`).

```ts twoslash
import * as d from 'typegpu/data';
// ---cut---
const VectorSchema = d.vec2f;
//    ^?
const vectorInstance = VectorSchema(1, 2);
//    ^?
```

Matrices work in a similar way. 
For matrix WGSL types `mat2x2f`, `mat3x3f` and `mat4x4f`, TypeGPU has `d.mat2x2f`, `d.mat3x3f` and `d.mat4x4f` schemas respectively.

```ts twoslash
import * as d from 'typegpu/data';
// ---cut---
const mat1 = d.mat2x2f(); // empty matrix
//    ^?

const mat2 = d.mat3x3f(
//    ^?
  1.1, 2.5, 3.3,
  1.2, 2.6, 3.4,
  1.3, 2.7, 3.5,
);

const firstColumn = mat2.columns[0]; // d.vec3f(1.1, 2.5, 3.3)
//    ^?
```

:::tip
Performing vector and matrix math operations with TypeGPU values is possible due
to a seamless integration with `wgpu-matrix`, which you can [read more about here](/TypeGPU/integration/working-with-wgpu-matrix).
:::

### Operators

## Structs

Values of different types can be grouped into structs.

```ts twoslash
import * as d from 'typegpu/data';

const Boid = d.struct({
  position: d.vec3u,
  velocity: d.vec3f,
  color: d.vec4f,
  isActive: d.bool,
});

type Boid = d.Infer<typeof Boid>;
//   ^?

const boid: Boid = {
  position: d.vec3u(0, 0, 0),
  velocity: d.vec3f(1, 0.5, 0.5),
  color: d.vec4f(1.0, 0.2, 0.3, 1.0),
  isActive: true,
};
```

You can also use the struct schema as a constructor that type-checks the object literal and provides autocomplete.

```ts twoslash
// @noErrors
import * as d from 'typegpu/data';

const Boid = d.struct({
  position: d.vec3u,
  velocity: d.vec3f,
  color: d.vec4f,
  isActive: d.bool,
});

// ---cut---
const boid = Boid({
  position: d.vec3u(0, 0, 0),
  velocity: d.vec3f(1, 0.5, 0.5),
  color: d.vec4f(1.0, 0.2, 0.3, 1.0),
  isAct
  //   ^|
});
```

Struct schemas adjust the padding and alignment automatically, so that they comply with WebGPU's memory alignment rules.
It is also possible to override default byte alignment and size for particular fields via the `align` and `size ` functions.

```ts twoslash
import * as d from 'typegpu/data';
// ---cut---
const Boid = d.struct({
  position: d.align(32, d.vec3u), // Aligned to multiples of 32 bytes
  velocity: d.vec3f,
  color: d.vec4f,
  isActive: d.size(8, d.bool), // Has a minimum size of 8 bytes
});
```

## Arrays

To define arrays of known constant length, use the `d.arrayOf` function. It accepts as arguments the array's elements data type constructor and the length of the array.

```ts twoslash
import * as d from 'typegpu/data';

// ---cut---
const RecentResults = d.arrayOf(d.f32, 4);

type RecentResults = d.Infer<typeof RecentResults>;
//   ^?

const recentResults: RecentResults = [
  1, 0, 0.5, 20
];
```

