---
title: Bind Groups
---

:::note[Recommended reading]
We assume that you are familiar with the following concepts:
- <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html" target="_blank" rel="noopener noreferrer">WebGPU Fundamentals</a>
- <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-bind-group-layouts.html" target="_blank" rel="noopener noreferrer">Bind Group Layouts</a>
:::

A bind group is a collection of resources that are bound to a shader. These resources can be buffers, textures, or samplers.
It's a way to define what resources are available to a shader and how they are accessed.

```ts
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

// Defining the layout of resources we want the shader to
// have access to.
const fooLayout = tgpu.bindGroupLayout({
  foo: { uniform: d.vec3f },
  bar: { texture: 'float' },
});

const fooBuffer = ...;
const barTexture = ...;

// Create a bind group that can fulfill the required layout.
const fooBindGroup = fooLayout.populate({
  foo: fooBuffer,
  bar: barTexture,
});
```

In this example, we create a bind group that contains a buffer and a texture. Binding indices are determined based on the order of properties
in the layout.

:::tip
To access the entries in `fooLayout` from a shader, the corresponding WGSL code would look like this:
```wgsl
@group(...) @binding(0) var<uniform> foo: vec3f;
@group(...) @binding(1) var bar: texture_2d;
```

Where `@group(...)` would contain the group index given when creating the pipeline layout.
:::

Now, during command encoding, we can assign this bind group to a shader.

```ts
// Assuming group index is 0...
renderPass.setBindGroup(0, root.unwrap(fooBindGroup));
```

## Available resource types

:::tip
This step can be automated by using the *tgpu-gen* cli package which can generate the typed bind group layout from the shader code.
It also generates the TypeScript types for the resources, so you can use them in your code.
To learn more about the TypeGPU Generator CLI, check the [Generator CLI guide](/TypeGPU/tooling/tgpu-gen).
:::


Each property in the layout object represents a resource as seen by a shader. We recommend keeping the names of
these properties the same as the corresponding `@group(...) @binding(...) ...;` statements in WGSL.

```ts
const fooLayout = tgpu.bindGroupLayout({
  key0: { ... },
  key1: { ... },
  // ...
});
```

### Uniforms

To interpret a buffer as a uniform, create a property with the value matching:
```ts
{ uniform: d.AnyData }
```

#### Simple example
```js
// main.js
const fooLayout = tgpu.bindGroupLayout({
  luckyNumber: { uniform: d.f32 },
  // ...
});
```

```wgsl
// shader.wgsl
@group(...) @binding(0) var<uniform> luckyNumber: f32;
// ...
```


### Storage

To get readonly/mutable access to a buffer, create a property of with the value matching:
```ts
{
  storage: d.AnyData | ((n: number) => d.AnyData),
  /** @default 'readonly' */
  access?: 'readonly' | 'mutable',
}
```

#### Simple example
```ts
const fooLayout = tgpu.bindGroupLayout({
  counter: { storage: d.f32 },
  // ...
});
```

#### Runtime-sized example
Apart from being able to specify any data type, we can signal that the shader is generalized to work on
arbitrarily sized data by passing a function.

```ts
// main.ts
const Filter = (n: number) => d.struct({
  clamp: d.f32,
  values: d.arrayOf(d.f32, n),
});

const fooLayout = tgpu.bindGroupLayout({
  factors: { storage: (n) => d.arrayOf(d.f32, n) },
  filter: { storage: Filter },
  // ...
});
```

```wgsl
// shader.wgsl
struct Filter {
  clamp: f32,
  values: array<f32>;
}

@group(...) @binding(0) var<storage, read> factors: array<f32>;
@group(...) @binding(1) var<storage, read> filter: Filter;
// ...
```

### Typed Bind Groups

Once you have a typed bind group layout, you can create a typed bind group by **populating** it with the resources.
To do this, you can call the `populate` method on the bind group layout and pass the resources using an object that matches the layout.

Here is an example of how you can create a typed bind group that matches the previous example:

```ts
const bindGroup = bindGroupLayout.populate({
  buffer: buffer,
  texture: textureView,
});
```

This will create a typed bind group that contains a buffer and a texture, matching the resources expected by the shader.
If we accidentally pass the wrong type of resource, the TypeScript compiler will catch the error at compile time.
