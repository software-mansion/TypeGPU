---
title: Functions
description: A guide on how to create and use the TypeGPU typed functions.
---

:::caution[May require unplugin-typegpu]
To write TypeGPU functions in JavaScript/TypeScript, you need to install and configure [unplugin-typegpu](/TypeGPU/tooling/unplugin-typegpu).
If you're planning on only using WGSL, you can skip this step.
:::

**TypeGPU functions** let you define shader logic in a modular and type-safe way.
Their signatures are fully visible to TypeScript, enabling tooling and static checks.
Dependencies, including GPU resources or other functions, are resolved automatically, with no duplication or name clashes.
This also supports distributing shader logic across multiple modules or packages.
Imported functions from external sources are automatically resolved and embedded into the final shader when referenced.

## Defining a function

:::note[WGSL enthusiasts!]
Don't let the JavaScript scare you! TypeGPU functions can be implemented using either WGSL or JS, both being able to call one another.
If you're planning on only using WGSL, you can skip right over to [Implementing functions in WGSL](#implementing-functions-in-wgsl),
though we recommend reading through anyway.
:::

The simplest and most powerful way to define TypeGPU functions is to just place `'use gpu'` at the beginning of the function body.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';
// ---cut---
const neighborhood = (a: number, r: number) => {
  'use gpu';
  return d.vec2f(a - r, a + r);
};
```

The `'use gpu'` directive allows the function to be picked up by our dedicated build plugin -- [unplugin-typegpu](/TypeGPU/tooling/unplugin-typegpu)
and transformed into a format TypeGPU can understand. This doesn't alter the fact that the function is still callable from JavaScript, and behaves
the same on the CPU and GPU.

There are three main ways to use TypeGPU functions.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';
const root = await tgpu.init();

const neighborhood = (a: number, r: number) => {
  'use gpu';
  return d.vec2f(a - r, a + r);
};

// ---cut---
const main = () => {
  'use gpu';
  // Call from another function
  return neighborhood(1.1, 0.5);
};

// #1) Can be called in JS
const range = main();
//    ^?

// #2) Used to generate WGSL
const wgsl = tgpu.resolve({ externals: { main } });
//    ^?

// #3) Executed on the GPU (generates WGSL underneath)
root['~unstable']
  .createGuardedComputePipeline(main)
  .dispatchThreads();
````

The contents of the `wgsl` variable would contain the following:

```wgsl
// Generated WGSL
fn neighborhood(a: f32, r: f32) -> vec2f {
  return vec2f(a - r, a + r);
}

fn main() -> vec2f {
  return neighborhood(1.1, 0.5);
}

// ...
````

You can already notice a few things about TypeGPU functions:
- Using operators like `+`, `-`, `*`, `/`, etc. is perfectly valid on numbers.
- TS types are properly inferred, feel free to hover over the variables to see their types.
- The generated code closely matches your source code.

## Type inference

Let's take a closer look at `neighborhood` versus the WGSL it generates.

```ts
// TS
const neighborhood = (a: number, r: number) => {
  'use gpu';
  return d.vec2f(a - r, a + r);
};
```
```wgsl
// WGSL
fn neighborhood(a: f32, r: f32) -> vec2f {
  return vec2f(a - r, a + r);
}
```

How does TypeGPU determine that `a` and `r` are of type `f32`, and that the return type is `vec2f`? You might think that we parse the TypeScript source file and use the types
that the user provided in the function signature, **but that's not the case**.

While generating WGSL, TypeGPU infers the type of each expression, which means it knows the types of values passed in at each call site.

```ts twoslash "1.1, 0.5"
import * as d from 'typegpu/data';
const neighborhood = (a: number, r: number) => {
  'use gpu';
  return d.vec2f(a - r, a + r);
};
// ---cut---
const main = () => {
  'use gpu';
  // A very easy case, just floating point literals, so f32 by default
  return neighborhood(1.1, 0.5);
};
```

TypeGPU then propagates those types into the function body and analyses the types returned by the function.
If it cannot unify them into a single type, it will throw an error.

### Polymorphism

For each set of input types, TypeGPU generates a specialized version of the function.

```ts twoslash
import * as d from 'typegpu/data';
const neighborhood = (a: number, r: number) => {
  'use gpu';
  return d.vec2f(a - r, a + r);
};
// ---cut---
const main = () => {
  'use gpu';
  const a = neighborhood(0, 1);
  // We can also use casts to coerce values into a specific type.
  const b = neighborhood(d.u32(1), d.f16(5.25));
};
```

```wgsl
// WGSL
fn neighborhood(a: i32, r: i32) -> vec2f {
  return vec2f(f32(a - r), f32(a + r));
}

fn neighborhood2(a: u32, r: f16) -> vec2f {
  return vec2f(f32(f16(a) - r), f32(f16(a) + r));
}

fn main() {
  var a = neighborhood(0, 1);
  var b = neighborhood2(1, 5.25);
}
```

You can limit the types that a function can accept by using wrapping it in a shell.

### Generics

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';
import * as std from 'typegpu/std';
// ---cut---
const double = <T extends d.v2f | d.v3f | d.v4f>(a: T): T => {
  'use gpu';
  return std.mul(a, a);
};
```

## Bruh

In order to construct a TypeGPU function, you need to start by defining its shell, an object holding only the input and output types.
The shell constructor `tgpu.fn` relies on [TypeGPU schemas](/TypeGPU/fundamentals/data-schemas), objects that represent WGSL data types and assist in generating shader code at runtime.
It accepts two arguments:

- An array of schemas representing argument types,
- (Optionally) a schema representing the return type.

Then the actual WGSL implementation is passed in to a shell invocation using the tagged template literal.

The following code defines a function that accepts one argument of type `f32` and returns a `vec4f`.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const getGradientColor = tgpu.fn(
  [d.f32],
  d.vec4f
) /* wgsl */`(ratio: f32) -> vec4f {
  var purple = vec4f(0.769, 0.392, 1.0, 1);
  var blue = vec4f(0.114, 0.447, 0.941, 1);
  return mix(purple, blue, ratio);
}`;
```

:::tip
If you're using Visual Studio Code, you can use [this extension](https://marketplace.visualstudio.com/items?itemName=ggsimm.wgsl-literal) that brings syntax highlighting to the code fragments marked with `/* wgsl */` comments.
:::

Since type information is already present in the shell, the WGSL header can be simplified to include only the argument names.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

// ---cut---
const getGradientColor = tgpu.fn([d.f32], d.vec4f) /* wgsl */`(ratio) {
  var purple = vec4f(0.769, 0.392, 1.0, 1);
  var blue = vec4f(0.114, 0.447, 0.941, 1);
  return mix(purple, blue, ratio);
}`;
```

## Implementing functions in WGSL

:::note[Recommended reading]
We assume that you are familiar with the following concepts:
- <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html" target="_blank" rel="noopener noreferrer">WebGPU Fundamentals</a>
- <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl.html" target="_blank" rel="noopener noreferrer">WebGPU Shading Language</a>
:::

```ts
// "shelled" function:
//   Same as a "bare" function, but with restricted argument
//   and return types.
//
const rangeB = tgpu.fn([d.f32, d.f32], d.vec2f)((a, b) => {
  return d.vec2f(a + b, a - b).mul(multiplier);
});

// "shelled wgsl" function:
//   A shell defining the function's signature, and the
//   implementation in WGSL.
//
const rangeC = tgpu.fn([d.f32, d.f32], d.vec2f)`(a, b) {
  return vec2f(a + b, a - b) * multiplier;
}
`.$uses({ multiplier });
// ^ Giving the function access to the 'multiplier' external value
````

## External resources

Functions can use external resources passed via the `$uses` method.
Externals can include anything that can be resolved to WGSL by TypeGPU (numbers, vectors, matrices, constants, TypeGPU functions, buffer usages, textures, samplers, slots, accessors etc.).

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

// ---cut---
const getBlueFunction = tgpu.fn([], d.vec4f)`() {
  return vec4f(0.114, 0.447, 0.941, 1);
}`;

// calling a schema to create a value on the JS side
const purple = d.vec4f(0.769, 0.392, 1.0, 1);

const getGradientColor = tgpu.fn([d.f32], d.vec4f)`(ratio) {
  return mix(purple, getBlue(), ratio);;
}
`.$uses({ purple, getBlue: getBlueFunction });
```

You can check yourself what `getGradientColor` resolves to by calling [`tgpu.resolve`](/TypeGPU/fundamentals/resolve), all relevant definitions will be automatically included:

```wgsl
// results of calling tgpu.resolve({ externals: { getGradientColor } })
fn getBlueFunction_1() -> vec4f{
  return vec4f(0.114, 0.447, 0.941, 1);
}

fn getGradientColor_0(ratio: f32) -> vec4f{
  return mix(vec4f(0.769, 0.392, 1, 1), getBlueFunction_1(), ratio);;
}
```

## Entry functions

:::caution[Experimental]
Entry functions are an *unstable* feature. The API may be subject to change in the near future.
:::

Instead of annotating a `TgpuFn` with attributes, entry functions are defined using dedicated shell constructors:

- `tgpu['~unstable'].computeFn`,
- `tgpu['~unstable'].vertexFn`,
- `tgpu['~unstable'].fragmentFn`.

### Entry point function I/O

To describe the input and output of an entry point function, we use `IORecord`s, JavaScript objects that map argument names to their types.

```ts
const vertexInput = {
  idx: d.builtin.vertexIndex,
  position: d.vec4f,
  color: d.vec4f
}
```

As you may note, builtin inter-stage inputs and outputs are available on the `d.builtin` object,
and require no further type clarification.

Another thing to note is that there is no need to specify locations of the arguments,
as TypeGPU tries to assign locations automatically.
If you wish to, you can assign the locations manually with the `d.location` decorator.

During WGSL generation, TypeGPU automatically generates structs corresponding to the passed `IORecord`s.
In WGSL implementation, input and output structs of the given function can be referenced as `In` and `Out` respectively.
Headers in WGSL implementations must be omitted, all input values are accessible through the struct named `in`.

:::note
Schemas used in `d.struct` can be wrapped in `d.size` and `d.align` decorators,
corresponding to `@size` and `@align` WGSL attributes.

Since TypeGPU wraps `IORecord`s into automatically generated structs, you can also use those decorators in `IOStruct`s.
:::

### Compute

`TgpuComputeFn` accepts an object with two properties:

- `in` -- an `IORecord` describing the input of the function,
- `workgroupSize` -- a JS array of 1-3 numbers that corresponds to the `@workgroup_size` attribute.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const root = await tgpu.init();

const particleDataBuffer = root
  .createBuffer(d.arrayOf(d.u32, 100))
  .$usage('storage', 'uniform', 'vertex');

const deltaTime = root.createUniform(d.f32);
const time = root.createMutable(d.f32);
const particleDataStorage = particleDataBuffer.as('mutable');
// ---cut---
const mainCompute = tgpu['~unstable'].computeFn({
  in: { gid: d.builtin.globalInvocationId },
  workgroupSize: [1],
}) /* wgsl */`{
  let index = in.gid.x;
  if index == 0 {
    time += deltaTime;
  }
  let phase = (time / 300) + particleData[index].seed;
  particleData[index].position += particleData[index].velocity * deltaTime / 20 + vec2f(sin(phase) / 600, cos(phase) / 500);
}`.$uses({ particleData: particleDataStorage, deltaTime, time });
```

Resolved WGSL for the compute function above is equivalent (with respect to some cleanup) to the following:

```wgsl
@group(0) @binding(0) var<storage, read_write> particleData: array<u32, 100>;
@group(0) @binding(1) var<uniform> deltaTime: f32;
@group(0) @binding(2) var<storage, read_write> time: f32;

struct mainCompute_Input {
  @builtin(global_invocation_id) gid: vec3u,
}

@compute @workgroup_size(1) fn mainCompute(in: mainCompute_Input)  {
  let index = in.gid.x;
  if index == 0 {
    time += deltaTime;
  }
  let phase = (time / 300) + particleData[index].seed;
  particleData[index].position += particleData[index].velocity * deltaTime / 20 + vec2f(sin(phase) / 600, cos(phase) / 500);
}
```

### Vertex and fragment

`TgpuVertexFn` accepts an object with two properties:

- `in` -- an `IORecord` describing the input of the function,
- `out` -- an `IORecord` describing the output of the function.

`TgpuFragment` accepts an object with two properties:

- `in` -- an `IORecord` describing the input of the function,
- `out` -- `d.vec4f`, or an `IORecord` describing the output of the function.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const getGradientColor = tgpu.fn([d.f32], d.vec4f)``;
// ---cut---
const mainVertex = tgpu['~unstable'].vertexFn({
  in: { vertexIndex: d.builtin.vertexIndex },
  out: { outPos: d.builtin.position, uv: d.vec2f },
}) /* wgsl */`{
    var pos = array<vec2f, 3>(
      vec2(0.0, 0.5),
      vec2(-0.5, -0.5),
      vec2(0.5, -0.5)
    );

    var uv = array<vec2f, 3>(
      vec2(0.5, 1.0),
      vec2(0.0, 0.0),
      vec2(1.0, 0.0),
    );

    return Out(vec4f(pos[in.vertexIndex], 0.0, 1.0), uv[in.vertexIndex]);
  }`;

const mainFragment = tgpu['~unstable'].fragmentFn({
  in: { uv: d.vec2f },
  out: d.vec4f,
}) /* wgsl */`{
    return getGradientColor((in.uv[0] + in.uv[1]) / 2);
  }`.$uses({ getGradientColor });
```

Resolved WGSL for the pipeline including the two entry point functions above is equivalent (with respect to some cleanup) to the following:

```wgsl
struct mainVertex_Input {
  @builtin(vertex_index) vertexIndex: u32,
}

struct mainVertex_Output {
  @builtin(position) outPos: vec4f,
  @location(0) uv: vec2f,
}

@vertex fn mainVertex(in: mainVertex_Input) -> mainVertex_Output {
  var pos = array<vec2f, 3>(
    vec2(0.0, 0.5),
    vec2(-0.5, -0.5),
    vec2(0.5, -0.5)
  );

  var uv = array<vec2f, 3>(
    vec2(0.5, 1.0),
    vec2(0.0, 0.0),
    vec2(1.0, 0.0),
  );

  return mainVertex_Output(vec4f(pos[in.vertexIndex], 0.0, 1.0), uv[in.vertexIndex]);
}

fn getGradientColor(ratio: f32) -> vec4f{
  return mix(vec4f(0.769, 0.392, 1, 1), vec4f(0.114, 0.447, 0.941, 1), ratio);
}

struct mainFragment_Input {
  @location(0) uv: vec2f,
}

@fragment fn mainFragment(in: mainFragment_Input) -> @location(0) vec4f {
  return getGradientColor((in.uv[0] + in.uv[1]) / 2);
}
```

## Usage in pipelines

:::caution[Experimental]
Pipelines are an *unstable* feature. The API may be subject to change in the near future.
:::

Typed functions are crucial for simplified [pipeline](/TypeGPU/fundamentals/pipelines) creation offered by TypeGPU. You can define and run pipelines as follows:

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const context = undefined as any;
const presentationFormat = "rgba8unorm";
const root = await tgpu.init();

const getGradientColor = tgpu.fn([d.f32], d.vec4f)/* wgsl */``;

const mainVertex = tgpu['~unstable'].vertexFn({
  in: { vertexIndex: d.builtin.vertexIndex },
  out: { outPos: d.builtin.position, uv: d.vec2f },
})``;

const mainFragment = tgpu['~unstable'].fragmentFn({
  in: { uv: d.vec2f },
  out: d.vec4f,
})``;
// ---cut---
const pipeline = root['~unstable']
  .withVertex(mainVertex, {})
  .withFragment(mainFragment, { format: presentationFormat })
  .createPipeline();

pipeline
  .withColorAttachment({
    view: context.getCurrentTexture().createView(),
    clearValue: [0, 0, 0, 0],
    loadOp: 'clear',
    storeOp: 'store',
  })
  .draw(3);
```

The rendering result looks like this:
![rendering result - gradient triangle](./triangle-result.png)

You can check out the full example on [our examples page](/TypeGPU/examples#example=simple--triangle).
