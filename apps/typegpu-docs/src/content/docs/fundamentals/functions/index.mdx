---
title: Functions
description: A guide on how to create and use the TypeGPU typed functions.
---
// AAA linki do innych dokumentacji

:::note[Recommended reading]
We assume that you are familiar with the following concepts:
- <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-fundamentals.html" target="_blank" rel="noopener noreferrer">WebGPU Fundamentals</a>
- <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-wgsl.html" target="_blank" rel="noopener noreferrer">WebGPU Shading Language</a>
:::

WGSL (WebGPU Shading Language) lacks many quality-of-life features that help with building complex shaders, like the ability to split functionality across
different files, or to import a shader utility function from a library. TypeGPU offers a more composable and familiar approach:

- Each definition in WGSL is represented as its own TypeGPU resource (e.g., `tgpu.fn`).
- Resources can reference outside resources, like other user-defined or helper functions, buffers, bind group layouts, etc.
- Resources can be imported and exported like any other JavaScript value.

## Defining a function

In order to construct a tgpu function, you need to start with defining its shell -- an object holding only the input and output types of a tgpu function.
The shell constructor `tgpu.fn` makes use of TypeGPU schemas -- objects representing different WGSL data types, that help us with generating WGSL at runtime.
It accepts two arguments:

- An array of schemas representing argument types,
- (Optionally) a schema representing the return type.

Then the actual WGSL implementation is passed in to a shell invocation using the tagged function syntax (no parentheses).

The following code defines a function that accepts one argument of type `f32` and returns a `vec4f`.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const getGradientColor = tgpu.fn(
  [d.f32], 
  d.vec4f
) /* wgsl */`(ratio: f32) -> vec4f {
  var purple = vec4f(0.769, 0.392, 1.0, 1);
  var blue = vec4f(0.114, 0.447, 0.941, 1);
  return mix(purple, blue, ratio);
}`;
```

:::tip
If you're using Visual Studio Code, you can use [this extension](https://marketplace.visualstudio.com/items?itemName=ggsimm.wgsl-literal) that brings syntax highlighting to the code fragments marked with `/* wgsl */` comments.
:::

Since the information about types is already present in the shell, we allow for the WGSL header to be simplified to just include the argument names.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

// ---cut---
const getGradientColor = tgpu.fn([d.f32], d.vec4f) /* wgsl */`(ratio) {
  var purple = vec4f(0.769, 0.392, 1.0, 1);
  var blue = vec4f(0.114, 0.447, 0.941, 1);
  return mix(purple, blue, ratio);
}`;
```

## External resources

Functions can use external resources passed via the `$uses` method during the function creation process. 
Externals can include anything that can be resolved to WGSL by TypeGPU (numbers, vectors, matrices, constants, functions, buffer usages, textures, samplers, slots, accessors etc.).

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

// ---cut---
const getBlueFunction = tgpu.fn([], d.vec4f)`() {
  return vec4f(0.114, 0.447, 0.941, 1); 
}`;

// calling a schema to create a value on the JS side
const purple = d.vec4f(0.769, 0.392, 1.0, 1); 

const getGradientColor = tgpu.fn([d.f32], d.vec4f)`(ratio) {
  return mix(purple, getBlue(), ratio);;
}
`.$uses({ purple, getBlue: getBlueFunction });
```

You can check yourself what `getGradientColor` resolves to by calling `tgpu.resolve`, all relevant definitions will be automatically included:

```wgsl
// AAA update
// results of calling tgpu.resolve({ externals: { getGradientColor } })
fn getBlue_1() -> vec4f { 
  return vec4f(0.114, 0.447, 0.941, 1); 
}

fn getGradientColor_0(ratio: f32) -> vec4f {
  let color = mix(vec4f(0.769, 0.392, 1, 1), getBlue_1(), ratio);
  return color;
}
```

## Entry functions

:::caution[Experimental]
Entry functions are an *unstable* feature. The API may be subject to change in the near future.
:::

Entry point functions can be passed to root-defined pipelines so that TypeGPU creates shader modules with them under the hood.
Defining entry functions is similar to regular ones, but is done through dedicated shell constructors:

- `tgpu['~unstable'].vertexFn`
- `tgpu['~unstable'].fragmentFn`
- `tgpu['~unstable'].computeFn`

Shell constructors accept objects with special values like builtins (`d.builtin`) and decorated data (`d.location`). 

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const root = await tgpu.init();

const particleDataBuffer = root
  .createBuffer(d.arrayOf(d.u32, 100))
  .$usage('storage', 'uniform', 'vertex');

const deltaTime = root.createUniform(d.f32);
const time = root.createMutable(d.f32);
const particleDataStorage = particleDataBuffer.as('mutable');
// ---cut---
const mainCompute = tgpu['~unstable'].computeFn({
  in: { gid: d.builtin.globalInvocationId },
  workgroupSize: [1],
}) /* wgsl */`{
  let index = in.gid.x;
  if index == 0 {
    time += deltaTime;
  }
  let phase = (time / 300) + particleData[index].seed;
  particleData[index].position += particleData[index].velocity * deltaTime / 20 + vec2f(sin(phase) / 600, cos(phase) / 500);
}`.$uses({ particleData: particleDataStorage, deltaTime, time });
```

When entry function inputs or outputs are specified as objects containing builtins and inter-stage variables, the WGSL implementations need to access these arguments as passed in via structs.
TypeGPU schemas for these structs are created automatically by the library and their definitions are included when resolving the functions.
Input values are accessible through the `in` keyword, while the automatically created structs for input and output shall be referenced in implementation as `In` and `Out` respectively.

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const getGradientColor = tgpu.fn([d.f32], d.vec4f)``;
// ---cut---
const mainVertex = tgpu['~unstable'].vertexFn({
  in: { vertexIndex: d.builtin.vertexIndex },
  out: { outPos: d.builtin.position, uv: d.vec2f },
}) /* wgsl */`{
    var pos = array<vec2f, 3>(
      vec2(0.0, 0.5),
      vec2(-0.5, -0.5),
      vec2(0.5, -0.5)
    );

    var uv = array<vec2f, 3>(
      vec2(0.5, 1.0),
      vec2(0.0, 0.0),
      vec2(1.0, 0.0),
    );

    return Out(vec4f(pos[in.vertexIndex], 0.0, 1.0), uv[in.vertexIndex]);
  }`;

const mainFragment = tgpu['~unstable'].fragmentFn({
  in: { uv: d.vec2f },
  out: d.vec4f,
}) /* wgsl */`{
    return getGradientColor((in.uv[0] + in.uv[1]) / 2);
  }`.$uses({ getGradientColor });
```

## Usage in pipelines

:::caution[Experimental]
Pipelines are an *unstable* feature. The API may be subject to change in the near future.
:::

Typed functions are crucial for simplified pipeline creation offered by TypeGPU. You can define and run pipelines as follows:

```ts twoslash
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const context = undefined as any;
const presentationFormat = "rgba8unorm";
const root = await tgpu.init();

const getGradientColor = tgpu.fn([d.f32], d.vec4f)/* wgsl */``;

const mainVertex = tgpu['~unstable'].vertexFn({
  in: { vertexIndex: d.builtin.vertexIndex },
  out: { outPos: d.builtin.position, uv: d.vec2f },
})``;

const mainFragment = tgpu['~unstable'].fragmentFn({
  in: { uv: d.vec2f },
  out: d.vec4f,
})``;
// ---cut---
const pipeline = root['~unstable']
  .withVertex(mainVertex, {})
  .withFragment(mainFragment, { format: presentationFormat })
  .createPipeline();

pipeline
  .withColorAttachment({
    view: context.getCurrentTexture().createView(),
    clearValue: [0, 0, 0, 0],
    loadOp: 'clear',
    storeOp: 'store',
  })
  .draw(3);
```

The rendering result looks like this:
![rendering result - gradient triangle](./triangle-result.png)

You can check out the full example on [our examples page](/TypeGPU/examples#example=simple--triangle).
