---
title: Resolve
description: Resolve API can be used to extend shader code with WGSL definitions of TypeGPU-defined objects.
---

Defining shader schemas and objects in JS/TS has lots of benefits, but for a while it meant introducing significant duplication between host and GPU code.
In addition to that it was crucial to keep both sides in sync manually when making any changes.
To mitigate this problem TypeGPU offers the **`tgpu.resolve`** API, which allows there to be just one source of truth,
ensuring that the shader code is always up-to-date with the latest changes to the data schemas, bind group layouts and such. It takes WGSL code and all the external objects it uses, but doesn't declare, and returns the complete necessary WGSL code, ready to be used as part of a *GPUShaderModule*.

:::note
`tgpu.resolve` is essentially a dedicated TypeGPU linker.
:::

Here's an example:
```ts
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const LightSource = d.struct({
  ambientColor: d.vec3f,
  intensity: d.f32,
}).$name('Source');

const layout = tgpu.bindGroupLayout({
  lightSource: { uniform: LightSource },
  sampling: { sampler: 'filtering' },
  bgTexture: { externalTexture: {} },
}).$idx(0);

const rawShader = /* wgsl */ `
  @fragment
  fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
    var bgColor = textureSampleBaseClampToEdge(inputTexture, sampling, uv).rgb;

    var newSource: LightSource;
    newSource.ambientColor = bgColor + lightSource.ambientColor;
    newSource.intensity = 0.6 * lightSource.intensity;

    return vec4f(newSource.ambientColor * newSource.intensity, 1.);
  }
`;

const resolved = tgpu.resolve({
  input: rawShader,
  extraDependencies: {
    lightSource: layout.bound.lightSource,
    sampling: layout.bound.sampling,
    bgTexture: layout.bound.bgTexture,
    LightSource,
  },
  names: 'strict',
});
```

Resolved WGSL shader code is as follows:

```wgsl
struct Source {
  ambientColor: vec3f,
  intensity: f32,
}

@group(0) @binding(0) var<uniform> lightSource: Source;
@group(0) @binding(1) var sampling: sampler;
@group(0) @binding(2) var bgTexture: texture_external;

@fragment
fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
  var bgColor = textureSampleBaseClampToEdge(inputTexture, sampling, uv).rgb;

  var newSource: Source;
  newSource.ambientColor = bgColor + lightSource.ambientColor;
  newSource.intensity = 0.6 * lightSource.intensity;

  return vec4f(newSource.ambientColor * newSource.intensity, 1.);
}
```

* Input(s)

First argument of the `tgpu.resolve` function (`input`) is a string containing WGSL code, that is meant to be extended with additional definitions. Moreover it can be any TypeGPU object which can be represented as a WGSL declaration. It is also possible to pass in an array of arguments, which resolutions are later concatenated to a single string output.

* Extra dependencies

Another (optional) argument is `extraDependencies` -- a record with TypeGPU objects that are to be included in the final resolved shader code. The values in the record are the objects themselves, while the keys are the names by which they are referenced in the input code. 

What differentiates the extra dependencies from inputs is that beside the dependencies being resolved to WGSL string declarations and added to the output string, all their references in resolved input code are also replaced with their new names. 
Therefore it is very important to put objects in *extraDependencies* (instead of *input*) when they are being referenced in raw WGSL snippets passed as inputs. If an object is being referenced only by another TypeGPU object to be resolved, it doesn't have to be included in *extraDependencies*, example: a bindGroupLayout including a struct data type that isn't referenced in any code snippet otherwise.

:::note
To resolve bindings you can access each entry of a bindGroupLayout via the `layout.bound` property.

```ts
  extraDependencies: {
    lightSource: layout.bound.lightSource,
    sampling: layout.bound.sampling,
    bgTexture: layout.bound.bgTexture,
  }

  // can be shortened to:
  extraDependencies: {
    { ...layout.bound },
  }
```
:::

* Name registry

When extra dependencies are being resolved, they are given new names based on the specified naming registry type (argument `names`).
The default naming schema is `random`. It uses labels assigned to the objects via *.$name* method or, if they aren't present, the keys in the *extraDependencies* record. 
In this mode however labels are later transformed to match the allowed identifier pattern, as well as include some unique suffix to ensure that no identifiers conflict with each other. 

Another allowed value of the parameter is `strict` which names resolved objects in the WGSL code exactly as they are labeled by the user in JS, 
unless there is a name conflict, then a suffix is added. 
If there is no explicit *.$name* call, an object is named based on its associated key in *extraDependencies*. 
This approach makes all of the generated identifiers predictable, but demands that all labels are valid identifiers 
and requires explicit naming (via `.$name`) of all of the objects that aren't immediate values in the *extraDependencies* record.
