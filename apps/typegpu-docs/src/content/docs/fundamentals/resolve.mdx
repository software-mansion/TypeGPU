---
title: Resolve
description: Resolve API can be used to extend shader code with WGSL definitions of TypeGPU-defined objects.
---

Defining shader schemas and objects in JS/TS has lots of benefits, but for a while it meant introducing significant duplication between host and GPU code.
In addition to that it was crucial to keep both sides in sync manually when making any changes.
To mitigate this problem TypeGPU offers the **`tgpu.resolve`** API, which allows there to be just one source of truth,
ensuring that the shader code is always up-to-date with the latest changes to the data schemas, bind group layouts and such. 
It takes WGSL code and all the external objects it uses, but doesn't declare, and returns the complete necessary WGSL code, ready to be used as part of a *GPUShaderModule*.

:::note
`tgpu.resolve` is essentially a dedicated TypeGPU linker.
:::

Here's an example:
```ts
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const LightSource = d.struct({
  ambientColor: d.vec3f,
  intensity: d.f32,
}).$name('Source');

const layout = tgpu.bindGroupLayout({
  lightSource: { uniform: LightSource },
  sampling: { sampler: 'filtering' },
  bgTexture: { externalTexture: {} },
}).$idx(0);

const rawShader = /* wgsl */ `
  @fragment
  fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
    var bgColor = textureSampleBaseClampToEdge(inputTexture, sampling, uv).rgb;

    var newSource: LightSource;
    newSource.ambientColor = bgColor + lightSource.ambientColor;
    newSource.intensity = 0.6 * lightSource.intensity;

    return vec4f(newSource.ambientColor * newSource.intensity, 1.);
  }
`;

const resolved = tgpu.resolve({
  template: rawShader,
  externals: {
    lightSource: layout.bound.lightSource,
    sampling: layout.bound.sampling,
    bgTexture: layout.bound.bgTexture,
    LightSource,
  },
  names: 'strict',
});
```

Resolved WGSL shader code is as follows:

```wgsl
struct Source {
  ambientColor: vec3f,
  intensity: f32,
}

@group(0) @binding(0) var<uniform> lightSource: Source;
@group(0) @binding(1) var sampling: sampler;
@group(0) @binding(2) var bgTexture: texture_external;

@fragment
fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
  var bgColor = textureSampleBaseClampToEdge(inputTexture, sampling, uv).rgb;

  var newSource: Source;
  newSource.ambientColor = bgColor + lightSource.ambientColor;
  newSource.intensity = 0.6 * lightSource.intensity;

  return vec4f(newSource.ambientColor * newSource.intensity, 1.);
}
```

## Template

This optional property of the `tgpu.resolve` function argument is a string containing WGSL code, that is meant to be extended with additional definitions. 
It can contain references to objects passed in the `externals` record.

## Externals

This is a record with TypeGPU objects that are to be included in the final resolved shader code. 
The values in the mapping are the objects themselves, while the keys are the names by which they are referenced in the template code.
Each object is resolved to its WGSL declaration, which is included in the final shader code.
Moreover each reference to the object in the template is replaced with the name used in its newly generated declaration.

If an object is being referenced only by another TypeGPU object in *externals*, it doesn't have to be included in the record.
Any passed-in object's dependencies are automatically resolved and included in the final result.

:::note
To resolve bindings you can access each entry of a [bindGroupLayout](/TypeGPU/fundamentals/bind-groups) via the `layout.bound` property.

```ts
  externals: {
    lightSource: layout.bound.lightSource,
    sampling: layout.bound.sampling,
    bgTexture: layout.bound.bgTexture,
  }

  // can be shortened to:
  externals: {
    { ...layout.bound },
  }
```
:::

## Name registry

When externals are being resolved, they are given new names based on the specified naming registry type (parameter `names`).

The default naming schema is `random`. It uses labels assigned to the objects via *.$name* method or, if they aren't present, the keys in the *externals* record. 
In this mode labels are later transformed to match the allowed identifier pattern, as well as include some unique suffix to ensure that no identifiers conflict with each other. 

Another allowed value of the parameter is `strict` which names resolved objects in the WGSL code exactly as they are labeled by the user in JS, 
unless there is a name conflict, then a suffix is added. 
If there is no explicit *.$name* call, an object is named based on its associated key in *externals*. 
This approach makes all of the generated identifiers predictable, but demands that all labels are valid identifiers 
and requires explicit naming (via `.$name`) of all objects that aren't immediate values in the *externals* record.
