---
title: Resolve
description: Resolve API can be used to extend shader code with WGSL definitions of TypeGPU-defined objects.
---

Defining shader schemas and objects in JS/TS has lots of benefits, but for a while it meant introducing significant duplication between host and GPU code.
In addition to that it was crucial to keep both sides in sync manually when making any changes.
To mitigate this problem TypeGPU offers the **`tgpu.resolve`** API, which allows there to be just one source of truth,
ensuring that the shader code is always up-to-date with the latest changes to the data schemas, bind group layouts and such. It takes WGSL code and all the external objects it uses, but doesn't declare, and returns the complete necessary WGSL code, ready to be used as part of a *GPUShaderModule*.

:::note
`tgpu.resolve` is essentially a dedicated TypeGPU linker.
:::

Here's an example:

```ts
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const LightSource = d.struct({
  ambientColor: d.vec3f,
  intensity: d.f32,
}).$name('Source');

const layout = tgpu.bindGroupLayout({
  lightSource: { uniform: LightSource },
  sampling: { sampler: 'filtering' },
  bgTexture: { externalTexture: {} },
});

const rawShader = /* wgsl */ `
  @fragment
  fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
    var bgColor = textureSampleBaseClampToEdge(inputTexture, sampling, uv).rgb;

    var newSource: LightSource;
    newSource.ambientColor = bgColor + lightSource.ambientColor;
    newSource.intensity = 0.6 * lightSource.intensity;

    return vec4f(newSource.ambientColor * newSource.intensity, 1.);
  }
`;

const resolved = tgpu.resolve({
  input: rawShader,
  extraDependencies: {
    lightSource: layout.bound.lightSource,
    sampling: layout.bound.sampling,
    bgTexture: layout.bound.bgTexture,
    LightSource,
  },
});

```
Resolved WGSL shader code is as follows:

```wgsl
struct Source_1 {
  ambientColor: vec3f,
  intensity: f32,
}

@group(0) @binding(0) var<uniform> lightSource_0: Source_1;
@group(0) @binding(1) var sampling_2: sampler;
@group(0) @binding(2) var bgTexture_3: texture_external;

@fragment
fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
  var bgColor = textureSampleBaseClampToEdge(inputTexture, sampling_2, uv).rgb;

  var newSource: Source_1;
  newSource.ambientColor = bgColor + lightSource_0.ambientColor;
  newSource.intensity = 0.6 * lightSource_0.intensity;

  return vec4f(newSource.ambientColor * newSource.intensity, 1.);
}
```

* Input(s)

First argument of the `tgpu.resolve` function (`input`) is a string containing WGSL code, that is meant to be extended with additional definitions. Moreover it can be any TypeGPU object which can be represented as a WGSL declaration. It is also possible to pass in an array of arguments, which resolutions are later concatenated to a single string output.

* Extra dependencies

Another (optional) argument is `extraDependencies` -- a record with TypeGPU objects that are to be included in the final resolved shader code. The values in the record are the objects themselves, while the keys are the names by which they are referenced in the input code. 

What differentiates the extra dependencies from inputs is that beside the dependencies being resolved to WGSL string declarations and added to the output string, all their references in resolved input code are also replaced with their new names. Therefore it is very important to put objects in `extraDependencies` (instead of `input`) when they are being referenced in raw WGSL snippets passed as inputs. If an object is being referenced only by another TypeGPU object to be resolved, it doesn't have to be included in *extraDependencies*, example: a bindGroupLayout including a struct data type that isn't referenced in any code snippet otherwise.

:::note
To resolve bindings you can access each entry of a bindGroupLayout via the `layout.bound` property.

```ts
  extraDependencies: {
    lightSource: layout.bound.lightSource,
    sampling: layout.bound.sampling,
    bgTexture: layout.bound.bgTexture,
  }

  // can be shortened to:
  extraDependencies: {
    { ...layout.bound },
  }
```
:::

* Name registry

When extra dependencies are being resolved, they are given new name based on the specified naming registry type (argument `names`).
The default naming schema is `random`. It uses labels given to the objects via `.$name` method, but appends some unique suffix to them to ensure that no identifiers conflict with each other. 

Another allowed value of the parameter is `strict` which names resolved objects in the WGSL code exactly as they are labeled by the user in JS.
If there is no explicit `.$name` call, an object is named based on its associated key in the `extraDependencies` record. This approach makes all of the generated identifiers predictable, but requires the user to make sure no two labels repeat.

```ts
import tgpu from 'typegpu';
import * as d from 'typegpu/data';

const LightSource = d.struct({
  ambientColor: d.vec3f,
  intensity: d.f32,
}).$name('Source');

const layout = tgpu.bindGroupLayout({
  lightSource: { uniform: LightSource },
  sampling: { sampler: 'filtering' },
  bgTexture: { externalTexture: {} },
});

const rawShader = /* wgsl */ `
  @fragment
  fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
    var bgColor = textureSampleBaseClampToEdge(inputTexture, sampling, uv).rgb;

    var newSource: LightSource;
    newSource.ambientColor = bgColor + lightSource.ambientColor;
    newSource.intensity = 0.6 * lightSource.intensity;

    return vec4f(newSource.ambientColor * newSource.intensity, 1.);
  }
`;

const resolved = tgpu.resolve({
  input: rawShader,
  extraDependencies: {
    lightSource: layout.bound.lightSource,
    sampling: layout.bound.sampling,
    bgTexture: layout.bound.bgTexture,
    LightSource,
  },
  names: 'strict',
});
```

In that case the resolved WGSL shader code looks like this:

```wgsl
struct Source {
  ambientColor: vec3f,
  intensity: f32,
}

@group(0) @binding(0) var<uniform> lightSource: Source;
@group(0) @binding(1) var sampling: sampler;
@group(0) @binding(2) var bgTexture: texture_external;

@fragment
fn main(@location(0) uv: vec2f) -> @location(0) vec4f {
  var bgColor = textureSampleBaseClampToEdge(inputTexture, sampling, uv).rgb;

  var newSource: Source;
  newSource.ambientColor = bgColor + lightSource.ambientColor;
  newSource.intensity = 0.6 * lightSource.intensity;

  return vec4f(newSource.ambientColor * newSource.intensity, 1.);
}
```
