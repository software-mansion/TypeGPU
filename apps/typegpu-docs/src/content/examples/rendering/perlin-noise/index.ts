import tgpu, { type TgpuFn } from 'typegpu';
import * as d from 'typegpu/data';
import { perlin3d } from '@typegpu/noise';
import { abs, mix, mul, pow, sign, tanh } from 'typegpu/std';

/** The depth of the perlin noise (in time), after which the pattern loops around */
const DEPTH = 10;

const fullScreenTriangle = tgpu['~unstable'].vertexFn({
  in: { vertexIndex: d.builtin.vertexIndex },
  out: { pos: d.builtin.position, uv: d.vec2f },
})((input) => {
  const pos = [d.vec2f(-1, -1), d.vec2f(3, -1), d.vec2f(-1, 3)];

  return {
    pos: d.vec4f(pos[input.vertexIndex], 0.0, 1.0),
    uv: mul(0.5, pos[input.vertexIndex]),
  };
});

const gridSizeAccess = tgpu['~unstable'].accessor(d.f32);
const timeAccess = tgpu['~unstable'].accessor(d.f32);
const sharpnessAccess = tgpu['~unstable'].accessor(d.f32);

const exponentialSharpen = tgpu.fn([d.f32, d.f32], d.f32)((n, sharpness) =>
  sign(n) * pow(abs(n), 1 - sharpness)
);

const tanhSharpen = tgpu.fn([d.f32, d.f32], d.f32)((n, sharpness) =>
  tanh(n * (1 + sharpness * 10))
);

const sharpenFnSlot = tgpu.slot<TgpuFn<(n: d.F32, sharpness: d.F32) => d.F32>>(
  exponentialSharpen,
);

const mainFragment = tgpu['~unstable'].fragmentFn({
  in: { uv: d.vec2f },
  out: d.vec4f,
})((input) => {
  const uv = mul(gridSizeAccess.$, input.uv);

  const n = perlin3d.sample(d.vec3f(uv, timeAccess.$));

  // Apply sharpening function
  const sharp = sharpenFnSlot.$(n, sharpnessAccess.$);

  // Map to 0-1 range
  const n01 = sharp * 0.5 + 0.5;

  // Gradient map
  const dark = d.vec3f(0, 0.2, 1);
  const light = d.vec3f(1, 0.3, 0.5);
  return d.vec4f(mix(dark, light, n01), 1);
});

// Configuring a dynamic (meaning it's size can change) cache
// for perlin noise gradients.
const perlinCacheConfig = perlin3d.dynamicCacheConfig();

/** Contains all resources that the perlin cache needs access to */
const dynamicLayout = tgpu.bindGroupLayout({ ...perlinCacheConfig.layout });

const root = await tgpu.init();
const device = root.device;

// Instantiating the cache with an initial size.
const perlinCache = perlinCacheConfig.instance(root, d.vec3u(4, 4, DEPTH));

const canvas = document.querySelector('canvas') as HTMLCanvasElement;
const context = canvas.getContext('webgpu') as GPUCanvasContext;
const presentationFormat = navigator.gpu.getPreferredCanvasFormat();
context.configure({
  device,
  format: presentationFormat,
  alphaMode: 'premultiplied',
});

const gridSize = root.createUniform(d.f32);
const time = root.createUniform(d.f32, 0);
const sharpness = root.createUniform(d.f32, 0.1);

const renderPipelineBase = root['~unstable']
  .with(gridSizeAccess, gridSize)
  .with(timeAccess, time)
  .with(sharpnessAccess, sharpness)
  .pipe(perlinCacheConfig.inject(dynamicLayout.$));

const renderPipelines = {
  exponential: renderPipelineBase
    .with(sharpenFnSlot, exponentialSharpen)
    .withVertex(fullScreenTriangle, {})
    .withFragment(mainFragment, { format: presentationFormat })
    .createPipeline(),
  tanh: renderPipelineBase
    .with(sharpenFnSlot, tanhSharpen)
    .withVertex(fullScreenTriangle, {})
    .withFragment(mainFragment, { format: presentationFormat })
    .createPipeline(),
};

let activeSharpenFn: 'exponential' | 'tanh' = 'exponential';

let isRunning = true;
let bindGroup = root.createBindGroup(dynamicLayout, perlinCache.bindings);

function draw(timestamp: number) {
  if (!isRunning) {
    return;
  }

  time.write(timestamp * 0.0002 % DEPTH);

  renderPipelines[activeSharpenFn]
    .with(dynamicLayout, bindGroup)
    .withColorAttachment({
      view: context.getCurrentTexture().createView(),
      loadOp: 'clear',
      storeOp: 'store',
    })
    .draw(3);

  requestAnimationFrame(draw);
}

requestAnimationFrame(draw);

export const controls = {
  'grid size': {
    initial: '4',
    options: [1, 2, 4, 8, 16, 32, 64, 128, 256].map((x) => x.toString()),
    onSelectChange: (value: string) => {
      const iSize = Number.parseInt(value);
      perlinCache.size = d.vec3u(iSize, iSize, DEPTH);
      gridSize.write(iSize);
      bindGroup = root.createBindGroup(dynamicLayout, perlinCache.bindings);
    },
  },
  'sharpness': {
    initial: 0.5,
    min: 0,
    max: 0.99,
    step: 0.01,
    onSliderChange: (value: number) => sharpness.write(value),
  },
  'sharpening function': {
    initial: 'exponential',
    options: ['exponential', 'tanh'],
    onSelectChange: (value: 'exponential' | 'tanh') => {
      activeSharpenFn = value;
    },
  },
};

export function onCleanup() {
  isRunning = false;
  root.destroy();
}
