// oxlint-disable typescript/no-unnecessary-type-assertion -- import.meta.glob is inferred incorrectly by oxlint
import pathe from 'pathe';
import * as R from 'remeda';
import type {
  Example,
  ExampleCommonFile,
  ExampleMetadata,
  ExampleSrcFile,
  ThumbnailPair,
} from '../utils/examples/types.ts';

function extractUrlFromViteImport(importFn: () => void): [URL | undefined, boolean] {
  const filePath = String(importFn);
  const match = filePath.match(/\(\)\s*=>\s*import\("([^"]+)"\)/);

  if (match?.[1]) {
    const isRelative = match[1].startsWith('./');
    return [new URL(match[1], window.location.origin), isRelative];
  }

  return [undefined, false];
}

function noCacheImport<T>(importFn: () => Promise<T>): Promise<T> {
  const [url, isRelative] = extractUrlFromViteImport(importFn);

  if (!url) {
    throw new Error(`Could not no-cache-import using ${importFn}`);
  }

  url.searchParams.append('update', Date.now().toString());
  return import(/* @vite-ignore */ `${isRelative ? '.' : ''}${url.pathname}${url.search}`);
}

function pathToExampleKey(path: string): string {
  return R.pipe(
    path,
    (p) => pathe.relative('./', p), // removing parent folder
    (p) => p.split('/'), // splitting into segments
    ([category, name]) => `${category}--${name}`,
  );
}

function pathToRelativePath(path: string): string {
  const pathRelToExamples = pathe.relative('./', path);
  const categoryDir = pathRelToExamples.split('/')[0];
  const exampleDir = pathRelToExamples.split('/')[1];
  const examplePath = pathe.join(categoryDir, exampleDir);

  return pathe.relative(examplePath, path);
}

const metaFiles = R.pipe(
  import.meta.glob('./**/meta.json', {
    eager: true,
    import: 'default',
  }) as Record<string, ExampleMetadata>,
  R.mapKeys(pathToExampleKey),
);

// Files that were generated by stripping away use of overloaded operators in .ts files
// './<category>/<example>/<file>.tsnotover.ts'
const exampleTsnotoverFiles = import.meta.glob('./*/*/*.tsnotover.ts', {
  query: 'raw',
  eager: true,
  import: 'default',
}) as Record<string, string>;

const exampleTsFiles = R.pipe(
  // './<category>/<example>/<file>.ts'
  import.meta.glob('./*/*/*.ts', {
    query: 'raw',
    eager: true,
    import: 'default',
  }) as Record<string, string>,
  R.entries(),
  R.filter(([key]) => !key.endsWith('.tsnotover.ts')),
  R.map(
    ([key, content]): ExampleSrcFile => ({
      exampleKey: pathToExampleKey(key),
      path: pathToRelativePath(key),
      content,
      tsnotoverContent: exampleTsnotoverFiles[`${key}notover.ts`],
    }),
  ),
  R.groupBy(R.prop('exampleKey')),
);

const tsFilesImportFunctions = R.pipe(
  import.meta.glob('./**/index.ts') as Record<string, () => Promise<unknown>>,
  R.mapKeys(pathToExampleKey),
);

const htmlFiles = R.pipe(
  import.meta.glob('./**/index.html', {
    query: 'raw',
    eager: true,
    import: 'default',
  }) as Record<string, string>,
  R.entries(),
  R.map(
    ([key, content]): ExampleSrcFile => ({
      exampleKey: pathToExampleKey(key),
      path: pathToRelativePath(key),
      content,
    }),
  ),
  R.groupBy(R.prop('exampleKey')),
);

const thumbnailFiles = R.pipe(
  import.meta.glob('./**/thumbnail.png', {
    eager: true,
    import: 'default',
    query: 'w=512;1024',
  }) as Record<string, string | [string, string]>,
  R.mapKeys(pathToExampleKey),
  R.mapValues((value, key): ThumbnailPair => {
    if (typeof value === 'string') {
      throw new Error(
        `Thumbnail for example "${key}" is too small (required width is at least 513 pixels).`,
      );
    }
    return { small: value[0], large: value[1] };
  }),
);

export const examples = R.pipe(
  metaFiles,
  R.mapValues(
    (value, key) =>
      ({
        key,
        metadata: value,
        tsFiles: exampleTsFiles[key] ?? [],
        tsImport: () => noCacheImport(tsFilesImportFunctions[key]),
        htmlFile: htmlFiles[key]?.[0] ?? '',
        thumbnails: thumbnailFiles[key],
      }) satisfies Example,
  ),
);

export const examplesByCategory = R.groupBy(
  Object.values(examples),
  (example) => example.metadata.category,
);

export const common = R.pipe(
  import.meta.glob('./common/*.ts', {
    query: 'raw',
    eager: true,
    import: 'default',
  }) as Record<string, string>,
  R.mapValues(
    (content: string, key: string): ExampleCommonFile => ({
      common: true,
      path: pathe.basename(key),
      content,
    }),
  ),
  R.values(),
);

export const PLAYGROUND_KEY = 'playground__';
